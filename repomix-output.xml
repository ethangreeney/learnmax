This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
prisma/
  migrations/
    20250807100731_init/
      migration.sql
    migration_lock.toml
  schema.prisma
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
src/
  app/
    api/
      auth/
        [...nextauth]/
          route.ts
      breakdown/
        route.ts
      chat/
        route.ts
      explain/
        route.ts
      explain-db/
        route.ts
      lectures/
        [lectureId]/
          route.ts
        route.ts
      mastery/
        route.ts
      quiz/
        route.ts
      upload-pdf/
        route.ts
      whoami/
        route.ts
    dashboard/
      page.tsx
    learn/
      [lectureId]/
        page.tsx
      page.tsx
      page.tsx.bak_1754565157
      page.tsx.bak_placeholder_1754565535
      page.tsx.bak_save_open
    globals.css
    layout.tsx
    page.tsx
  components/
    AuthProvider.tsx
    ChatPanel.tsx
    ClientBoundary.tsx
    LearnView.tsx
    LearnView.tsx.bak_fixmerge_1754565868
    LearnView.tsx.bak_fixsyntax_1754565820
    LearnView.tsx.bak_mergeSave_1754565785
    LearnView.tsx.bak_sidebar_1754565963
    LearnView.tsx.bak_sidebar_1754565969
    LearnView.tsx.bak_spacing_1754565674
    LearnView.tsx.bak2
    LearnView.tsx.bak3
    SignInOut.tsx
  lib/
    client/
      learn-ui-store.ts
      lectures.ts
      rename-lecture.ts
    shared/
      learn-types.ts
    ai.ts
    auth.ts
    learn-store.ts
    prisma.ts
    store.ts
.gitignore
.prettierignore
.prettierrc.json
eslint.config.mjs
next.config.ts
package.json
PHASE5_NOTES.md
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/app/learn/page.tsx.bak_placeholder_1754565535">
// 'use client' makes this a valid client component with a default export.
'use client';

import { useState } from 'react';

async function createLectureFromText(
  content: string
): Promise<{ lectureId: string }> {
  const res = await fetch('/api/lectures', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content }),
  });
  if (!res.ok) {
    const e = await res.json().catch(() => ({}));
    throw new Error(e.error || `Failed: ${res.status}`);
  }
  return res.json();
}

export default function LearnWorkspacePage() {
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  const handleCreate = async () => {
    const text = input.trim();
    if (!text || loading) return;
    setLoading(true);
    setErr(null);
    try {
      const { lectureId } = await createLectureFromText(text);
      window.location.href = `/learn/${lectureId}`;
    } catch (e: any) {
      setErr(e.message || 'Failed to create lecture.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container-narrow space-y-6">
      <header>
        <h1 className="text-2xl font-bold tracking-tight">Learn Workspace</h1>
        <p className="text-sm text-neutral-400">
          Paste text and create a persistent lecture. You’ll be redirected to
          the lecture page with explanations and quizzes.
        </p>
      </header>

      <div className="space-y-4 rounded-lg border border-neutral-800 p-4">
        <textarea
          className="min-h-[160px] w-full rounded-md bg-neutral-900 p-3 ring-1 ring-neutral-700 outline-none"
          placeholder="What do you want to learn about? paste any study notes or PDF lecture slides here"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          disabled={loading}
        />
        <div className="flex gap-2">
          <button
            onClick={handleCreate}
            disabled={loading || !input.trim()}
            className="rounded-md bg-white px-4 py-2 font-medium text-black disabled:opacity-50"
          >
            {loading ? 'Creating…' : 'Create Lecture'}
          </button>
          <button
            onClick={() => setInput('')}
            disabled={loading}
            className="rounded-md border border-neutral-700 px-4 py-2 text-neutral-200 disabled:opacity-50"
          >
            Reset
          </button>
        </div>
        {err && (
          <div className="text-sm text-red-400" role="alert">
            {err}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/LearnView.tsx.bak_fixmerge_1754565868">
'use client';

import { useMemo, useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type LearnSubtopic,
  type QuizQuestion,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';
import { renameLecture } from '@/lib/client/rename-lecture';

export default function LearnView({ initial }: { initial: LearnLecture }) {
  // Initialize UI-only store
  const initialUnlocked = deriveUnlockedIndex(initial.subtopics);
  const storeRef = useRef(
    createLearnUIStore({
      currentIndex: initialUnlocked,
      unlockedIndex: initialUnlocked,
    })
  );
  const ui = storeRef.current;

  const currentSubtopic = initial.subtopics[ui.getState().currentIndex];

  // Local title editing state
  const [title, setTitle] = useState(initial.title);
  const [isSavingTitle, setIsSavingTitle] = useState(false);
  const [saveMsg, setSaveMsg] = useState<string | null>(null);

  // "Saved to Dashboard" is inherent once lecture exists in DB; we just expose a button for UX// Explanations cache per subtopic
  const [explanations, setExplanations] = useState<Record<string, string>>(() =>
    Object.fromEntries(
      initial.subtopics.map((s) => [s.id, s.explanation || ''])
    )
  );

  const canSelect = (i: number) => i <= ui.getState().unlockedIndex;

  useEffect(() => {
    const u = deriveUnlockedIndex(initial.subtopics);
    ui.setState((s) => ({
      ...s,
      unlockedIndex: Math.max(u, s.unlockedIndex),
      currentIndex: Math.max(
        0,
        Math.min(s.currentIndex, initial.subtopics.length - 1)
      ),
    }));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initial.subtopics.map((s) => s.mastered).join('|')]);

  const fetchExplanation = useCallback(
    async (
      style: 'default' | 'simplified' | 'detailed' | 'example' = 'default'
    ) => {
      const s = currentSubtopic;
      if (!s) return;
      setExplanations((e) => ({ ...e, [s.id]: 'Loading...' }));
      try {
        const res = await fetch('/api/explain-db', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ subtopicId: s.id, style }),
        });
        if (!res.ok) {
          const e = await res.json().catch(() => ({}));
          throw new Error(e.error || `HTTP ${res.status}`);
        }
        const data = (await res.json()) as { explanation: string };
        setExplanations((e) => ({ ...e, [s.id]: data.explanation }));
      } catch (e: any) {
        setExplanations((ex) => ({
          ...ex,
          [s.id]: 'Could not generate explanation. ' + e.message,
        }));
      }
    },
    [currentSubtopic]
  );

  useEffect(() => {
    const s = currentSubtopic;
    if (s && !explanations[s.id]) {
      fetchExplanation('default');
    }
  }, [currentSubtopic, explanations, fetchExplanation]);

  const handleRename = async () => {
    if (!title.trim() || title.trim().length < 3) {
      setSaveMsg('Title must be at least 3 characters.');
      return;
    }
    try {
      setIsSavingTitle(true);
      setSaveMsg(null);
      const res = await renameLecture(initial.id, title.trim());
      setSaveMsg('Lecture title saved.');
    } catch (e: any) {
      setSaveMsg(e.message || 'Failed to save title.');
    } finally {
      setIsSavingTitle(false);
      setTimeout(() => setSaveMsg(null), 2500);
    }
  };

  const handleSaveToDashboard = async () => {
    // The lecture already exists in DB; we simply give user feedback and a quick link.
    setSavedHint('Saved! You can access this lecture on your Dashboard.');
    setTimeout(() => setSavedHint(null), 2500);
  };

  return (
    <div className="grid grid-cols-1 gap-8 px-4 lg:grid-cols-10">
      {/* Left: Outline */}
      <aside className="space-y-4 self-start rounded-lg border border-neutral-800 p-4 lg:col-span-2">
        <h2 className="text-xl font-semibold">Lecture</h2>

        {/* Rename row */}
        <div className="flex flex-wrap items-center gap-2">
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full rounded-md bg-neutral-900 px-3 py-2 ring-1 ring-neutral-700 outline-none"
            aria-label="Lecture title"
          />
          <button
            onClick={handleRename}
            disabled={isSavingTitle || title.trim().length < 3}
            className="rounded-md bg-white px-3 py-2 text-sm font-medium whitespace-nowrap text-black disabled:opacity-50"
          >
            {isSavingTitle ? 'Saving...' : 'Save'}
          </button>
        </div>
        {saveMsg && <div className="text-xs text-neutral-400">{saveMsg}</div>

        

        <div className="mt-4 mb-2">
          <div className="text-sm text-neutral-400 uppercase">Title</div>
          <div className="text-lg font-semibold">{title}</div>
        </div>

        <ul className="space-y-1">
          {initial.subtopics.map((s, i) => (
            <li key={s.id}>
              <button
                onClick={() => canSelect(i) && ui.setState({ currentIndex: i })}
                disabled={!canSelect(i)}
                className={`w-full rounded-md px-3.5 py-3 text-left text-sm leading-snug transition-colors ${
                  i > ui.getState().unlockedIndex
                    ? 'text-neutral-600'
                    : i === ui.getState().currentIndex
                      ? 'bg-neutral-800 font-semibold text-white'
                      : 'text-neutral-300 hover:bg-neutral-900'
                }`}
              >
                {i + 1}. {s.title}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      {/* Center: Explanation + Quiz */}
      <main className="lg:col-span-5">
        {currentSubtopic ? (
          <div className="space-y-8">
            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="text-3xl font-bold tracking-tight">
                {currentSubtopic.title}
              </h3>
              <div className="mt-2 flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-neutral-400">
                <span>Importance: {currentSubtopic.importance}</span>{' '}
                <span>•</span>{' '}
                <span>Difficulty: {currentSubtopic.difficulty}</span>
              </div>
              <div className="mt-6 flex items-center gap-2 border-t border-neutral-800/50 pt-4">
                <span className="text-sm font-medium text-neutral-400">
                  Style:
                </span>
                <button
                  onClick={() => fetchExplanation('default')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Default
                </button>
                <button
                  onClick={() => fetchExplanation('simplified')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Simplified
                </button>
                <button
                  onClick={() => fetchExplanation('detailed')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Detailed
                </button>
                <button
                  onClick={() => fetchExplanation('example')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Example
                </button>
              </div>
              <hr className="my-6 border-neutral-800" />
              <div className="markdown">
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {explanations[currentSubtopic.id] || 'Loading...'}
                </ReactMarkdown>
              </div>
            </div>

            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="mb-6 text-2xl font-bold tracking-tight">
                Mastery Check
              </h3>
              <QuizPanel
                key={currentSubtopic.id}
                questions={currentSubtopic.questions}
                onPassed={async () => {
                  try {
                    const res = await fetch('/api/mastery', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ subtopicId: currentSubtopic.id }),
                    });
                    if (!res.ok)
                      throw new Error((await res.json()).error || 'HTTP');
                    // Unlock next subtopic locally
                    const idx = ui.getState().currentIndex;
                    const next = Math.min(
                      idx + 1,
                      initial.subtopics.length - 1
                    );
                    ui.setState({
                      currentIndex: next,
                      unlockedIndex: Math.max(
                        ui.getState().unlockedIndex,
                        next
                      ),
                    });
                  } catch (e) {
                    // silent
                  }
                }}
              />
            </div>
          </div>
        ) : (
          <div className="flex h-full min-h-[60vh] items-center justify-center rounded-lg border-2 border-dashed border-neutral-800 text-neutral-500">
            <p>Select a subtopic to begin</p>
          </div>
        )}
      </main>

      {/* Right: AI Tutor */}
      <aside className="sticky top-24 h-[calc(100vh-8rem)] self-start lg:col-span-3">
        <ChatPanel documentContent={initial.originalContent} />
      </aside>
    </div>
  );
}

function QuizPanel({
  questions,
  onPassed,
}: {
  questions: QuizQuestion[];
  onPassed: () => void;
}) {
  const [answers, setAnswers] = useState<number[]>([]);
  const [revealed, setRevealed] = useState(false);

  const setAns = (qIndex: number, ansIndex: number) => {
    const next = [...answers];
    next[qIndex] = ansIndex;
    setAnswers(next);
  };

  const check = () => {
    setRevealed(true);
    const allCorrect = questions.every((q, i) => answers[i] === q.answerIndex);
    if (allCorrect) setTimeout(onPassed, 900);
  };

  useEffect(() => {
    setAnswers([]);
    setRevealed(false);
  }, [questions.map((q) => q.id).join('|')]);

  if (!questions || questions.length === 0) {
    return (
      <p className="text-sm text-neutral-400">
        No quiz questions for this subtopic.
      </p>
    );
  }

  return (
    <div className="space-y-4">
      <ul className="space-y-6">
        {questions.map((q, i) => (
          <li key={q.id} className="space-y-3">
            <div className="font-medium text-neutral-200">{q.prompt}</div>
            <div className="grid gap-2">
              {q.options.map((o, j) => {
                const isSelected = answers[i] === j;
                const isCorrect = revealed && j === q.answerIndex;
                const isIncorrect =
                  revealed && isSelected && j !== q.answerIndex;
                const buttonClass = `rounded-md border p-3 text-left transition-all text-sm ${
                  isCorrect
                    ? 'border-green-500 bg-green-900/30'
                    : isIncorrect
                      ? 'border-red-500 bg-red-900/30'
                      : isSelected
                        ? 'border-blue-500 bg-blue-900/20'
                        : 'border-neutral-700 hover:bg-neutral-800'
                }`;
                return (
                  <button
                    key={j}
                    onClick={() => setAns(i, j)}
                    className={buttonClass}
                    disabled={revealed}
                  >
                    {o}
                  </button>
                );
              })}
            </div>
            {revealed && q.explanation && (
              <div className="mt-4 border-t border-neutral-800 pt-3 text-sm text-neutral-400">
                {q.explanation}
              </div>
            )}
          </li>
        ))}
      </ul>
      <div className="flex items-center gap-4 pt-4">
        <button
          onClick={check}
          disabled={revealed || questions.length === 0}
          className="rounded-md bg-white px-5 py-2 font-semibold text-black disabled:opacity-50"
        >
          Check Answer
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/LearnView.tsx.bak_fixsyntax_1754565820">
'use client';

import { useMemo, useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type LearnSubtopic,
  type QuizQuestion,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';
import { renameLecture } from '@/lib/client/rename-lecture';

export default function LearnView({ initial }: { initial: LearnLecture }) {
  // Initialize UI-only store
  const initialUnlocked = deriveUnlockedIndex(initial.subtopics);
  const storeRef = useRef(
    createLearnUIStore({
      currentIndex: initialUnlocked,
      unlockedIndex: initialUnlocked,
    })
  );
  const ui = storeRef.current;

  const currentSubtopic = initial.subtopics[ui.getState().currentIndex];

  // Local title editing state
  const [title, setTitle] = useState(initial.title);
  const [isSavingTitle, setIsSavingTitle] = useState(false);
  const [saveMsg, setSaveMsg] = useState<string | null>(null);

  // "Saved to Dashboard" is inherent once lecture exists in DB; we just expose a button for UX// Explanations cache per subtopic
  const [explanations, setExplanations] = useState<Record<string, string>>(() =>
    Object.fromEntries(
      initial.subtopics.map((s) => [s.id, s.explanation || ''])
    )
  );

  const canSelect = (i: number) => i <= ui.getState().unlockedIndex;

  useEffect(() => {
    const u = deriveUnlockedIndex(initial.subtopics);
    ui.setState((s) => ({
      ...s,
      unlockedIndex: Math.max(u, s.unlockedIndex),
      currentIndex: Math.max(
        0,
        Math.min(s.currentIndex, initial.subtopics.length - 1)
      ),
    }));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initial.subtopics.map((s) => s.mastered).join('|')]);

  const fetchExplanation = useCallback(
    async (
      style: 'default' | 'simplified' | 'detailed' | 'example' = 'default'
    ) => {
      const s = currentSubtopic;
      if (!s) return;
      setExplanations((e) => ({ ...e, [s.id]: 'Loading...' }));
      try {
        const res = await fetch('/api/explain-db', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ subtopicId: s.id, style }),
        });
        if (!res.ok) {
          const e = await res.json().catch(() => ({}));
          throw new Error(e.error || `HTTP ${res.status}`);
        }
        const data = (await res.json()) as { explanation: string };
        setExplanations((e) => ({ ...e, [s.id]: data.explanation }));
      } catch (e: any) {
        setExplanations((ex) => ({
          ...ex,
          [s.id]: 'Could not generate explanation. ' + e.message,
        }));
      }
    },
    [currentSubtopic]
  );

  useEffect(() => {
    const s = currentSubtopic;
    if (s && !explanations[s.id]) {
      fetchExplanation('default');
    }
  }, [currentSubtopic, explanations, fetchExplanation]);

  const handleRename = async () => {
    if (!title.trim() || title.trim().length < 3) {
      setSaveMsg('Title must be at least 3 characters.');
      return;
    }
    try {
      setIsSavingTitle(true);
      setSaveMsg(null);
      const res = await renameLecture(initial.id, title.trim());
      setSaveMsg('Lecture title saved.');
    } catch (e: any) {
      setSaveMsg(e.message || 'Failed to save title.');
    } finally {
      setIsSavingTitle(false);
      setTimeout(() => setSaveMsg(null), 2500);
    }
  };

  const handleSaveToDashboard = async () => {
    // The lecture already exists in DB; we simply give user feedback and a quick link.
    setSavedHint('Saved! You can access this lecture on your Dashboard.');
    setTimeout(() => setSavedHint(null), 2500);
  };

  return (
    <div className="grid grid-cols-1 gap-8 px-4 lg:grid-cols-10">
      {/* Left: Outline */}
      <aside className="space-y-4 self-start rounded-lg border border-neutral-800 p-4 lg:col-span-2">
        <h2 className="text-xl font-semibold">Lecture</h2>

        {/* Rename row */}
        <div className="flex flex-wrap items-center gap-2">
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full rounded-md bg-neutral-900 px-3 py-2 ring-1 ring-neutral-700 outline-none"
            aria-label="Lecture title"
          />
          <button
            onClick={handleRename}
            disabled={isSavingTitle || title.trim().length < 3}
            className="rounded-md bg-white px-3 py-2 text-sm font-medium whitespace-nowrap text-black disabled:opacity-50"
          >
            {isSavingTitle ? 'Saving...' : 'Save'}
          </button>
        </div>
        {saveMsg && <div className="text-xs text-neutral-400">{saveMsg}</div>}

        {/* Save to Dashboard */}</div>}

        <div className="mt-4 mb-2">
          <div className="text-sm text-neutral-400 uppercase">Title</div>
          <div className="text-lg font-semibold">{title}</div>
        </div>

        <ul className="space-y-1">
          {initial.subtopics.map((s, i) => (
            <li key={s.id}>
              <button
                onClick={() => canSelect(i) && ui.setState({ currentIndex: i })}
                disabled={!canSelect(i)}
                className={`w-full rounded-md px-3.5 py-3 text-left text-sm leading-snug transition-colors ${
                  i > ui.getState().unlockedIndex
                    ? 'text-neutral-600'
                    : i === ui.getState().currentIndex
                      ? 'bg-neutral-800 font-semibold text-white'
                      : 'text-neutral-300 hover:bg-neutral-900'
                }`}
              >
                {i + 1}. {s.title}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      {/* Center: Explanation + Quiz */}
      <main className="lg:col-span-5">
        {currentSubtopic ? (
          <div className="space-y-8">
            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="text-3xl font-bold tracking-tight">
                {currentSubtopic.title}
              </h3>
              <div className="mt-2 flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-neutral-400">
                <span>Importance: {currentSubtopic.importance}</span>{' '}
                <span>•</span>{' '}
                <span>Difficulty: {currentSubtopic.difficulty}</span>
              </div>
              <div className="mt-6 flex items-center gap-2 border-t border-neutral-800/50 pt-4">
                <span className="text-sm font-medium text-neutral-400">
                  Style:
                </span>
                <button
                  onClick={() => fetchExplanation('default')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Default
                </button>
                <button
                  onClick={() => fetchExplanation('simplified')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Simplified
                </button>
                <button
                  onClick={() => fetchExplanation('detailed')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Detailed
                </button>
                <button
                  onClick={() => fetchExplanation('example')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Example
                </button>
              </div>
              <hr className="my-6 border-neutral-800" />
              <div className="markdown">
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {explanations[currentSubtopic.id] || 'Loading...'}
                </ReactMarkdown>
              </div>
            </div>

            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="mb-6 text-2xl font-bold tracking-tight">
                Mastery Check
              </h3>
              <QuizPanel
                key={currentSubtopic.id}
                questions={currentSubtopic.questions}
                onPassed={async () => {
                  try {
                    const res = await fetch('/api/mastery', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ subtopicId: currentSubtopic.id }),
                    });
                    if (!res.ok)
                      throw new Error((await res.json()).error || 'HTTP');
                    // Unlock next subtopic locally
                    const idx = ui.getState().currentIndex;
                    const next = Math.min(
                      idx + 1,
                      initial.subtopics.length - 1
                    );
                    ui.setState({
                      currentIndex: next,
                      unlockedIndex: Math.max(
                        ui.getState().unlockedIndex,
                        next
                      ),
                    });
                  } catch (e) {
                    // silent
                  }
                }}
              />
            </div>
          </div>
        ) : (
          <div className="flex h-full min-h-[60vh] items-center justify-center rounded-lg border-2 border-dashed border-neutral-800 text-neutral-500">
            <p>Select a subtopic to begin</p>
          </div>
        )}
      </main>

      {/* Right: AI Tutor */}
      <aside className="sticky top-24 h-[calc(100vh-8rem)] self-start lg:col-span-3">
        <ChatPanel documentContent={initial.originalContent} />
      </aside>
    </div>
  );
}

function QuizPanel({
  questions,
  onPassed,
}: {
  questions: QuizQuestion[];
  onPassed: () => void;
}) {
  const [answers, setAnswers] = useState<number[]>([]);
  const [revealed, setRevealed] = useState(false);

  const setAns = (qIndex: number, ansIndex: number) => {
    const next = [...answers];
    next[qIndex] = ansIndex;
    setAnswers(next);
  };

  const check = () => {
    setRevealed(true);
    const allCorrect = questions.every((q, i) => answers[i] === q.answerIndex);
    if (allCorrect) setTimeout(onPassed, 900);
  };

  useEffect(() => {
    setAnswers([]);
    setRevealed(false);
  }, [questions.map((q) => q.id).join('|')]);

  if (!questions || questions.length === 0) {
    return (
      <p className="text-sm text-neutral-400">
        No quiz questions for this subtopic.
      </p>
    );
  }

  return (
    <div className="space-y-4">
      <ul className="space-y-6">
        {questions.map((q, i) => (
          <li key={q.id} className="space-y-3">
            <div className="font-medium text-neutral-200">{q.prompt}</div>
            <div className="grid gap-2">
              {q.options.map((o, j) => {
                const isSelected = answers[i] === j;
                const isCorrect = revealed && j === q.answerIndex;
                const isIncorrect =
                  revealed && isSelected && j !== q.answerIndex;
                const buttonClass = `rounded-md border p-3 text-left transition-all text-sm ${
                  isCorrect
                    ? 'border-green-500 bg-green-900/30'
                    : isIncorrect
                      ? 'border-red-500 bg-red-900/30'
                      : isSelected
                        ? 'border-blue-500 bg-blue-900/20'
                        : 'border-neutral-700 hover:bg-neutral-800'
                }`;
                return (
                  <button
                    key={j}
                    onClick={() => setAns(i, j)}
                    className={buttonClass}
                    disabled={revealed}
                  >
                    {o}
                  </button>
                );
              })}
            </div>
            {revealed && q.explanation && (
              <div className="mt-4 border-t border-neutral-800 pt-3 text-sm text-neutral-400">
                {q.explanation}
              </div>
            )}
          </li>
        ))}
      </ul>
      <div className="flex items-center gap-4 pt-4">
        <button
          onClick={check}
          disabled={revealed || questions.length === 0}
          className="rounded-md bg-white px-5 py-2 font-semibold text-black disabled:opacity-50"
        >
          Check Answer
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/LearnView.tsx.bak_mergeSave_1754565785">
'use client';

import { useMemo, useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type LearnSubtopic,
  type QuizQuestion,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';
import { renameLecture } from '@/lib/client/rename-lecture';

export default function LearnView({ initial }: { initial: LearnLecture }) {
  // Initialize UI-only store
  const initialUnlocked = deriveUnlockedIndex(initial.subtopics);
  const storeRef = useRef(
    createLearnUIStore({
      currentIndex: initialUnlocked,
      unlockedIndex: initialUnlocked,
    })
  );
  const ui = storeRef.current;

  const currentSubtopic = initial.subtopics[ui.getState().currentIndex];

  // Local title editing state
  const [title, setTitle] = useState(initial.title);
  const [isSavingTitle, setIsSavingTitle] = useState(false);
  const [saveMsg, setSaveMsg] = useState<string | null>(null);

  // "Saved to Dashboard" is inherent once lecture exists in DB; we just expose a button for UX
  const [savedHint, setSavedHint] = useState<string | null>(null);

  // Explanations cache per subtopic
  const [explanations, setExplanations] = useState<Record<string, string>>(() =>
    Object.fromEntries(
      initial.subtopics.map((s) => [s.id, s.explanation || ''])
    )
  );

  const canSelect = (i: number) => i <= ui.getState().unlockedIndex;

  useEffect(() => {
    const u = deriveUnlockedIndex(initial.subtopics);
    ui.setState((s) => ({
      ...s,
      unlockedIndex: Math.max(u, s.unlockedIndex),
      currentIndex: Math.max(
        0,
        Math.min(s.currentIndex, initial.subtopics.length - 1)
      ),
    }));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initial.subtopics.map((s) => s.mastered).join('|')]);

  const fetchExplanation = useCallback(
    async (
      style: 'default' | 'simplified' | 'detailed' | 'example' = 'default'
    ) => {
      const s = currentSubtopic;
      if (!s) return;
      setExplanations((e) => ({ ...e, [s.id]: 'Loading...' }));
      try {
        const res = await fetch('/api/explain-db', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ subtopicId: s.id, style }),
        });
        if (!res.ok) {
          const e = await res.json().catch(() => ({}));
          throw new Error(e.error || `HTTP ${res.status}`);
        }
        const data = (await res.json()) as { explanation: string };
        setExplanations((e) => ({ ...e, [s.id]: data.explanation }));
      } catch (e: any) {
        setExplanations((ex) => ({
          ...ex,
          [s.id]: 'Could not generate explanation. ' + e.message,
        }));
      }
    },
    [currentSubtopic]
  );

  useEffect(() => {
    const s = currentSubtopic;
    if (s && !explanations[s.id]) {
      fetchExplanation('default');
    }
  }, [currentSubtopic, explanations, fetchExplanation]);

  const handleRename = async () => {
    if (!title.trim() || title.trim().length < 3) {
      setSaveMsg('Title must be at least 3 characters.');
      return;
    }
    try {
      setIsSavingTitle(true);
      setSaveMsg(null);
      const res = await renameLecture(initial.id, title.trim());
      setSaveMsg('Lecture title saved.');
    } catch (e: any) {
      setSaveMsg(e.message || 'Failed to save title.');
    } finally {
      setIsSavingTitle(false);
      setTimeout(() => setSaveMsg(null), 2500);
    }
  };

  const handleSaveToDashboard = async () => {
    // The lecture already exists in DB; we simply give user feedback and a quick link.
    setSavedHint('Saved! You can access this lecture on your Dashboard.');
    setTimeout(() => setSavedHint(null), 2500);
  };

  return (
    <div className="grid grid-cols-1 gap-8 px-4 lg:grid-cols-10">
      {/* Left: Outline */}
      <aside className="space-y-4 self-start rounded-lg border border-neutral-800 p-4 lg:col-span-2">
        <h2 className="text-xl font-semibold">Lecture</h2>

        {/* Rename row */}
        <div className="flex flex-wrap items-center gap-2">
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full rounded-md bg-neutral-900 px-3 py-2 ring-1 ring-neutral-700 outline-none"
            aria-label="Lecture title"
          />
          <button
            onClick={handleRename}
            disabled={isSavingTitle || title.trim().length < 3}
            className="rounded-md bg-white px-3 py-2 text-sm font-medium whitespace-nowrap text-black disabled:opacity-50"
          >
            {isSavingTitle ? 'Saving...' : 'Save'}
          </button>
        </div>
        {saveMsg && <div className="text-xs text-neutral-400">{saveMsg}</div>}

        {/* Save to Dashboard */}
        <button
          onClick={handleSaveToDashboard}
          className="mt-2 w-full rounded-md border border-neutral-700 px-3 py-2 text-sm hover:bg-neutral-900"
          title="This lecture is stored in your account; click for confirmation."
        >
          Save to Dashboard
        </button>
        {savedHint && <div className="text-xs text-green-400">{savedHint}</div>}

        <div className="mt-4 mb-2">
          <div className="text-sm text-neutral-400 uppercase">Title</div>
          <div className="text-lg font-semibold">{title}</div>
        </div>

        <ul className="space-y-1">
          {initial.subtopics.map((s, i) => (
            <li key={s.id}>
              <button
                onClick={() => canSelect(i) && ui.setState({ currentIndex: i })}
                disabled={!canSelect(i)}
                className={`w-full rounded-md px-3.5 py-3 text-left text-sm leading-snug transition-colors ${
                  i > ui.getState().unlockedIndex
                    ? 'text-neutral-600'
                    : i === ui.getState().currentIndex
                      ? 'bg-neutral-800 font-semibold text-white'
                      : 'text-neutral-300 hover:bg-neutral-900'
                }`}
              >
                {i + 1}. {s.title}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      {/* Center: Explanation + Quiz */}
      <main className="lg:col-span-5">
        {currentSubtopic ? (
          <div className="space-y-8">
            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="text-3xl font-bold tracking-tight">
                {currentSubtopic.title}
              </h3>
              <div className="mt-2 flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-neutral-400">
                <span>Importance: {currentSubtopic.importance}</span>{' '}
                <span>•</span>{' '}
                <span>Difficulty: {currentSubtopic.difficulty}</span>
              </div>
              <div className="mt-6 flex items-center gap-2 border-t border-neutral-800/50 pt-4">
                <span className="text-sm font-medium text-neutral-400">
                  Style:
                </span>
                <button
                  onClick={() => fetchExplanation('default')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Default
                </button>
                <button
                  onClick={() => fetchExplanation('simplified')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Simplified
                </button>
                <button
                  onClick={() => fetchExplanation('detailed')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Detailed
                </button>
                <button
                  onClick={() => fetchExplanation('example')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Example
                </button>
              </div>
              <hr className="my-6 border-neutral-800" />
              <div className="markdown">
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {explanations[currentSubtopic.id] || 'Loading...'}
                </ReactMarkdown>
              </div>
            </div>

            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="mb-6 text-2xl font-bold tracking-tight">
                Mastery Check
              </h3>
              <QuizPanel
                key={currentSubtopic.id}
                questions={currentSubtopic.questions}
                onPassed={async () => {
                  try {
                    const res = await fetch('/api/mastery', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ subtopicId: currentSubtopic.id }),
                    });
                    if (!res.ok)
                      throw new Error((await res.json()).error || 'HTTP');
                    // Unlock next subtopic locally
                    const idx = ui.getState().currentIndex;
                    const next = Math.min(
                      idx + 1,
                      initial.subtopics.length - 1
                    );
                    ui.setState({
                      currentIndex: next,
                      unlockedIndex: Math.max(
                        ui.getState().unlockedIndex,
                        next
                      ),
                    });
                  } catch (e) {
                    // silent
                  }
                }}
              />
            </div>
          </div>
        ) : (
          <div className="flex h-full min-h-[60vh] items-center justify-center rounded-lg border-2 border-dashed border-neutral-800 text-neutral-500">
            <p>Select a subtopic to begin</p>
          </div>
        )}
      </main>

      {/* Right: AI Tutor */}
      <aside className="sticky top-24 h-[calc(100vh-8rem)] self-start lg:col-span-3">
        <ChatPanel documentContent={initial.originalContent} />
      </aside>
    </div>
  );
}

function QuizPanel({
  questions,
  onPassed,
}: {
  questions: QuizQuestion[];
  onPassed: () => void;
}) {
  const [answers, setAnswers] = useState<number[]>([]);
  const [revealed, setRevealed] = useState(false);

  const setAns = (qIndex: number, ansIndex: number) => {
    const next = [...answers];
    next[qIndex] = ansIndex;
    setAnswers(next);
  };

  const check = () => {
    setRevealed(true);
    const allCorrect = questions.every((q, i) => answers[i] === q.answerIndex);
    if (allCorrect) setTimeout(onPassed, 900);
  };

  useEffect(() => {
    setAnswers([]);
    setRevealed(false);
  }, [questions.map((q) => q.id).join('|')]);

  if (!questions || questions.length === 0) {
    return (
      <p className="text-sm text-neutral-400">
        No quiz questions for this subtopic.
      </p>
    );
  }

  return (
    <div className="space-y-4">
      <ul className="space-y-6">
        {questions.map((q, i) => (
          <li key={q.id} className="space-y-3">
            <div className="font-medium text-neutral-200">{q.prompt}</div>
            <div className="grid gap-2">
              {q.options.map((o, j) => {
                const isSelected = answers[i] === j;
                const isCorrect = revealed && j === q.answerIndex;
                const isIncorrect =
                  revealed && isSelected && j !== q.answerIndex;
                const buttonClass = `rounded-md border p-3 text-left transition-all text-sm ${
                  isCorrect
                    ? 'border-green-500 bg-green-900/30'
                    : isIncorrect
                      ? 'border-red-500 bg-red-900/30'
                      : isSelected
                        ? 'border-blue-500 bg-blue-900/20'
                        : 'border-neutral-700 hover:bg-neutral-800'
                }`;
                return (
                  <button
                    key={j}
                    onClick={() => setAns(i, j)}
                    className={buttonClass}
                    disabled={revealed}
                  >
                    {o}
                  </button>
                );
              })}
            </div>
            {revealed && q.explanation && (
              <div className="mt-4 border-t border-neutral-800 pt-3 text-sm text-neutral-400">
                {q.explanation}
              </div>
            )}
          </li>
        ))}
      </ul>
      <div className="flex items-center gap-4 pt-4">
        <button
          onClick={check}
          disabled={revealed || questions.length === 0}
          className="rounded-md bg-white px-5 py-2 font-semibold text-black disabled:opacity-50"
        >
          Check Answer
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/LearnView.tsx.bak_sidebar_1754565963">
'use client';

import { useMemo, useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type LearnSubtopic,
  type QuizQuestion,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';
import { renameLecture } from '@/lib/client/rename-lecture';

export default function LearnView({ initial }: { initial: LearnLecture }) {
  // Initialize UI-only store
  const initialUnlocked = deriveUnlockedIndex(initial.subtopics);
  const storeRef = useRef(
    createLearnUIStore({
      currentIndex: initialUnlocked,
      unlockedIndex: initialUnlocked,
    })
  );
  const ui = storeRef.current;

  const currentSubtopic = initial.subtopics[ui.getState().currentIndex];

  // Local title editing state
  const [title, setTitle] = useState(initial.title);
  const [isSavingTitle, setIsSavingTitle] = useState(false);
  const [saveMsg, setSaveMsg] = useState<string | null>(null);

  // "Saved to Dashboard" is inherent once lecture exists in DB; we just expose a button for UX// Explanations cache per subtopic
  const [explanations, setExplanations] = useState<Record<string, string>>(() =>
    Object.fromEntries(
      initial.subtopics.map((s) => [s.id, s.explanation || ''])
    )
  );

  const canSelect = (i: number) => i <= ui.getState().unlockedIndex;

  useEffect(() => {
    const u = deriveUnlockedIndex(initial.subtopics);
    ui.setState((s) => ({
      ...s,
      unlockedIndex: Math.max(u, s.unlockedIndex),
      currentIndex: Math.max(
        0,
        Math.min(s.currentIndex, initial.subtopics.length - 1)
      ),
    }));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initial.subtopics.map((s) => s.mastered).join('|')]);

  const fetchExplanation = useCallback(
    async (
      style: 'default' | 'simplified' | 'detailed' | 'example' = 'default'
    ) => {
      const s = currentSubtopic;
      if (!s) return;
      setExplanations((e) => ({ ...e, [s.id]: 'Loading...' }));
      try {
        const res = await fetch('/api/explain-db', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ subtopicId: s.id, style }),
        });
        if (!res.ok) {
          const e = await res.json().catch(() => ({}));
          throw new Error(e.error || `HTTP ${res.status}`);
        }
        const data = (await res.json()) as { explanation: string };
        setExplanations((e) => ({ ...e, [s.id]: data.explanation }));
      } catch (e: any) {
        setExplanations((ex) => ({
          ...ex,
          [s.id]: 'Could not generate explanation. ' + e.message,
        }));
      }
    },
    [currentSubtopic]
  );

  useEffect(() => {
    const s = currentSubtopic;
    if (s && !explanations[s.id]) {
      fetchExplanation('default');
    }
  }, [currentSubtopic, explanations, fetchExplanation]);

  const handleRename = async () => {
    if (!title.trim() || title.trim().length < 3) {
      setSaveMsg('Title must be at least 3 characters.');
      return;
    }
    try {
      setIsSavingTitle(true);
      setSaveMsg(null);
      const res = await renameLecture(initial.id, title.trim());
      setSaveMsg('Lecture title saved.');
    } catch (e: any) {
      setSaveMsg(e.message || 'Failed to save title.');
    } finally {
      setIsSavingTitle(false);
      setTimeout(() => setSaveMsg(null), 2500);
    }
  };

  const handleSaveToDashboard = async () => {
    // The lecture already exists in DB; we simply give user feedback and a quick link.
    setSavedHint('Saved! You can access this lecture on your Dashboard.');
    setTimeout(() => setSavedHint(null), 2500);
  };

  return (
    <div className="grid grid-cols-1 gap-8 px-4 lg:grid-cols-10">
      {/* Left: Outline */}
      <aside className="space-y-4 self-start rounded-lg border border-neutral-800 p-4 lg:col-span-2">
        <h2 className="text-xl font-semibold">Lecture</h2>

        {/* Rename row */}
        <div className="flex flex-wrap items-center gap-2">
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full rounded-md bg-neutral-900 px-3 py-2 ring-1 ring-neutral-700 outline-none"
            aria-label="Lecture title"
          />
          <button
            onClick={handleRename}
            disabled={isSavingTitle || title.trim().length < 3}
            className="rounded-md bg-white px-3 py-2 text-sm font-medium whitespace-nowrap text-black disabled:opacity-50"
          >
            {isSavingTitle ? 'Saving...' : 'Save'}
          </button>
        </div>
        {saveMsg && <div className="text-xs text-neutral-400">{saveMsg}</div>

        

        <div className="mt-4 mb-2">
          <div className="text-sm text-neutral-400 uppercase">Title</div>
          <div className="text-lg font-semibold">{title}</div>
        </div>

        <ul className="space-y-1">
          {initial.subtopics.map((s, i) => (
            <li key={s.id}>
              <button
                onClick={() => canSelect(i) && ui.setState({ currentIndex: i })}
                disabled={!canSelect(i)}
                className={`w-full rounded-md px-3.5 py-3 text-left text-sm leading-snug transition-colors ${
                  i > ui.getState().unlockedIndex
                    ? 'text-neutral-600'
                    : i === ui.getState().currentIndex
                      ? 'bg-neutral-800 font-semibold text-white'
                      : 'text-neutral-300 hover:bg-neutral-900'
                }`}
              >
                {i + 1}. {s.title}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      {/* Center: Explanation + Quiz */}
      <main className="lg:col-span-5">
        {currentSubtopic ? (
          <div className="space-y-8">
            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="text-3xl font-bold tracking-tight">
                {currentSubtopic.title}
              </h3>
              <div className="mt-2 flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-neutral-400">
                <span>Importance: {currentSubtopic.importance}</span>{' '}
                <span>•</span>{' '}
                <span>Difficulty: {currentSubtopic.difficulty}</span>
              </div>
              <div className="mt-6 flex items-center gap-2 border-t border-neutral-800/50 pt-4">
                <span className="text-sm font-medium text-neutral-400">
                  Style:
                </span>
                <button
                  onClick={() => fetchExplanation('default')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Default
                </button>
                <button
                  onClick={() => fetchExplanation('simplified')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Simplified
                </button>
                <button
                  onClick={() => fetchExplanation('detailed')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Detailed
                </button>
                <button
                  onClick={() => fetchExplanation('example')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Example
                </button>
              </div>
              <hr className="my-6 border-neutral-800" />
              <div className="markdown">
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {explanations[currentSubtopic.id] || 'Loading...'}
                </ReactMarkdown>
              </div>
            </div>

            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="mb-6 text-2xl font-bold tracking-tight">
                Mastery Check
              </h3>
              <QuizPanel
                key={currentSubtopic.id}
                questions={currentSubtopic.questions}
                onPassed={async () => {
                  try {
                    const res = await fetch('/api/mastery', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ subtopicId: currentSubtopic.id }),
                    });
                    if (!res.ok)
                      throw new Error((await res.json()).error || 'HTTP');
                    // Unlock next subtopic locally
                    const idx = ui.getState().currentIndex;
                    const next = Math.min(
                      idx + 1,
                      initial.subtopics.length - 1
                    );
                    ui.setState({
                      currentIndex: next,
                      unlockedIndex: Math.max(
                        ui.getState().unlockedIndex,
                        next
                      ),
                    });
                  } catch (e) {
                    // silent
                  }
                }}
              />
            </div>
          </div>
        ) : (
          <div className="flex h-full min-h-[60vh] items-center justify-center rounded-lg border-2 border-dashed border-neutral-800 text-neutral-500">
            <p>Select a subtopic to begin</p>
          </div>
        )}
      </main>

      {/* Right: AI Tutor */}
      <aside className="sticky top-24 h-[calc(100vh-8rem)] self-start lg:col-span-3">
        <ChatPanel documentContent={initial.originalContent} />
      </aside>
    </div>
  );
}

function QuizPanel({
  questions,
  onPassed,
}: {
  questions: QuizQuestion[];
  onPassed: () => void;
}) {
  const [answers, setAnswers] = useState<number[]>([]);
  const [revealed, setRevealed] = useState(false);

  const setAns = (qIndex: number, ansIndex: number) => {
    const next = [...answers];
    next[qIndex] = ansIndex;
    setAnswers(next);
  };

  const check = () => {
    setRevealed(true);
    const allCorrect = questions.every((q, i) => answers[i] === q.answerIndex);
    if (allCorrect) setTimeout(onPassed, 900);
  };

  useEffect(() => {
    setAnswers([]);
    setRevealed(false);
  }, [questions.map((q) => q.id).join('|')]);

  if (!questions || questions.length === 0) {
    return (
      <p className="text-sm text-neutral-400">
        No quiz questions for this subtopic.
      </p>
    );
  }

  return (
    <div className="space-y-4">
      <ul className="space-y-6">
        {questions.map((q, i) => (
          <li key={q.id} className="space-y-3">
            <div className="font-medium text-neutral-200">{q.prompt}</div>
            <div className="grid gap-2">
              {q.options.map((o, j) => {
                const isSelected = answers[i] === j;
                const isCorrect = revealed && j === q.answerIndex;
                const isIncorrect =
                  revealed && isSelected && j !== q.answerIndex;
                const buttonClass = `rounded-md border p-3 text-left transition-all text-sm ${
                  isCorrect
                    ? 'border-green-500 bg-green-900/30'
                    : isIncorrect
                      ? 'border-red-500 bg-red-900/30'
                      : isSelected
                        ? 'border-blue-500 bg-blue-900/20'
                        : 'border-neutral-700 hover:bg-neutral-800'
                }`;
                return (
                  <button
                    key={j}
                    onClick={() => setAns(i, j)}
                    className={buttonClass}
                    disabled={revealed}
                  >
                    {o}
                  </button>
                );
              })}
            </div>
            {revealed && q.explanation && (
              <div className="mt-4 border-t border-neutral-800 pt-3 text-sm text-neutral-400">
                {q.explanation}
              </div>
            )}
          </li>
        ))}
      </ul>
      <div className="flex items-center gap-4 pt-4">
        <button
          onClick={check}
          disabled={revealed || questions.length === 0}
          className="rounded-md bg-white px-5 py-2 font-semibold text-black disabled:opacity-50"
        >
          Check Answer
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/LearnView.tsx.bak_sidebar_1754565969">
'use client';

import { useMemo, useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type LearnSubtopic,
  type QuizQuestion,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';
import { renameLecture } from '@/lib/client/rename-lecture';

export default function LearnView({ initial }: { initial: LearnLecture }) {
  // Initialize UI-only store
  const initialUnlocked = deriveUnlockedIndex(initial.subtopics);
  const storeRef = useRef(
    createLearnUIStore({
      currentIndex: initialUnlocked,
      unlockedIndex: initialUnlocked,
    })
  );
  const ui = storeRef.current;

  const currentSubtopic = initial.subtopics[ui.getState().currentIndex];

  // Local title editing state
  const [title, setTitle] = useState(initial.title);
  const [isSavingTitle, setIsSavingTitle] = useState(false);
  const [saveMsg, setSaveMsg] = useState<string | null>(null);

  // "Saved to Dashboard" is inherent once lecture exists in DB; we just expose a button for UX// Explanations cache per subtopic
  const [explanations, setExplanations] = useState<Record<string, string>>(() =>
    Object.fromEntries(
      initial.subtopics.map((s) => [s.id, s.explanation || ''])
    )
  );

  const canSelect = (i: number) => i <= ui.getState().unlockedIndex;

  useEffect(() => {
    const u = deriveUnlockedIndex(initial.subtopics);
    ui.setState((s) => ({
      ...s,
      unlockedIndex: Math.max(u, s.unlockedIndex),
      currentIndex: Math.max(
        0,
        Math.min(s.currentIndex, initial.subtopics.length - 1)
      ),
    }));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initial.subtopics.map((s) => s.mastered).join('|')]);

  const fetchExplanation = useCallback(
    async (
      style: 'default' | 'simplified' | 'detailed' | 'example' = 'default'
    ) => {
      const s = currentSubtopic;
      if (!s) return;
      setExplanations((e) => ({ ...e, [s.id]: 'Loading...' }));
      try {
        const res = await fetch('/api/explain-db', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ subtopicId: s.id, style }),
        });
        if (!res.ok) {
          const e = await res.json().catch(() => ({}));
          throw new Error(e.error || `HTTP ${res.status}`);
        }
        const data = (await res.json()) as { explanation: string };
        setExplanations((e) => ({ ...e, [s.id]: data.explanation }));
      } catch (e: any) {
        setExplanations((ex) => ({
          ...ex,
          [s.id]: 'Could not generate explanation. ' + e.message,
        }));
      }
    },
    [currentSubtopic]
  );

  useEffect(() => {
    const s = currentSubtopic;
    if (s && !explanations[s.id]) {
      fetchExplanation('default');
    }
  }, [currentSubtopic, explanations, fetchExplanation]);

  const handleRename = async () => {
    if (!title.trim() || title.trim().length < 3) {
      setSaveMsg('Title must be at least 3 characters.');
      return;
    }
    try {
      setIsSavingTitle(true);
      setSaveMsg(null);
      const res = await renameLecture(initial.id, title.trim());
      setSaveMsg('Lecture title saved.');
    } catch (e: any) {
      setSaveMsg(e.message || 'Failed to save title.');
    } finally {
      setIsSavingTitle(false);
      setTimeout(() => setSaveMsg(null), 2500);
    }
  };

  const handleSaveToDashboard = async () => {
    // The lecture already exists in DB; we simply give user feedback and a quick link.
    setSavedHint('Saved! You can access this lecture on your Dashboard.');
    setTimeout(() => setSavedHint(null), 2500);
  };

  return (
    <div className="grid grid-cols-1 gap-8 px-4 lg:grid-cols-10">
      {/* Left: Outline */}
      <aside className="space-y-4 self-start rounded-lg border border-neutral-800 p-4 lg:col-span-2">
        <h2 className="text-xl font-semibold">Lecture</h2>

        {/* Rename row */}
        <div className="flex flex-wrap items-center gap-2">
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full rounded-md bg-neutral-900 px-3 py-2 ring-1 ring-neutral-700 outline-none"
            aria-label="Lecture title"
          />
          <button
            onClick={handleRename}
            disabled={isSavingTitle || title.trim().length < 3}
            className="rounded-md bg-white px-3 py-2 text-sm font-medium whitespace-nowrap text-black disabled:opacity-50"
          >
            {isSavingTitle ? 'Saving...' : 'Save'}
          </button>
        </div>
        {saveMsg && <div className="text-xs text-neutral-400">{saveMsg}</div>

        

        <div className="mt-4 mb-2">
          <div className="text-sm text-neutral-400 uppercase">Title</div>
          <div className="text-lg font-semibold">{title}</div>
        </div>

        <ul className="space-y-1">
          {initial.subtopics.map((s, i) => (
            <li key={s.id}>
              <button
                onClick={() => canSelect(i) && ui.setState({ currentIndex: i })}
                disabled={!canSelect(i)}
                className={`w-full rounded-md px-3.5 py-3 text-left text-sm leading-snug transition-colors ${
                  i > ui.getState().unlockedIndex
                    ? 'text-neutral-600'
                    : i === ui.getState().currentIndex
                      ? 'bg-neutral-800 font-semibold text-white'
                      : 'text-neutral-300 hover:bg-neutral-900'
                }`}
              >
                {i + 1}. {s.title}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      {/* Center: Explanation + Quiz */}
      <main className="lg:col-span-5">
        {currentSubtopic ? (
          <div className="space-y-8">
            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="text-3xl font-bold tracking-tight">
                {currentSubtopic.title}
              </h3>
              <div className="mt-2 flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-neutral-400">
                <span>Importance: {currentSubtopic.importance}</span>{' '}
                <span>•</span>{' '}
                <span>Difficulty: {currentSubtopic.difficulty}</span>
              </div>
              <div className="mt-6 flex items-center gap-2 border-t border-neutral-800/50 pt-4">
                <span className="text-sm font-medium text-neutral-400">
                  Style:
                </span>
                <button
                  onClick={() => fetchExplanation('default')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Default
                </button>
                <button
                  onClick={() => fetchExplanation('simplified')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Simplified
                </button>
                <button
                  onClick={() => fetchExplanation('detailed')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Detailed
                </button>
                <button
                  onClick={() => fetchExplanation('example')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Example
                </button>
              </div>
              <hr className="my-6 border-neutral-800" />
              <div className="markdown">
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {explanations[currentSubtopic.id] || 'Loading...'}
                </ReactMarkdown>
              </div>
            </div>

            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="mb-6 text-2xl font-bold tracking-tight">
                Mastery Check
              </h3>
              <QuizPanel
                key={currentSubtopic.id}
                questions={currentSubtopic.questions}
                onPassed={async () => {
                  try {
                    const res = await fetch('/api/mastery', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ subtopicId: currentSubtopic.id }),
                    });
                    if (!res.ok)
                      throw new Error((await res.json()).error || 'HTTP');
                    // Unlock next subtopic locally
                    const idx = ui.getState().currentIndex;
                    const next = Math.min(
                      idx + 1,
                      initial.subtopics.length - 1
                    );
                    ui.setState({
                      currentIndex: next,
                      unlockedIndex: Math.max(
                        ui.getState().unlockedIndex,
                        next
                      ),
                    });
                  } catch (e) {
                    // silent
                  }
                }}
              />
            </div>
          </div>
        ) : (
          <div className="flex h-full min-h-[60vh] items-center justify-center rounded-lg border-2 border-dashed border-neutral-800 text-neutral-500">
            <p>Select a subtopic to begin</p>
          </div>
        )}
      </main>

      {/* Right: AI Tutor */}
      <aside className="sticky top-24 h-[calc(100vh-8rem)] self-start lg:col-span-3">
        <ChatPanel documentContent={initial.originalContent} />
      </aside>
    </div>
  );
}

function QuizPanel({
  questions,
  onPassed,
}: {
  questions: QuizQuestion[];
  onPassed: () => void;
}) {
  const [answers, setAnswers] = useState<number[]>([]);
  const [revealed, setRevealed] = useState(false);

  const setAns = (qIndex: number, ansIndex: number) => {
    const next = [...answers];
    next[qIndex] = ansIndex;
    setAnswers(next);
  };

  const check = () => {
    setRevealed(true);
    const allCorrect = questions.every((q, i) => answers[i] === q.answerIndex);
    if (allCorrect) setTimeout(onPassed, 900);
  };

  useEffect(() => {
    setAnswers([]);
    setRevealed(false);
  }, [questions.map((q) => q.id).join('|')]);

  if (!questions || questions.length === 0) {
    return (
      <p className="text-sm text-neutral-400">
        No quiz questions for this subtopic.
      </p>
    );
  }

  return (
    <div className="space-y-4">
      <ul className="space-y-6">
        {questions.map((q, i) => (
          <li key={q.id} className="space-y-3">
            <div className="font-medium text-neutral-200">{q.prompt}</div>
            <div className="grid gap-2">
              {q.options.map((o, j) => {
                const isSelected = answers[i] === j;
                const isCorrect = revealed && j === q.answerIndex;
                const isIncorrect =
                  revealed && isSelected && j !== q.answerIndex;
                const buttonClass = `rounded-md border p-3 text-left transition-all text-sm ${
                  isCorrect
                    ? 'border-green-500 bg-green-900/30'
                    : isIncorrect
                      ? 'border-red-500 bg-red-900/30'
                      : isSelected
                        ? 'border-blue-500 bg-blue-900/20'
                        : 'border-neutral-700 hover:bg-neutral-800'
                }`;
                return (
                  <button
                    key={j}
                    onClick={() => setAns(i, j)}
                    className={buttonClass}
                    disabled={revealed}
                  >
                    {o}
                  </button>
                );
              })}
            </div>
            {revealed && q.explanation && (
              <div className="mt-4 border-t border-neutral-800 pt-3 text-sm text-neutral-400">
                {q.explanation}
              </div>
            )}
          </li>
        ))}
      </ul>
      <div className="flex items-center gap-4 pt-4">
        <button
          onClick={check}
          disabled={revealed || questions.length === 0}
          className="rounded-md bg-white px-5 py-2 font-semibold text-black disabled:opacity-50"
        >
          Check Answer
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/LearnView.tsx.bak_spacing_1754565674">
'use client';

import { useMemo, useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type LearnSubtopic,
  type QuizQuestion,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';
import { renameLecture } from '@/lib/client/rename-lecture';

export default function LearnView({ initial }: { initial: LearnLecture }) {
  // Initialize UI-only store
  const initialUnlocked = deriveUnlockedIndex(initial.subtopics);
  const storeRef = useRef(
    createLearnUIStore({
      currentIndex: initialUnlocked,
      unlockedIndex: initialUnlocked,
    })
  );
  const ui = storeRef.current;

  const currentSubtopic = initial.subtopics[ui.getState().currentIndex];

  // Local title editing state
  const [title, setTitle] = useState(initial.title);
  const [isSavingTitle, setIsSavingTitle] = useState(false);
  const [saveMsg, setSaveMsg] = useState<string | null>(null);

  // "Saved to Dashboard" is inherent once lecture exists in DB; we just expose a button for UX
  const [savedHint, setSavedHint] = useState<string | null>(null);

  // Explanations cache per subtopic
  const [explanations, setExplanations] = useState<Record<string, string>>(() =>
    Object.fromEntries(
      initial.subtopics.map((s) => [s.id, s.explanation || ''])
    )
  );

  const canSelect = (i: number) => i <= ui.getState().unlockedIndex;

  useEffect(() => {
    const u = deriveUnlockedIndex(initial.subtopics);
    ui.setState((s) => ({
      ...s,
      unlockedIndex: Math.max(u, s.unlockedIndex),
      currentIndex: Math.max(
        0,
        Math.min(s.currentIndex, initial.subtopics.length - 1)
      ),
    }));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initial.subtopics.map((s) => s.mastered).join('|')]);

  const fetchExplanation = useCallback(
    async (
      style: 'default' | 'simplified' | 'detailed' | 'example' = 'default'
    ) => {
      const s = currentSubtopic;
      if (!s) return;
      setExplanations((e) => ({ ...e, [s.id]: 'Loading...' }));
      try {
        const res = await fetch('/api/explain-db', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ subtopicId: s.id, style }),
        });
        if (!res.ok) {
          const e = await res.json().catch(() => ({}));
          throw new Error(e.error || `HTTP ${res.status}`);
        }
        const data = (await res.json()) as { explanation: string };
        setExplanations((e) => ({ ...e, [s.id]: data.explanation }));
      } catch (e: any) {
        setExplanations((ex) => ({
          ...ex,
          [s.id]: 'Could not generate explanation. ' + e.message,
        }));
      }
    },
    [currentSubtopic]
  );

  useEffect(() => {
    const s = currentSubtopic;
    if (s && !explanations[s.id]) {
      fetchExplanation('default');
    }
  }, [currentSubtopic, explanations, fetchExplanation]);

  const handleRename = async () => {
    if (!title.trim() || title.trim().length < 3) {
      setSaveMsg('Title must be at least 3 characters.');
      return;
    }
    try {
      setIsSavingTitle(true);
      setSaveMsg(null);
      const res = await renameLecture(initial.id, title.trim());
      setSaveMsg('Lecture title saved.');
    } catch (e: any) {
      setSaveMsg(e.message || 'Failed to save title.');
    } finally {
      setIsSavingTitle(false);
      setTimeout(() => setSaveMsg(null), 2500);
    }
  };

  const handleSaveToDashboard = async () => {
    // The lecture already exists in DB; we simply give user feedback and a quick link.
    setSavedHint('Saved! You can access this lecture on your Dashboard.');
    setTimeout(() => setSavedHint(null), 2500);
  };

  return (
    <div className="grid grid-cols-1 gap-8 px-4 lg:grid-cols-10">
      {/* Left: Outline */}
      <aside className="space-y-4 self-start rounded-lg border border-neutral-800 p-4 lg:col-span-2">
        <h2 className="text-xl font-semibold">Lecture</h2>

        {/* Rename row */}
        <div className="flex flex-wrap items-center gap-2">
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full rounded-md bg-neutral-900 px-3 py-2 ring-1 ring-neutral-700 outline-none"
            aria-label="Lecture title"
          />
          <button
            onClick={handleRename}
            disabled={isSavingTitle || title.trim().length < 3}
            className="rounded-md bg-white px-3 py-2 text-sm font-medium whitespace-nowrap text-black disabled:opacity-50"
          >
            {isSavingTitle ? 'Saving...' : 'Save'}
          </button>
        </div>
        {saveMsg && <div className="text-xs text-neutral-400">{saveMsg}</div>}

        {/* Save to Dashboard */}
        <button
          onClick={handleSaveToDashboard}
          className="mt-2 w-full rounded-md border border-neutral-700 px-3 py-2 text-sm hover:bg-neutral-900"
          title="This lecture is stored in your account; click for confirmation."
        >
          Save to Dashboard
        </button>
        {savedHint && <div className="text-xs text-green-400">{savedHint}</div>}

        <div className="mb-2">
          <div className="text-sm text-neutral-400 uppercase">Title</div>
          <div className="text-lg font-semibold">{title}</div>
        </div>

        <ul className="space-y-1">
          {initial.subtopics.map((s, i) => (
            <li key={s.id}>
              <button
                onClick={() => canSelect(i) && ui.setState({ currentIndex: i })}
                disabled={!canSelect(i)}
                className={`w-full rounded-md px-3 py-2.5 text-left text-sm leading-snug transition-colors ${
                  i > ui.getState().unlockedIndex
                    ? 'text-neutral-600'
                    : i === ui.getState().currentIndex
                      ? 'bg-neutral-800 font-semibold text-white'
                      : 'text-neutral-300 hover:bg-neutral-900'
                }`}
              >
                {i + 1}. {s.title}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      {/* Center: Explanation + Quiz */}
      <main className="lg:col-span-5">
        {currentSubtopic ? (
          <div className="space-y-8">
            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="text-3xl font-bold tracking-tight">
                {currentSubtopic.title}
              </h3>
              <div className="mt-2 flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-neutral-400">
                <span>Importance: {currentSubtopic.importance}</span>{' '}
                <span>•</span>{' '}
                <span>Difficulty: {currentSubtopic.difficulty}</span>
              </div>
              <div className="mt-6 flex items-center gap-2 border-t border-neutral-800/50 pt-4">
                <span className="text-sm font-medium text-neutral-400">
                  Style:
                </span>
                <button
                  onClick={() => fetchExplanation('default')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Default
                </button>
                <button
                  onClick={() => fetchExplanation('simplified')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Simplified
                </button>
                <button
                  onClick={() => fetchExplanation('detailed')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Detailed
                </button>
                <button
                  onClick={() => fetchExplanation('example')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Example
                </button>
              </div>
              <hr className="my-6 border-neutral-800" />
              <div className="markdown">
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {explanations[currentSubtopic.id] || 'Loading...'}
                </ReactMarkdown>
              </div>
            </div>

            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="mb-6 text-2xl font-bold tracking-tight">
                Mastery Check
              </h3>
              <QuizPanel
                key={currentSubtopic.id}
                questions={currentSubtopic.questions}
                onPassed={async () => {
                  try {
                    const res = await fetch('/api/mastery', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ subtopicId: currentSubtopic.id }),
                    });
                    if (!res.ok)
                      throw new Error((await res.json()).error || 'HTTP');
                    // Unlock next subtopic locally
                    const idx = ui.getState().currentIndex;
                    const next = Math.min(
                      idx + 1,
                      initial.subtopics.length - 1
                    );
                    ui.setState({
                      currentIndex: next,
                      unlockedIndex: Math.max(
                        ui.getState().unlockedIndex,
                        next
                      ),
                    });
                  } catch (e) {
                    // silent
                  }
                }}
              />
            </div>
          </div>
        ) : (
          <div className="flex h-full min-h-[60vh] items-center justify-center rounded-lg border-2 border-dashed border-neutral-800 text-neutral-500">
            <p>Select a subtopic to begin</p>
          </div>
        )}
      </main>

      {/* Right: AI Tutor */}
      <aside className="sticky top-24 h-[calc(100vh-8rem)] self-start lg:col-span-3">
        <ChatPanel documentContent={initial.originalContent} />
      </aside>
    </div>
  );
}

function QuizPanel({
  questions,
  onPassed,
}: {
  questions: QuizQuestion[];
  onPassed: () => void;
}) {
  const [answers, setAnswers] = useState<number[]>([]);
  const [revealed, setRevealed] = useState(false);

  const setAns = (qIndex: number, ansIndex: number) => {
    const next = [...answers];
    next[qIndex] = ansIndex;
    setAnswers(next);
  };

  const check = () => {
    setRevealed(true);
    const allCorrect = questions.every((q, i) => answers[i] === q.answerIndex);
    if (allCorrect) setTimeout(onPassed, 900);
  };

  useEffect(() => {
    setAnswers([]);
    setRevealed(false);
  }, [questions.map((q) => q.id).join('|')]);

  if (!questions || questions.length === 0) {
    return (
      <p className="text-sm text-neutral-400">
        No quiz questions for this subtopic.
      </p>
    );
  }

  return (
    <div className="space-y-4">
      <ul className="space-y-6">
        {questions.map((q, i) => (
          <li key={q.id} className="space-y-3">
            <div className="font-medium text-neutral-200">{q.prompt}</div>
            <div className="grid gap-2">
              {q.options.map((o, j) => {
                const isSelected = answers[i] === j;
                const isCorrect = revealed && j === q.answerIndex;
                const isIncorrect =
                  revealed && isSelected && j !== q.answerIndex;
                const buttonClass = `rounded-md border p-3 text-left transition-all text-sm ${
                  isCorrect
                    ? 'border-green-500 bg-green-900/30'
                    : isIncorrect
                      ? 'border-red-500 bg-red-900/30'
                      : isSelected
                        ? 'border-blue-500 bg-blue-900/20'
                        : 'border-neutral-700 hover:bg-neutral-800'
                }`;
                return (
                  <button
                    key={j}
                    onClick={() => setAns(i, j)}
                    className={buttonClass}
                    disabled={revealed}
                  >
                    {o}
                  </button>
                );
              })}
            </div>
            {revealed && q.explanation && (
              <div className="mt-4 border-t border-neutral-800 pt-3 text-sm text-neutral-400">
                {q.explanation}
              </div>
            )}
          </li>
        ))}
      </ul>
      <div className="flex items-center gap-4 pt-4">
        <button
          onClick={check}
          disabled={revealed || questions.length === 0}
          className="rounded-md bg-white px-5 py-2 font-semibold text-black disabled:opacity-50"
        >
          Check Answer
        </button>
      </div>
    </div>
  );
}
</file>

<file path="prisma/migrations/20250807100731_init/migration.sql">
-- CreateTable
CREATE TABLE "public"."Account" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "provider" TEXT NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "refresh_token" TEXT,
    "access_token" TEXT,
    "expires_at" INTEGER,
    "token_type" TEXT,
    "scope" TEXT,
    "id_token" TEXT,
    "session_state" TEXT,

    CONSTRAINT "Account_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Session" (
    "id" TEXT NOT NULL,
    "sessionToken" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Session_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."VerificationToken" (
    "identifier" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL
);

-- CreateTable
CREATE TABLE "public"."User" (
    "id" TEXT NOT NULL,
    "name" TEXT,
    "email" TEXT,
    "emailVerified" TIMESTAMP(3),
    "image" TEXT,
    "elo" INTEGER NOT NULL DEFAULT 1000,
    "streak" INTEGER NOT NULL DEFAULT 0,
    "lastStudiedAt" TIMESTAMP(3),

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Lecture" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "originalContent" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Lecture_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Subtopic" (
    "id" TEXT NOT NULL,
    "order" INTEGER NOT NULL,
    "title" TEXT NOT NULL,
    "importance" TEXT NOT NULL,
    "difficulty" INTEGER NOT NULL,
    "overview" TEXT NOT NULL,
    "explanation" TEXT,
    "lectureId" TEXT NOT NULL,

    CONSTRAINT "Subtopic_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."QuizQuestion" (
    "id" TEXT NOT NULL,
    "prompt" TEXT NOT NULL,
    "options" JSONB NOT NULL,
    "answerIndex" INTEGER NOT NULL,
    "explanation" TEXT NOT NULL,
    "subtopicId" TEXT NOT NULL,

    CONSTRAINT "QuizQuestion_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."UserMastery" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "subtopicId" TEXT NOT NULL,

    CONSTRAINT "UserMastery_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Account_provider_providerAccountId_key" ON "public"."Account"("provider", "providerAccountId");

-- CreateIndex
CREATE UNIQUE INDEX "Session_sessionToken_key" ON "public"."Session"("sessionToken");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_token_key" ON "public"."VerificationToken"("token");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_identifier_token_key" ON "public"."VerificationToken"("identifier", "token");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "public"."User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Subtopic_lectureId_order_key" ON "public"."Subtopic"("lectureId", "order");

-- CreateIndex
CREATE UNIQUE INDEX "UserMastery_userId_subtopicId_key" ON "public"."UserMastery"("userId", "subtopicId");
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="prisma/schema.prisma">
// Schema generated by setup script from the migration plan.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("POSTGRES_URL")
  directUrl         = env("POSTGRES_URL_NON_POOLING")
  shadowDatabaseUrl = env("POSTGRES_SHADOW_URL")
  relationMode      = "prisma"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id                String        @id @default(cuid())
  name              String?
  email             String?       @unique
  emailVerified     DateTime?
  image             String?
  elo               Int           @default(1000)
  streak            Int           @default(0)
  lastStudiedAt     DateTime?
  accounts          Account[]
  sessions          Session[]
  lectures          Lecture[]
  masteredSubtopics UserMastery[]
}

model Lecture {
  id              String   @id @default(cuid())
  title           String
  originalContent String   @db.Text
  createdAt       DateTime @default(now())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  subtopics       Subtopic[]
}

model Subtopic {
  id          String         @id @default(cuid())
  order       Int
  title       String
  importance  String
  difficulty  Int
  overview    String
  explanation String?        @db.Text
  lectureId   String
  lecture     Lecture        @relation(fields: [lectureId], references: [id], onDelete: Cascade)
  questions   QuizQuestion[]
  masteredBy  UserMastery[]

  @@unique([lectureId, order])
}

model QuizQuestion {
  id          String   @id @default(cuid())
  prompt      String
  options     Json
  answerIndex Int
  explanation String
  subtopicId  String
  subtopic    Subtopic @relation(fields: [subtopicId], references: [id], onDelete: Cascade)
}

model UserMastery {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  subtopicId String
  subtopic   Subtopic @relation(fields: [subtopicId], references: [id], onDelete: Cascade)

  @@unique([userId, subtopicId])
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/app/api/breakdown/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateJSON } from '@/lib/ai';

export async function POST(req: NextRequest) {
  try {
    const { content } = await req.json();

    if (!content) {
      return NextResponse.json({ error: 'Content is required.' }, { status: 400 });
    }

    // A detailed prompt for generating a topic breakdown.
    const prompt = `
      As an expert instructional designer, analyze the following text and break it down into a structured learning path.
      The output must be a JSON object with two keys: "topic" (a concise title for the overall subject) and "subtopics" (an array of objects).
      Each subtopic object must have the following keys:
      - "title": A clear, concise title for the subtopic.
      - "importance": A rating of "high", "medium", or "low".
      - "difficulty": A number from 1 (easy) to 3 (hard).
      - "overview": A one-sentence summary of what the subtopic covers.

      Here is the text to analyze:
      ---
      ${content}
      ---
    `;

    const aiResponse = await generateJSON(prompt);
    return NextResponse.json(aiResponse);

  } catch (error: any) {
    console.error("Error in breakdown API:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
</file>

<file path="src/app/api/chat/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateText } from '@/lib/ai';

export async function POST(req: NextRequest) {
  try {
    const { userQuestion, documentContent } = await req.json() as { userQuestion: string, documentContent: string };

    if (!userQuestion) {
      return NextResponse.json({ error: 'A question is required.' }, { status: 400 });
    }

    const systemPrompt = `
      You are an expert academic tutor. Your primary goal is to help the user learn, both by explaining the provided study material and by answering general knowledge questions that aid in their understanding.

      **YOUR BEHAVIOR:**
      1.  **Prioritize the Document:** First, check if the user's question can be answered using the "DOCUMENT CONTENT" provided below. If it can, base your answer primarily on the document.
      2.  **Use General Knowledge:** If the question is about a general topic or is unrelated to the document, use your own extensive knowledge to provide an accurate and helpful answer.
      3.  **Acknowledge Your Source (If Possible):** When it feels natural, clarify the source of your information. For example:
          - "According to the provided text, the xv6 operating system..."
          - "That's a great general question. Apple Silicon processors are based on the ARM architecture, not RISC-V. Here's a bit more on that..."
      4.  **Be a Helpful Tutor:** Your tone should always be encouraging, clear, and helpful.

      ---
      **DOCUMENT CONTENT (for context, if available):**
      ${documentContent || 'No document has been provided yet.'}
      ---
      
      **USER'S QUESTION:**
      ${userQuestion}
    `;

    const aiTextResponse = await generateText(systemPrompt);
    
    return NextResponse.json({ response: aiTextResponse });

  } catch (error: any) {
    console.error("Error in chat API:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
</file>

<file path="src/app/api/explain-db/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { requireSession } from '@/lib/auth';
import { generateText } from '@/lib/ai';

export type ExplanationStyle = 'default' | 'simplified' | 'detailed' | 'example';

export async function POST(req: NextRequest) {
  try {
    await requireSession();
    const { subtopicId, style = 'default' } = (await req.json()) as {
      subtopicId: string;
      style?: ExplanationStyle;
    };

    if (!subtopicId) {
      return NextResponse.json(
        { error: 'subtopicId is required.' },
        { status: 400 }
      );
    }

    const subtopic = await prisma.subtopic.findUnique({
      where: { id: subtopicId },
    });
    if (!subtopic) {
      return NextResponse.json({ error: 'Subtopic not found.' }, { status: 404 });
    }

    // If already cached, return it
    if (subtopic.explanation && style === 'default') {
      return NextResponse.json({ explanation: subtopic.explanation });
    }

    let styleInstruction = '';
    switch (style) {
      case 'simplified':
        styleInstruction =
          'Explain in very simple terms, as if for a first-year student.';
        break;
      case 'detailed':
        styleInstruction =
          'Provide a detailed, in-depth explanation suitable for a post-graduate student, covering nuances and complexities.';
        break;
      case 'example':
        styleInstruction =
          'Focus on a concrete, real-world example; keep theory brief, emphasize practical application.';
        break;
      default:
        styleInstruction =
          'Provide a clear and comprehensive explanation suitable for a university undergraduate.';
        break;
    }

    const prompt = `
      You are a University Professor creating a study guide about "${subtopic.title}".
      ${styleInstruction}
      Use clean Markdown with headings (###, ####), lists, and code blocks where helpful.
      Base the explanation on the following lecture text for context:
      ---
      ${subtopic.overview || ''}
    `;

    const markdownExplanation = await generateText(prompt);

    // Save fresh explanation for default style
    if (style === 'default') {
      await prisma.subtopic.update({
        where: { id: subtopicId },
        data: { explanation: markdownExplanation },
      });
    }

    return NextResponse.json({ explanation: markdownExplanation });
  } catch (error: any) {
    const status = error?.status || 500;
    console.error('EXPLAIN_DB_API_ERROR:', error?.stack || error?.message || error);
    return NextResponse.json({ error: error.message }, { status });
  }
}
</file>

<file path="src/app/api/lectures/[lectureId]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function PATCH(
  req: NextRequest,
  { params }: { params: { lectureId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user)
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    const userId = (session.user as any).id as string;
    const { title } = await req.json();

    if (!title || typeof title !== 'string' || title.trim().length < 3) {
      return NextResponse.json(
        { error: 'Title must be at least 3 characters' },
        { status: 400 }
      );
    }

    const owned = await prisma.lecture.findFirst({
      where: { id: params.lectureId, userId },
      select: { id: true },
    });
    if (!owned) return NextResponse.json({ error: 'Not found' }, { status: 404 });

    const updated = await prisma.lecture.update({
      where: { id: params.lectureId },
      data: { title: title.trim() },
      select: { id: true, title: true },
    });

    return NextResponse.json({ ok: true, lecture: updated });
  } catch (e: any) {
    console.error('LECTURE_PATCH_ERROR', e);
    return NextResponse.json(
      { error: e.message || 'Server error' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/lectures/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import pdf from 'pdf-extraction';
import prisma from '@/lib/prisma';
import { requireSession } from '@/lib/auth';
import { generateJSON } from '@/lib/ai';

export const runtime = 'nodejs';
export const maxDuration = 60;

type Breakdown = {
  topic: string;
  subtopics: Array<{
    title: string;
    importance: string;
    difficulty: number;
    overview?: string;
  }>;
};

type QuizOut = {
  questions: Array<{
    prompt: string;
    options: string[];
    answerIndex: number;
    explanation: string;
    subtopicTitle?: string;
  }>;
};

export async function POST(req: NextRequest) {
  try {
    const session = await requireSession();
    const userId = (session.user as any).id as string;

    const contentType = req.headers.get('content-type') || '';
    let text = '';

    if (contentType.includes('multipart/form-data')) {
      const form = await req.formData();
      const file = form.get('file');
      if (!file || !(file instanceof File)) {
        return NextResponse.json(
          { error: 'No file provided. Please upload a single PDF.' },
          { status: 400 }
        );
      }
      if (!file.name.toLowerCase().endsWith('.pdf')) {
        return NextResponse.json(
          { error: 'Invalid file type. Only PDF files are accepted.' },
          { status: 400 }
        );
      }
      const arrayBuffer = await file.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);
      const data = await pdf(buffer);
      text = (data.text || '').replace(/\s{2,}/g, ' ').trim();
      if (!text) {
        return NextResponse.json(
          {
            error:
              'Could not extract text from the PDF. The file may only contain images.',
          },
          { status: 422 }
        );
      }
    } else if (contentType.includes('application/json')) {
      const body = await req.json();
      text = (body?.content || '').toString();
      if (!text?.trim()) {
        return NextResponse.json(
          { error: 'Content is required.' },
          { status: 400 }
        );
      }
    } else {
      return NextResponse.json(
        { error: 'Unsupported content type.' },
        { status: 415 }
      );
    }

    // Ask AI once for breakdown
    const breakdownPrompt = `
      As an expert instructional designer, analyze the following text and break it down into a structured learning path.
      Output JSON with keys: "topic" and "subtopics".
      Each subtopic: { "title", "importance": "high"|"medium"|"low", "difficulty": 1|2|3, "overview": string }.
      ---
      ${text}
    `;
    const bd = (await generateJSON(breakdownPrompt)) as Breakdown;

    // Ask AI for quiz from subtopics
    const quizPrompt = `
      You are an expert in educational assessments. Generate a quiz based on the subtopics.
      Response MUST be a single JSON object with key "questions".
      For each subtopic, create exactly one multiple-choice question:
      { "prompt", "options": [4 strings], "answerIndex": 0-3, "explanation", "subtopicTitle" }.
      ---
      ${JSON.stringify(bd.subtopics, null, 2)}
      ---
    `;
    const qz = (await generateJSON(quizPrompt)) as QuizOut;

    // Persist everything in one transaction
    const result = await prisma.$transaction(async (tx) => {
      const lecture = await tx.lecture.create({
        data: {
          title: bd.topic || 'Untitled',
          originalContent: text,
          userId,
        },
      });

      // Create subtopics with order
      const subtopics = await Promise.all(
        bd.subtopics.map((s, idx) =>
          tx.subtopic.create({
            data: {
              order: idx,
              title: s.title,
              importance: s.importance,
              difficulty: s.difficulty,
              overview: s.overview || '',
              lectureId: lecture.id,
            },
          })
        )
      );

      // Index subtopics by title (case-insensitive) for linking questions
      const byTitle = new Map<string, string>();
      for (const st of subtopics) {
        byTitle.set(st.title.trim().toLowerCase(), st.id);
      }

      // Create quiz questions
      for (const q of qz.questions || []) {
        const matchTitle = (q.subtopicTitle || '').trim().toLowerCase();
        const subtopicId =
          byTitle.get(matchTitle) ??
          // fallback: try contains
          Array.from(byTitle.entries()).find(([t]) => t.includes(matchTitle))
            ?.[1] ??
          subtopics[0]?.id; // last resort: first subtopic

        if (!subtopicId) continue;

        await tx.quizQuestion.create({
          data: {
            prompt: q.prompt,
            options: q.options as unknown as any, // Prisma Json
            answerIndex: q.answerIndex,
            explanation: q.explanation,
            subtopicId,
          },
        });
      }

      return lecture;
    });

    return NextResponse.json({ lectureId: result.id }, { status: 201 });
  } catch (e: any) {
    const status = e?.status || 500;
    console.error('LECTURES_API_ERROR:', e?.stack || e?.message || e);
    return NextResponse.json({ error: e?.message || 'Server error' }, { status });
  }
}
</file>

<file path="src/app/api/mastery/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { requireSession } from '@/lib/auth';

export async function POST(req: NextRequest) {
  try {
    const session = await requireSession();
    const userId = (session.user as any).id as string;

    const { subtopicId, eloDelta = 5 } = (await req.json()) as {
      subtopicId: string;
      eloDelta?: number;
    };

    if (!subtopicId) {
      return NextResponse.json(
        { error: 'subtopicId is required.' },
        { status: 400 }
      );
    }

    // Create mastery; ignore if already exists
    await prisma.userMastery.upsert({
      where: { userId_subtopicId: { userId, subtopicId } },
      update: {},
      create: { userId, subtopicId },
    });

    // Update ELO
    await prisma.user.update({
      where: { id: userId },
      data: { elo: { increment: eloDelta } },
    });

    return NextResponse.json({ ok: true });
  } catch (e: any) {
    const status = e?.status || 500;
    console.error('MASTERY_API_ERROR:', e?.stack || e?.message || e);
    return NextResponse.json({ error: e?.message || 'Server error' }, { status });
  }
}
</file>

<file path="src/app/api/upload-pdf/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import pdf from 'pdf-extraction';

// Set the runtime to Node.js for server-side operations.
export const runtime = 'nodejs';
// Increase the timeout to handle large PDF files.
export const maxDuration = 60;

export async function POST(req: NextRequest) {
  try {
    const form = await req.formData();
    const file = form.get('file');

    if (!file || !(file instanceof File)) {
      return NextResponse.json(
        { error: 'No file provided. Please upload a single PDF.' },
        { status: 400 }
      );
    }

    if (!file.name.toLowerCase().endsWith('.pdf')) {
      return NextResponse.json(
        { error: 'Invalid file type. Only PDF files are accepted.' },
        { status: 400 }
      );
    }

    // Convert the uploaded file's data into a Node.js Buffer.
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Use the 'pdf-extraction' library to get text from the buffer.
    const data = await pdf(buffer);

    // The extracted text is in data.text.
    const text = (data.text || '').replace(/\s{2,}/g, ' ').trim();

    if (!text) {
      return NextResponse.json(
        { error: 'Could not extract text from the PDF. The file may only contain images.' },
        { status: 422 } // Unprocessable Entity
      );
    }

    return NextResponse.json({
      filename: file.name,
      pages: data.numpages,
      content: text,
    });

  } catch (e: any) {
    // Log the full error on the server for easier debugging.
    console.error('UPLOAD_PDF_ERROR:', e?.stack || e?.message || e);
    const errorMessage = e.message || 'An unknown error occurred during processing.';
    return NextResponse.json({ error: `Failed to process PDF: ${errorMessage}` }, { status: 500 });
  }
}
</file>

<file path="src/app/api/whoami/route.ts">
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET() {
  const session = await getServerSession(authOptions);
  return NextResponse.json({
    ok: true,
    hasSession: !!session,
    user: session?.user ?? null,
  });
}
</file>

<file path="src/app/learn/[lectureId]/page.tsx">
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { notFound, redirect } from 'next/navigation';
import LearnView from '@/components/LearnView';

export default async function LearnPage({
  params,
}: {
  params: { lectureId: string };
}) {
  const session = await getServerSession(authOptions);
  if (!session || !session.user || !(session.user as any).id) {
    redirect('/api/auth/signin');
  }
  const userId = (session.user as any).id as string;

  const lecture = await prisma.lecture.findFirst({
    where: { id: params.lectureId, userId },
    include: {
      subtopics: {
        orderBy: { order: 'asc' },
        include: {
          questions: true,
          masteredBy: { where: { userId } },
        },
      },
    },
  });

  if (!lecture) {
    notFound();
  }

  // Normalize data for the client component
  const initial = {
    id: lecture.id,
    title: lecture.title,
    originalContent: lecture.originalContent,
    subtopics: lecture.subtopics.map((s) => ({
      id: s.id,
      order: s.order,
      title: s.title,
      importance: s.importance,
      difficulty: s.difficulty,
      overview: s.overview,
      explanation: s.explanation || '',
      mastered: s.masteredBy.length > 0,
      questions: s.questions.map((q) => ({
        id: q.id,
        prompt: q.prompt,
        options: q.options as unknown as string[],
        answerIndex: q.answerIndex,
        explanation: q.explanation,
      })),
    })),
  };

  return <LearnView initial={initial} />;
}
</file>

<file path="src/app/learn/page.tsx.bak_1754565157">
import { redirect } from 'next/navigation';

// This page previously hosted a client-only "workspace" that may have lost
// its default export or returned something invalid for Next.js 15 App Router.
// We now make it a simple server component that redirects users to Dashboard,
// where they can open/create persistent lectures. Adjust as needed.

export default function LearnRedirectPage() {
  redirect('/dashboard');
}
</file>

<file path="src/app/learn/page.tsx.bak_save_open">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { createLectureFromText, createLectureFromPdf } from '@/lib/client/lectures';
import { useLearnStore } from '@/lib/learn-store';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import type { ExplanationStyle } from '@/app/api/explain/route';
import { Loader2, Wand2 } from 'lucide-react';
import ChatPanel from '@/components/ChatPanel';

async function postJSON<T>(url: string, body: any): Promise<T> {
  const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
  if (!res.ok) { const err = await res.json().catch(() => ({})); throw new Error(err.error || `Request failed: ${res.status}`); }
  return res.json();
}
async function postForm<T>(url: string, form: FormData): Promise<T> {
  const res = await fetch(url, { method: 'POST', body: form });
  if (!res.ok) { const err = await res.json().catch(() => ({})); throw new Error(err.error || `Request failed: `); }
  return res.json();
}

const TopicProgressBar = ({ current, total }: { current: number, total: number }) => {
  const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
  return (
    <div className="space-y-2">
      <div className="flex justify-between items-baseline text-sm">
        <span className="font-medium text-neutral-300">Topic Progress</span>
        <span className="text-neutral-400">{current} / {total} Mastered</span>
      </div>
      <div className="w-full bg-neutral-800 rounded-full h-2.5">
        <div className="bg-green-500 h-2.5 rounded-full transition-all duration-500" style={{ width: `${percentage}%` }}></div>
      </div>
    </div>
  );
};

export default function Learn() {
  const [input, setInput] = useState('');
  const {
    topic, subtopics, unlockedIndex, currentIndex, content, explanation, quiz, loading, error,
    setContent, setBreakdown, setExplanation, setQuiz, setLoading, setError, selectIndex, unlockNext, resetAll,
  } = useLearnStore();

  const currentSubtopic = subtopics[currentIndex];
  const isSubtopicActive = currentSubtopic != null;

  const performAnalysis = async (text: string) => {
    try {
      setContent(text);
      setBreakdown('Analyzing, please wait...', []);
      const bd = await postJSON<{ topic: string; subtopics: any[] }>('/api/breakdown', { content: text });
      setBreakdown(bd.topic, bd.subtopics);
      const qz = await postJSON<{ questions: any[] }>('api/quiz', { subtopics: bd.subtopics });
      setQuiz(qz.questions);
    } catch (e: any) {
      setError(e.message || 'Failed to analyze content.');
      setBreakdown('Analysis Failed', []);
    }
  };

  const handleTextAnalysis = async () => {
    if (!input.trim() || loading) return;
    setLoading(true);
    setError(undefined);
    resetAll();
    try {
      await performAnalysis(input);
    } finally {
      setLoading(false);
    }
  };

  const handlePdfUpload = async (file: File) => {
    if (loading) return;
    setLoading(true);
    setError(undefined);
    resetAll();
    setInput('');
    setBreakdown(`Processing ${file.name}...`, []);
    try {
      const form = new FormData();
      form.append('file', file);
      const res = await postForm<{ content: string }>('/api/upload-pdf', form);
      await performAnalysis(res.content);
    } catch (e: any) {
      setError(e.message || 'Failed to upload PDF');
      setBreakdown('PDF Upload Failed', []);
    } finally {
      setLoading(false);
    }
  };

  const fetchExplanation = useCallback(async (style: ExplanationStyle = 'default') => {
    if (!currentSubtopic || !content) return;
    setExplanation('Crafting your learning module...');
    try {
      const res = await postJSON<{ explanation: string }>('/api/explain', { content, subtopicTitle: currentSubtopic.title, style });
      // No longer need the client-side parser. Trusting the new prompt.
      setExplanation(res.explanation);
    } catch (e: any) {
      setExplanation('Could not generate explanation. ' + e.message);
    }
  }, [content, currentSubtopic, setExplanation]);
  
  useEffect(() => {
    if (currentSubtopic) {
      fetchExplanation('default');
    }
  }, [currentIndex, currentSubtopic, fetchExplanation]);

  return (
    <div className="grid grid-cols-1 lg:grid-cols-10 gap-8 px-4">
      {/* --- Left Column: Workspace (2/10 width) --- */}
      <aside className="lg:col-span-2 rounded-lg border border-neutral-800 p-4 space-y-4 self-start">
        <h2 className="text-xl font-semibold">Learn Workspace</h2>
        <div 
          className="relative"
          onDragOver={(e) => e.preventDefault()}
          onDrop={(e) => { e.preventDefault(); const file = e.dataTransfer?.files?.[0]; if (file) handlePdfUpload(file); }}
        >
          <textarea
              className="w-full min-h-[120px] rounded-md bg-neutral-900 p-3 outline-none ring-1 ring-neutral-700 disabled:opacity-60"
              placeholder="Paste notes or drop a PDF..."
              value={input}
              onChange={(e) => setInput(e.target.value)}
              disabled={loading}
          />
        </div>
        <div className="flex gap-2">
            <button onClick={handleTextAnalysis} disabled={loading || !input.trim()} className="flex-1 inline-flex items-center justify-center gap-2 rounded-md bg-white px-4 py-2 text-black font-medium disabled:opacity-50 disabled:cursor-not-allowed">
              {loading ? ( <> <Loader2 className="w-4 h-4 animate-spin" /> Analyzing... </> ) : ( <> <Wand2 className="w-4 h-4" /> Analyze </> )}
            </button>
            <button onClick={() => { resetAll(); setInput(''); }} disabled={loading} className="rounded-md border border-neutral-700 px-4 py-2 text-neutral-200 disabled:opacity-50">Reset</button>
        </div>
        {error && (<div className="text-sm text-red-400" role="alert">{error}</div>)}
        <hr className="border-neutral-800" />
        <div>
            <div className="mb-2"><div className="text-sm uppercase text-neutral-400">Topic</div><div className="font-semibold text-lg">{topic}</div></div>
            {subtopics.length > 0 && ( <div className="my-4"> <TopicProgressBar current={unlockedIndex} total={subtopics.length} /> </div> )}
            {subtopics.length > 0 && (
                <ul className="space-y-1">{subtopics.map((s, i) => (
                    <li key={i}>
                      <button onClick={() => selectIndex(i)} disabled={i > unlockedIndex} className={`w-full text-left rounded-md px-3 py-2.5 text-sm leading-snug transition-colors ${i > unlockedIndex ? 'text-neutral-600' : i === currentIndex ? 'bg-neutral-800 text-white font-semibold' : 'text-neutral-300 hover:bg-neutral-900'}`}>
                        {i + 1}. {s.title}
                      </button>
                    </li>
                ))}</ul>
            )}
        </div>
      </aside>

      {/* --- Center Column: Main Content (5/10 width) --- */}
      <main className="lg:col-span-5">
        {isSubtopicActive ? (
          <div className="space-y-8">
            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
                <h3 className="text-3xl font-bold tracking-tight">{currentSubtopic.title}</h3>
                <div className="flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-neutral-400 mt-2">
                  <span>Importance: {currentSubtopic.importance}</span> <span>•</span> <span>Difficulty: {currentSubtopic.difficulty}</span>
                </div>
                <div className="mt-6 pt-4 border-t border-neutral-800/50 flex items-center gap-2">
                  <span className="text-sm font-medium text-neutral-400">Style:</span>
                  <button onClick={() => fetchExplanation('default')} className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700">Default</button>
                  <button onClick={() => fetchExplanation('simplified')} className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700">Simplified</button>
                  <button onClick={() => fetchExplanation('detailed')} className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700">Detailed</button>
                  <button onClick={() => fetchExplanation('example')} className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700">Example</button>
                </div>
                <hr className="border-neutral-800 my-6" />
                <div className="markdown">
                    <ReactMarkdown remarkPlugins={[remarkGfm]}>{explanation}</ReactMarkdown>
                </div>
            </div>
            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
                <h3 className="text-2xl font-bold tracking-tight mb-6">Mastery Check</h3>
                <QuizPanel key={currentIndex} quiz={quiz} onPassed={unlockNext} activeTitle={currentSubtopic.title} />
            </div>
          </div>
        ) : (
          <div className="h-full flex items-center justify-center rounded-lg border-2 border-dashed border-neutral-800 text-neutral-500 min-h-[60vh]">
            <p>{loading ? 'Analyzing...' : 'Analyze some content to begin learning'}</p>
          </div>
        )}
      </main>

      {/* --- Right Column: AI Tutor (3/10 width) --- */}
      <aside className="lg:col-span-3 h-[calc(100vh-8rem)] self-start sticky top-24">
        <ChatPanel documentContent={content} />
      </aside>
    </div>
  );
}

function QuizPanel({ quiz, onPassed, activeTitle }: { quiz: any[], onPassed: () => void, activeTitle?: string }) {
  const [answers, setAnswers] = useState<number[]>([]);
  const [revealed, setRevealed] = useState(false);
  
  const allCorrect = qs.length > 0 && qs.every((q, i) => answers[i] === q.answerIndex);
const relevantQs = activeTitle ? quiz.filter(q => q.subtopicTitle && q.subtopicTitle.toLowerCase().includes(activeTitle.toLowerCase())) : [];
  const qs = relevantQs.length > 0 ? relevantQs : [];
  const setAns = (qIndex: number, ansIndex: number) => { const next = [...answers]; next[qIndex] = ansIndex; setAnswers(next); };
  const check = () => { setRevealed(true); const allCorrect = qs.every((q, i) => answers[i] === q.answerIndex); if (allCorrect) setTimeout(onPassed, 1200); };
  useEffect(() => { setAnswers([]); setRevealed(false); }, [activeTitle]);
  return (
    <div className="space-y-4">
      {qs.length === 0 ? <p className="text-neutral-400 text-sm">No quiz questions available for this subtopic.</p> :
      <ul className="space-y-6">
        {qs.map((q, i) => (
          <li key={q.prompt} className="space-y-3">
            <div className="font-medium text-neutral-200">{q.prompt}</div>
            <div className="grid gap-2">
              {q.options.map((o: string, j: number) => {
                const isSelected = answers[i] === j;
                const isCorrect = revealed && j === q.answerIndex;
                const isIncorrect = revealed && isSelected && j !== q.answerIndex;
                const buttonClass = `rounded-md border p-3 text-left transition-all text-sm ${ isCorrect ? 'border-green-500 bg-green-900/30' : isIncorrect ? 'border-red-500 bg-red-900/30' : isSelected ? 'border-blue-500 bg-blue-900/20' : 'border-neutral-700 hover:bg-neutral-800' }`;
                return <button key={j} onClick={() => setAns(i, j)} className={buttonClass} disabled={revealed && qs.every((q, i) => answers[i] === q.answerIndex)}>{o}</button>;
              })}
            </div>
            {revealed && q.explanation && <div className="text-sm text-neutral-400 pt-3 border-t border-neutral-800 mt-4">{q.explanation}</div>}
          </li>
        ))}
      </ul>}
      <div className="flex items-center gap-4 pt-4">
        <button onClick={check} disabled={revealed || qs.length === 0} className="rounded-md bg-white px-5 py-2 text-black font-semibold disabled:opacity-50">Check Answer</button>
      </div>
    </div>
  );
}


  const handleCreatePersistentLecture = async () => {
    if (loading) return;
    const text = input.trim();
    const fileInput = null; // You can extend to capture dropped file if you track it in state.
    try {
      setLoading(true);
      setError(undefined);
      if (text) {
        const { lectureId } = await createLectureFromText(text);
        window.location.href = `/learn/${lectureId}`;
        return;
      }
      // Fallback: ask user to pick a PDF if no text pasted
      alert('Please paste text first (or wire a file input to create from PDF).');
    } catch (e: any) {
      setError(e.message || 'Failed to create lecture.');
    } finally {
      setLoading(false);
    }
  };
</file>

<file path="src/components/AuthProvider.tsx">
'use client';

import { SessionProvider } from 'next-auth/react';

export default function AuthProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  return <SessionProvider>{children}</SessionProvider>;
}
</file>

<file path="src/components/ClientBoundary.tsx">
'use client';

import SignInOut from '@/components/SignInOut';

export default function ClientBoundary() {
  return <SignInOut />;
}
</file>

<file path="src/components/LearnView.tsx.bak2">
'use client';

import { useMemo, useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type LearnSubtopic,
  type QuizQuestion,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';

export default function LearnView({ initial }: { initial: LearnLecture }) {
  // Initialize UI store based on mastered subtopics
  const initialUnlocked = deriveUnlockedIndex(initial.subtopics);
  const storeRef = useRef(
    createLearnUIStore({ currentIndex: initialUnlocked, unlockedIndex: initialUnlocked })
  );
  const ui = storeRef.current;

  const currentSubtopic = initial.subtopics[ui.getState().currentIndex];

  // Explanations cache per subtopic (client-side only; default to server cached explanation string)
  const [explanations, setExplanations] = useState<Record<string, string>>(() =>
    Object.fromEntries(initial.subtopics.map((s) => [s.id, s.explanation || '']))
  );

  const canSelect = (i: number) => i <= ui.getState().unlockedIndex;

  // Ensure unlocked index remains aligned if server-side mastery changes on reload
  useEffect(() => {
    const u = deriveUnlockedIndex(initial.subtopics);
    ui.setState((s) => ({
      ...s,
      unlockedIndex: Math.max(u, s.unlockedIndex),
      currentIndex: Math.max(0, Math.min(s.currentIndex, initial.subtopics.length - 1)),
    }));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initial.subtopics.map((s) => s.mastered).join('|')]);

  const fetchExplanation = useCallback(
    async (style: 'default' | 'simplified' | 'detailed' | 'example' = 'default') => {
      const s = currentSubtopic;
      if (!s) return;
      setExplanations((e) => ({ ...e, [s.id]: 'Loading...' }));
      try {
        const res = await fetch('/api/explain-db', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ subtopicId: s.id, style }),
        });
        if (!res.ok) {
          const e = await res.json().catch(() => ({}));
          throw new Error(e.error || `HTTP ${res.status}`);
        }
        const data = (await res.json()) as { explanation: string };
        setExplanations((e) => ({ ...e, [s.id]: data.explanation }));
      } catch (e: any) {
        setExplanations((ex) => ({
          ...ex,
          [s.id]: 'Could not generate explanation. ' + e.message,
        }));
      }
    },
    [currentSubtopic]
  );

  useEffect(() => {
    const s = currentSubtopic;
    if (s && !explanations[s.id]) {
      fetchExplanation('default');
    }
  }, [currentSubtopic, explanations, fetchExplanation]);

  return (
    <div className="grid grid-cols-1 lg:grid-cols-10 gap-8 px-4">
      {/* Left: Outline */}
      <aside className="lg:col-span-2 rounded-lg border border-neutral-800 p-4 space-y-4 self-start">
        <h2 className="text-xl font-semibold">Lecture</h2>
        <div className="mb-2">
          <div className="text-sm uppercase text-neutral-400">Title</div>
          <div className="font-semibold text-lg">{initial.title}</div>
        </div>
        <ul className="space-y-1">
          {initial.subtopics.map((s, i) => (
            <li key={s.id}>
              <button
                onClick={() =>
                  canSelect(i) && ui.setState({ currentIndex: i })
                }
                disabled={!canSelect(i)}
                className={`w-full text-left rounded-md px-3 py-2.5 text-sm leading-snug transition-colors ${
                  i > ui.getState().unlockedIndex
                    ? 'text-neutral-600'
                    : i === ui.getState().currentIndex
                    ? 'bg-neutral-800 text-white font-semibold'
                    : 'text-neutral-300 hover:bg-neutral-900'
                }`}
              >
                {i + 1}. {s.title}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      {/* Center: Explanation + Quiz */}
      <main className="lg:col-span-5">
        {currentSubtopic ? (
          <div className="space-y-8">
            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="text-3xl font-bold tracking-tight">
                {currentSubtopic.title}
              </h3>
              <div className="flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-neutral-400 mt-2">
                <span>Importance: {currentSubtopic.importance}</span> <span>•</span>{' '}
                <span>Difficulty: {currentSubtopic.difficulty}</span>
              </div>
              <div className="mt-6 pt-4 border-t border-neutral-800/50 flex items-center gap-2">
                <span className="text-sm font-medium text-neutral-400">Style:</span>
                <button
                  onClick={() => fetchExplanation('default')}
                  className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700"
                >
                  Default
                </button>
                <button
                  onClick={() => fetchExplanation('simplified')}
                  className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700"
                >
                  Simplified
                </button>
                <button
                  onClick={() => fetchExplanation('detailed')}
                  className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700"
                >
                  Detailed
                </button>
                <button
                  onClick={() => fetchExplanation('example')}
                  className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700"
                >
                  Example
                </button>
              </div>
              <hr className="border-neutral-800 my-6" />
              <div className="markdown">
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {explanations[currentSubtopic.id] || 'Loading...'}
                </ReactMarkdown>
              </div>
            </div>

            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="text-2xl font-bold tracking-tight mb-6">Mastery Check</h3>
              <QuizPanel
                key={currentSubtopic.id}
                questions={currentSubtopic.questions}
                onPassed={async () => {
                  try {
                    const res = await fetch('/api/mastery', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ subtopicId: currentSubtopic.id }),
                    });
                    if (!res.ok) throw new Error((await res.json()).error || 'HTTP');
                    // Unlock next subtopic locally
                    const idx = ui.getState().currentIndex;
                    const next = Math.min(idx + 1, initial.subtopics.length - 1);
                    ui.setState({
                      currentIndex: next,
                      unlockedIndex: Math.max(ui.getState().unlockedIndex, next),
                    });
                  } catch (e) {
                    // Silent for now or add toast
                  }
                }}
              />
            </div>
          </div>
        ) : (
          <div className="h-full flex items-center justify-center rounded-lg border-2 border-dashed border-neutral-800 text-neutral-500 min-h-[60vh]">
            <p>Select a subtopic to begin</p>
          </div>
        )}
      </main>

      {/* Right: AI Tutor */}
      <aside className="lg:col-span-3 h-[calc(100vh-8rem)] self-start sticky top-24">
        <ChatPanel documentContent={initial.originalContent} />
      </aside>
    </div>
  );
}

function QuizPanel({
  questions,
  onPassed,
}: {
  questions: QuizQuestion[];
  onPassed: () => void;
}) {
  const [answers, setAnswers] = useState<number[]>([]);
  const [revealed, setRevealed] = useState(false);

  const setAns = (qIndex: number, ansIndex: number) => {
    const next = [...answers];
    next[qIndex] = ansIndex;
    setAnswers(next);
  };

  const check = () => {
    setRevealed(true);
    if (allCorrect) setTimeout(onPassed, 900);
  };

  useEffect(() => {
    setAnswers([]);
    setRevealed(false);
  }, [questions.map((q) => q.id).join('|')]);

  if (!questions || questions.length === 0) {
    return <p className="text-neutral-400 text-sm">No quiz questions for this subtopic.</p>;
  }

  return (
    <div className="space-y-4">
      <ul className="space-y-6">
        {questions.map((q, i) => (
          <li key={q.id} className="space-y-3">
            <div className="font-medium text-neutral-200">{q.prompt}</div>
            <div className="grid gap-2">
              {q.options.map((o, j) => {
                const isSelected = answers[i] === j;
                const isCorrect = revealed && j === q.answerIndex;
                const isIncorrect = revealed && isSelected && j !== q.answerIndex;
                const buttonClass = `rounded-md border p-3 text-left transition-all text-sm ${
                  isCorrect
                    ? 'border-green-500 bg-green-900/30'
                    : isIncorrect
                    ? 'border-red-500 bg-red-900/30'
                    : isSelected
                    ? 'border-blue-500 bg-blue-900/20'
                    : 'border-neutral-700 hover:bg-neutral-800'
                }`;
                return (
                  <button
                    key={j}
                    onClick={() => setAns(i, j)}
                    className={buttonClass}
                    disabled={revealed && allCorrect}
                  >
                    {o}
                  </button>
                );
              })}
            </div>
            {revealed && q.explanation && (
              <div className="text-sm text-neutral-400 pt-3 border-t border-neutral-800 mt-4">
                {q.explanation}
              </div>
            )}
          </li>
        ))}
      </ul>
      <div className="flex items-center gap-4 pt-4">
        <button
          onClick={check}
          disabled={revealed || questions.length === 0}
          className="rounded-md bg-white px-5 py-2 text-black font-semibold disabled:opacity-50"
        >
          Check Answer
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/LearnView.tsx.bak3">
'use client';

import { useMemo, useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type LearnSubtopic,
  type QuizQuestion,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';
import { renameLecture } from '@/lib/client/rename-lecture';

export default function LearnView({ initial }: { initial: LearnLecture }) {
  // Initialize UI-only store
  const initialUnlocked = deriveUnlockedIndex(initial.subtopics);
  const storeRef = useRef(
    createLearnUIStore({ currentIndex: initialUnlocked, unlockedIndex: initialUnlocked })
  );
  const ui = storeRef.current;

  const currentSubtopic = initial.subtopics[ui.getState().currentIndex];

  // Local title editing state
  const [title, setTitle] = useState(initial.title);
  const [isSavingTitle, setIsSavingTitle] = useState(false);
  const [saveMsg, setSaveMsg] = useState<string | null>(null);

  // "Saved to Dashboard" is inherent once lecture exists in DB; we just expose a button for UX
  const [savedHint, setSavedHint] = useState<string | null>(null);

  // Explanations cache per subtopic
  const [explanations, setExplanations] = useState<Record<string, string>>(() =>
    Object.fromEntries(initial.subtopics.map((s) => [s.id, s.explanation || '']))
  );

  const canSelect = (i: number) => i <= ui.getState().unlockedIndex;

  useEffect(() => {
    const u = deriveUnlockedIndex(initial.subtopics);
    ui.setState((s) => ({
      ...s,
      unlockedIndex: Math.max(u, s.unlockedIndex),
      currentIndex: Math.max(0, Math.min(s.currentIndex, initial.subtopics.length - 1)),
    }));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initial.subtopics.map((s) => s.mastered).join('|')]);

  const fetchExplanation = useCallback(
    async (style: 'default' | 'simplified' | 'detailed' | 'example' = 'default') => {
      const s = currentSubtopic;
      if (!s) return;
      setExplanations((e) => ({ ...e, [s.id]: 'Loading...' }));
      try {
        const res = await fetch('/api/explain-db', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ subtopicId: s.id, style }),
        });
        if (!res.ok) {
          const e = await res.json().catch(() => ({}));
          throw new Error(e.error || `HTTP ${res.status}`);
        }
        const data = (await res.json()) as { explanation: string };
        setExplanations((e) => ({ ...e, [s.id]: data.explanation }));
      } catch (e: any) {
        setExplanations((ex) => ({
          ...ex,
          [s.id]: 'Could not generate explanation. ' + e.message,
        }));
      }
    },
    [currentSubtopic]
  );

  useEffect(() => {
    const s = currentSubtopic;
    if (s && !explanations[s.id]) {
      fetchExplanation('default');
    }
  }, [currentSubtopic, explanations, fetchExplanation]);

  const handleRename = async () => {
    if (!title.trim() || title.trim().length < 3) {
      setSaveMsg('Title must be at least 3 characters.');
      return;
    }
    try {
      setIsSavingTitle(true);
      setSaveMsg(null);
      const res = await renameLecture(initial.id, title.trim());
      setSaveMsg('Lecture title saved.');
    } catch (e: any) {
      setSaveMsg(e.message || 'Failed to save title.');
    } finally {
      setIsSavingTitle(false);
      setTimeout(() => setSaveMsg(null), 2500);
    }
  };

  const handleSaveToDashboard = async () => {
    // The lecture already exists in DB; we simply give user feedback and a quick link.
    setSavedHint('Saved! You can access this lecture on your Dashboard.');
    setTimeout(() => setSavedHint(null), 2500);
  };

  return (
    <div className="grid grid-cols-1 lg:grid-cols-10 gap-8 px-4">
      {/* Left: Outline */}
      <aside className="lg:col-span-2 rounded-lg border border-neutral-800 p-4 space-y-4 self-start">
        <h2 className="text-xl font-semibold">Lecture</h2>

        {/* Rename row */}
        <div className="flex items-center gap-2">
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="flex-1 rounded-md bg-neutral-900 p-2 outline-none ring-1 ring-neutral-700"
            aria-label="Lecture title"
          />
          <button
            onClick={handleRename}
            disabled={isSavingTitle || title.trim().length < 3}
            className="rounded-md bg-white px-3 py-2 text-black text-sm font-medium disabled:opacity-50"
          >
            {isSavingTitle ? 'Saving...' : 'Save'}
          </button>
        </div>
        {saveMsg && <div className="text-xs text-neutral-400">{saveMsg}</div>}

        {/* Save to Dashboard */}
        <button
          onClick={handleSaveToDashboard}
          className="w-full rounded-md border border-neutral-700 px-3 py-2 text-sm hover:bg-neutral-900"
          title="This lecture is stored in your account; click for confirmation."
        >
          Save to Dashboard
        </button>
        {savedHint && <div className="text-xs text-green-400">{savedHint}</div>}

        <div className="mb-2">
          <div className="text-sm uppercase text-neutral-400">Title</div>
          <div className="font-semibold text-lg">{title}</div>
        </div>

        <ul className="space-y-1">
          {initial.subtopics.map((s, i) => (
            <li key={s.id}>
              <button
                onClick={() =>
                  canSelect(i) && ui.setState({ currentIndex: i })
                }
                disabled={!canSelect(i)}
                className={`w-full text-left rounded-md px-3 py-2.5 text-sm leading-snug transition-colors ${
                  i > ui.getState().unlockedIndex
                    ? 'text-neutral-600'
                    : i === ui.getState().currentIndex
                    ? 'bg-neutral-800 text-white font-semibold'
                    : 'text-neutral-300 hover:bg-neutral-900'
                }`}
              >
                {i + 1}. {s.title}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      {/* Center: Explanation + Quiz */}
      <main className="lg:col-span-5">
        {currentSubtopic ? (
          <div className="space-y-8">
            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="text-3xl font-bold tracking-tight">
                {currentSubtopic.title}
              </h3>
              <div className="flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-neutral-400 mt-2">
                <span>Importance: {currentSubtopic.importance}</span> <span>•</span>{' '}
                <span>Difficulty: {currentSubtopic.difficulty}</span>
              </div>
              <div className="mt-6 pt-4 border-t border-neutral-800/50 flex items-center gap-2">
                <span className="text-sm font-medium text-neutral-400">Style:</span>
                <button
                  onClick={() => fetchExplanation('default')}
                  className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700"
                >
                  Default
                </button>
                <button
                  onClick={() => fetchExplanation('simplified')}
                  className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700"
                >
                  Simplified
                </button>
                <button
                  onClick={() => fetchExplanation('detailed')}
                  className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700"
                >
                  Detailed
                </button>
                <button
                  onClick={() => fetchExplanation('example')}
                  className="text-sm rounded-md px-3 py-1 bg-neutral-800 hover:bg-neutral-700"
                >
                  Example
                </button>
              </div>
              <hr className="border-neutral-800 my-6" />
              <div className="markdown">
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {explanations[currentSubtopic.id] || 'Loading...'}
                </ReactMarkdown>
              </div>
            </div>

            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="text-2xl font-bold tracking-tight mb-6">Mastery Check</h3>
              <QuizPanel
                key={currentSubtopic.id}
                questions={currentSubtopic.questions}
                onPassed={async () => {
                  try {
                    const res = await fetch('/api/mastery', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ subtopicId: currentSubtopic.id }),
                    });
                    if (!res.ok) throw new Error((await res.json()).error || 'HTTP');
                    // Unlock next subtopic locally
                    const idx = ui.getState().currentIndex;
                    const next = Math.min(idx + 1, initial.subtopics.length - 1);
                    ui.setState({
                      currentIndex: next,
                      unlockedIndex: Math.max(ui.getState().unlockedIndex, next),
                    });
                  } catch (e) {
                    // silent
                  }
                }}
              />
            </div>
          </div>
        ) : (
          <div className="h-full flex items-center justify-center rounded-lg border-2 border-dashed border-neutral-800 text-neutral-500 min-h-[60vh]">
            <p>Select a subtopic to begin</p>
          </div>
        )}
      </main>

      {/* Right: AI Tutor */}
      <aside className="lg:col-span-3 h-[calc(100vh-8rem)] self-start sticky top-24">
        <ChatPanel documentContent={initial.originalContent} />
      </aside>
    </div>
  );
}

function QuizPanel({
  questions,
  onPassed,
}: {
  questions: QuizQuestion[];
  onPassed: () => void;
}) {
  const [answers, setAnswers] = useState<number[]>([]);
  const [revealed, setRevealed] = useState(false);

  const setAns = (qIndex: number, ansIndex: number) => {
    const next = [...answers];
    next[qIndex] = ansIndex;
    setAnswers(next);
  };

  const check = () => {
    setRevealed(true);
    if (allCorrect) setTimeout(onPassed, 900);
  };

  useEffect(() => {
    setAnswers([]);
    setRevealed(false);
  }, [questions.map((q) => q.id).join('|')]);

  if (!questions || questions.length === 0) {
    return <p className="text-neutral-400 text-sm">No quiz questions for this subtopic.</p>;
  }

  return (
    <div className="space-y-4">
      <ul className="space-y-6">
        {questions.map((q, i) => (
          <li key={q.id} className="space-y-3">
            <div className="font-medium text-neutral-200">{q.prompt}</div>
            <div className="grid gap-2">
              {q.options.map((o, j) => {
                const isSelected = answers[i] === j;
                const isCorrect = revealed && j === q.answerIndex;
                const isIncorrect = revealed && isSelected && j !== q.answerIndex;
                const buttonClass = `rounded-md border p-3 text-left transition-all text-sm ${
                  isCorrect
                    ? 'border-green-500 bg-green-900/30'
                    : isIncorrect
                    ? 'border-red-500 bg-red-900/30'
                    : isSelected
                    ? 'border-blue-500 bg-blue-900/20'
                    : 'border-neutral-700 hover:bg-neutral-800'
                }`;
                return (
                  <button
                    key={j}
                    onClick={() => setAns(i, j)}
                    className={buttonClass}
                    disabled={revealed && allCorrect}
                  >
                    {o}
                  </button>
                );
              })}
            </div>
            {revealed && q.explanation && (
              <div className="text-sm text-neutral-400 pt-3 border-t border-neutral-800 mt-4">
                {q.explanation}
              </div>
            )}
          </li>
        ))}
      </ul>
      <div className="flex items-center gap-4 pt-4">
        <button
          onClick={check}
          disabled={revealed || questions.length === 0}
          className="rounded-md bg-white px-5 py-2 text-black font-semibold disabled:opacity-50"
        >
          Check Answer
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/lib/client/learn-ui-store.ts">
import { create } from 'zustand';

type UIState = {
  currentIndex: number;
  unlockedIndex: number;
  setCurrentIndex: (i: number) => void;
  setUnlockedIndex: (i: number) => void;
};

export const createLearnUIStore = (initial: {
  currentIndex: number;
  unlockedIndex: number;
}) =>
  create<UIState>((set) => ({
    currentIndex: initial.currentIndex,
    unlockedIndex: initial.unlockedIndex,
    setCurrentIndex: (i) => set({ currentIndex: i }),
    setUnlockedIndex: (i) => set({ unlockedIndex: i }),
  }));
</file>

<file path="src/lib/client/rename-lecture.ts">
export async function renameLecture(lectureId: string, title: string) {
  const res = await fetch(`/api/lectures/${lectureId}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ title }),
  });
  if (!res.ok) {
    const e = await res.json().catch(() => ({}));
    throw new Error(e.error || `Failed (${res.status})`);
  }
  return res.json() as Promise<{
    ok: true;
    lecture: { id: string; title: string };
  }>;
}
</file>

<file path="src/lib/shared/learn-types.ts">
export type QuizQuestion = {
  id: string;
  prompt: string;
  options: string[];
  answerIndex: number;
  explanation: string;
};

export type LearnSubtopic = {
  id: string;
  order: number;
  title: string;
  importance: string;
  difficulty: number;
  overview: string;
  explanation: string;
  mastered: boolean;
  questions: QuizQuestion[];
};

export type LearnLecture = {
  id: string;
  title: string;
  originalContent: string;
  subtopics: LearnSubtopic[];
};

export function deriveUnlockedIndex(subtopics: LearnSubtopic[]): number {
  // Highest mastered index + 1 (at least 0)
  const lastMastered = subtopics.reduce((acc, s, i) => (s.mastered ? i : acc), -1);
  return Math.min(lastMastered + 1, Math.max(0, subtopics.length - 1));
}
</file>

<file path="src/lib/learn-store.ts">
import { create } from 'zustand';

export type Subtopic = {
  title: string;
  importance: 'low' | 'med' | 'high';
  difficulty: number;
  overview?: string;
};

export type Question = {
  prompt: string;
  options: string[];
  answerIndex: number;
  explanation?: string;
  subtopicTitle?: string;
};

type State = {
  topic: string;
  subtopics: Subtopic[];
  unlockedIndex: number;
  currentIndex: number;
  content: string;
  explanation: string; // Changed from summary
  quiz: Question[];
  loading: boolean;
  error?: string;
  setContent: (v: string) => void;
  setBreakdown: (topic: string, subs: Subtopic[]) => void;
  setExplanation: (s: string) => void; // Changed from setSummary
  setQuiz: (q: Question[]) => void;
  setLoading: (v: boolean) => void;
  setError: (e?: string) => void;
  selectIndex: (i: number) => void;
  unlockNext: () => void;
  resetAll: () => void;
};

export const useLearnStore = create<State>((set, get) => ({
  topic: 'Untitled',
  subtopics: [],
  unlockedIndex: 0,
  currentIndex: 0,
  content: '',
  explanation: '', // Changed from summary
  quiz: [],
  loading: false,
  setContent: (v) => set({ content: v }),
  setBreakdown: (topic, subs) =>
    set({
      topic,
      subtopics: subs,
      unlockedIndex: 0,
      currentIndex: 0,
    }),
  setExplanation: (s) => set({ explanation: s }), // Changed from setSummary
  setQuiz: (q) => set({ quiz: q }),
  setLoading: (v) => set({ loading: v }),
  setError: (e) => set({ error: e }),
  selectIndex: (i) => {
    const { unlockedIndex } = get();
    if (i <= unlockedIndex) set({ currentIndex: i });
  },
  unlockNext: () => {
    const { unlockedIndex, subtopics } = get();
    if (unlockedIndex < subtopics.length - 1) {
      set({ unlockedIndex: unlockedIndex + 1, currentIndex: unlockedIndex + 1 });
    }
  },
  resetAll: () =>
    set({
      topic: 'Untitled',
      subtopics: [],
      unlockedIndex: 0,
      currentIndex: 0,
      content: '',
      explanation: '', // Changed from summary
      quiz: [],
      loading: false,
      error: undefined,
    }),
}));
</file>

<file path="src/lib/prisma.ts">
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    // log: ['query'], // enable for debugging
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export default prisma;
</file>

<file path="src/lib/store.ts">
import { create } from 'zustand';

type Progress = {
  completedLectures: number;
  masteredSubtopics: number;
  elo: number;
  streak: number;
  lastStudyISO?: string;
};

type State = {
  progress: Progress;
  incrementLecture: () => void;
  addMastery: (n: number) => void;
  tickStudy: (minutes: number) => void;
};

export const useProgressStore = create<State>((set) => ({
  progress: {
    completedLectures: 0,
    masteredSubtopics: 0,
    elo: 1000,
    streak: 0,
  },
  incrementLecture: () =>
    set((s) => ({
      progress: {
        ...s.progress,
        completedLectures: s.progress.completedLectures + 1,
        elo: s.progress.elo + 10,
      },
    })),
  addMastery: (n: number) =>
    set((s) => ({
      progress: {
        ...s.progress,
        masteredSubtopics: s.progress.masteredSubtopics + n,
        elo: s.progress.elo + n * 5,
      },
    })),
  tickStudy: (minutes: number) =>
    set((s) => {
      const now = new Date();
      const prev = s.progress.lastStudyISO
        ? new Date(s.progress.lastStudyISO)
        : undefined;
      let streak = s.progress.streak;
      if (minutes >= 10) {
        if (!prev) {
          streak = 1;
        } else {
          const diffDays =
            Math.floor(
              (Date.UTC(
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
              ) -
                Date.UTC(
                  prev.getUTCFullYear(),
                  prev.getUTCMonth(),
                  prev.getUTCDate()
                )) /
                (1000 * 60 * 60 * 24)
            );
          if (diffDays === 1) streak = s.progress.streak + 1;
          else if (diffDays > 1) streak = 1; // reset if broken
        }
      }
      return {
        progress: {
          ...s.progress,
          streak,
          lastStudyISO: now.toISOString(),
        },
      };
    }),
}));
</file>

<file path=".prettierignore">
.next
node_modules
build
dist
coverage
.env*
</file>

<file path=".prettierrc.json">
{
  "printWidth": 80,
  "singleQuote": true,
  "semi": true,
  "trailingComma": "es5",
  "tabWidth": 2,
  "plugins": ["prettier-plugin-tailwindcss"]
}
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="PHASE5_NOTES.md">
Phase 5 — Persistent-first state

What changed:
- Client-side LearnView now derives unlockedIndex from mastered subtopics returned by the server.
- UI-only state (currentIndex, unlockedIndex) lives in a tiny Zustand store created per page mount.
- On quiz pass, the client calls /api/mastery to persist mastery, then locally unlocks the next subtopic.

What you can remove/stop using:
- src/lib/learn-store.ts (old in-memory topic/subtopic/quiz store driving the entire Learn flow)
- src/lib/store.ts for global "progress" numbers; use real values from DB on server pages instead.

Next steps to complete removal:
1) Remove imports/usages of useLearnStore and useProgressStore from client components.
2) On the Dashboard, read stats from DB directly (already implemented in Phase 4 server page).
3) If you still need per-session UI (like toasts, toggles), create tiny local Zustand stores colocated with those components.

Optional enhancements:
- Refetch lecture data after mastery to reflect new mastered state from DB (SWR/React Query) or navigate refresh.
- Add optimistic UI badge "Mastered" on subtopic list after pass.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
</file>

<file path="src/app/api/quiz/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateJSON } from '@/lib/ai';

export async function POST(req: NextRequest) {
  try {
    const { subtopics } = await req.json();

    if (!subtopics || !Array.isArray(subtopics) || subtopics.length === 0) {
      return NextResponse.json({ error: 'A list of subtopics is required.' }, { status: 400 });
    }

    // This prompt instructs the AI to create a mastery check quiz based on the subtopics.
    const prompt = `
      You are an expert in creating educational assessments. Your task is to generate a quiz based on the provided list of subtopics.

      **CRITICAL INSTRUCTIONS:**
      1. Your entire response MUST be a single, raw JSON object. Do not include any text, commentary, or markdown formatting like \`\`\`json before or after the JSON object.
      2. The root of the JSON object must be a key named "questions", which is an array of question objects.
      3. For each subtopic provided, create exactly one multiple-choice question.

      **Each question object in the "questions" array must have these exact keys:**
      - "prompt": The question text.
      - "options": An array of 4 strings representing the possible answers.
      - "answerIndex": The 0-based index of the correct answer in the "options" array.
      - "explanation": A brief explanation of why the correct answer is right.
      - "subtopicTitle": The title of the subtopic this question relates to.

      **Subtopics to use:**
      ---
      ${JSON.stringify(subtopics, null, 2)}
      ---
    `;

    const aiResponse = await generateJSON(prompt);
    return NextResponse.json(aiResponse);

  } catch (error: any)    {
    console.error("Error in quiz API:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
</file>

<file path="src/components/ChatPanel.tsx">
'use client';

import { useState, useRef, useEffect } from 'react';
import { Send, Loader2, User, Bot } from 'lucide-react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

type Message = {
  sender: 'user' | 'ai';
  text: string;
};

type ChatPanelProps = {
  documentContent: string;
};

async function postJSON<T>(url: string, body: any): Promise<T> {
  const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
  if (!res.ok) { const err = await res.json().catch(() => ({})); throw new Error(err.error || `Request failed: ${res.status}`); }
  return res.json();
}

export default function ChatPanel({ documentContent }: ChatPanelProps) {
  const [history, setHistory] = useState<Message[]>([
    { sender: 'ai', text: "I'm your AI Tutor. Ask me anything about the content on the left!" }
  ]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const scrollContainerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const scrollContainer = scrollContainerRef.current;
    if (scrollContainer) {
      scrollContainer.scrollTop = scrollContainer.scrollHeight;
    }
  }, [history]);

  const handleSendMessage = async () => {
    if (!input.trim() || isLoading || !documentContent) {
        if (!documentContent) {
            setHistory(prev => [...prev, { sender: 'ai', text: 'Please analyze some content first before asking questions.'}]);
        }
        return;
    };

    const userMessage: Message = { sender: 'user', text: input };
    setHistory(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const res = await postJSON<{ response: string }>('/api/chat', {
        userQuestion: input,
        documentContent,
      });
      const aiMessage: Message = { sender: 'ai', text: res.response };
      setHistory(prev => [...prev, aiMessage]);
    } catch (error) {
      const errorMessage: Message = { sender: 'ai', text: 'Sorry, I ran into an error. Please try again.' };
      setHistory(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex flex-col h-full rounded-lg border border-neutral-800 bg-neutral-900/50">
      <header className="flex items-center justify-between p-4 border-b border-neutral-800">
        <h3 className="font-semibold text-lg">AI Tutor</h3>
      </header>

      <div ref={scrollContainerRef} className="flex-1 p-4 space-y-6 overflow-y-auto">
        {history.map((msg, index) => (
          <div key={index} className={`flex items-start gap-3 ${msg.sender === 'user' ? 'justify-end' : ''}`}>
            {msg.sender === 'ai' && <div className="flex-shrink-0 w-8 h-8 rounded-full bg-neutral-700 flex items-center justify-center"><Bot className="w-5 h-5" /></div>}
            <div className={`max-w-xs md:max-w-md rounded-lg px-4 py-2 ${msg.sender === 'user' ? 'bg-blue-600 text-white' : 'bg-neutral-800'}`}>
              {msg.sender === 'ai' ? (
                <div className="markdown text-sm">
                  <ReactMarkdown remarkPlugins={[remarkGfm]}>
                    {msg.text}
                  </ReactMarkdown>
                </div>
              ) : (
                <p className="text-sm whitespace-pre-wrap">{msg.text}</p>
              )}
            </div>
            {msg.sender === 'user' && <div className="flex-shrink-0 w-8 h-8 rounded-full bg-neutral-700 flex items-center justify-center"><User className="w-5 h-5" /></div>}
          </div>
        ))}
        {isLoading && (
            <div className="flex items-start gap-3">
                <div className="flex-shrink-0 w-8 h-8 rounded-full bg-neutral-700 flex items-center justify-center"><Bot className="w-5 h-5" /></div>
                <div className="max-w-xs md:max-w-md rounded-lg px-4 py-2 bg-neutral-800 flex items-center">
                    <Loader2 className="w-5 h-5 animate-spin text-neutral-400" />
                </div>
            </div>
        )}
      </div>

      <footer className="p-4 border-t border-neutral-800">
        <div className="relative">
          <textarea
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={(e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                }
            }}
            placeholder="Ask about the content..."
            className="w-full rounded-md bg-neutral-800 pr-12 pl-4 py-2 resize-none ring-1 ring-transparent focus:ring-blue-500 outline-none"
            rows={1}
            disabled={isLoading || !documentContent}
          />
          <button onClick={handleSendMessage} disabled={isLoading || !input.trim() || !documentContent} className="absolute right-2 top-1/2 -translate-y-1/2 p-2 rounded-md bg-blue-600 text-white disabled:opacity-50">
            <Send className="w-4 h-4" />
          </button>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="src/components/LearnView.tsx">
'use client';

import { useMemo, useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type LearnSubtopic,
  type QuizQuestion,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';
import { renameLecture } from '@/lib/client/rename-lecture';

export default function LearnView({ initial }: { initial: LearnLecture }) {
  // Initialize UI-only store
  const initialUnlocked = deriveUnlockedIndex(initial.subtopics);
  const storeRef = useRef(
    createLearnUIStore({
      currentIndex: initialUnlocked,
      unlockedIndex: initialUnlocked,
    })
  );
  const ui = storeRef.current;

  const currentSubtopic = initial.subtopics[ui.getState().currentIndex];

  // Local title editing state
  const [title, setTitle] = useState(initial.title);
  const [isSavingTitle, setIsSavingTitle] = useState(false);
  const [saveMsg, setSaveMsg] = useState<string | null>(null);

  // "Saved to Dashboard" is inherent once lecture exists in DB; we just expose a button for UX// Explanations cache per subtopic
  const [explanations, setExplanations] = useState<Record<string, string>>(() =>
    Object.fromEntries(
      initial.subtopics.map((s) => [s.id, s.explanation || ''])
    )
  );

  const canSelect = (i: number) => i <= ui.getState().unlockedIndex;

  useEffect(() => {
    const u = deriveUnlockedIndex(initial.subtopics);
    ui.setState((s) => ({
      ...s,
      unlockedIndex: Math.max(u, s.unlockedIndex),
      currentIndex: Math.max(
        0,
        Math.min(s.currentIndex, initial.subtopics.length - 1)
      ),
    }));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initial.subtopics.map((s) => s.mastered).join('|')]);

  const fetchExplanation = useCallback(
    async (
      style: 'default' | 'simplified' | 'detailed' | 'example' = 'default'
    ) => {
      const s = currentSubtopic;
      if (!s) return;
      setExplanations((e) => ({ ...e, [s.id]: 'Loading...' }));
      try {
        const res = await fetch('/api/explain-db', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ subtopicId: s.id, style }),
        });
        if (!res.ok) {
          const e = await res.json().catch(() => ({}));
          throw new Error(e.error || `HTTP ${res.status}`);
        }
        const data = (await res.json()) as { explanation: string };
        setExplanations((e) => ({ ...e, [s.id]: data.explanation }));
      } catch (e: any) {
        setExplanations((ex) => ({
          ...ex,
          [s.id]: 'Could not generate explanation. ' + e.message,
        }));
      }
    },
    [currentSubtopic]
  );

  useEffect(() => {
    const s = currentSubtopic;
    if (s && !explanations[s.id]) {
      fetchExplanation('default');
    }
  }, [currentSubtopic, explanations, fetchExplanation]);

  const handleRename = async () => {
    if (!title.trim() || title.trim().length < 3) {
      setSaveMsg('Title must be at least 3 characters.');
      return;
    }
    try {
      setIsSavingTitle(true);
      setSaveMsg(null);
      const res = await renameLecture(initial.id, title.trim());
      setSaveMsg('Lecture title saved.');
    } catch (e: any) {
      setSaveMsg(e.message || 'Failed to save title.');
    } finally {
      setIsSavingTitle(false);
      setTimeout(() => setSaveMsg(null), 2500);
    }
  };

  const handleSaveToDashboard = async () => {
    // The lecture already exists in DB; we simply give user feedback and a quick link.
    setSavedHint('Saved! You can access this lecture on your Dashboard.');
    setTimeout(() => setSavedHint(null), 2500);
  };

  return (
    <div className="grid grid-cols-1 gap-8 px-4 lg:grid-cols-10">
      {/* Left: Outline */}
      <aside className="space-y-5 self-start rounded-lg border border-neutral-800 p-6 lg:col-span-2">
        <h2 className="text-xl font-semibold">Lecture</h2>

        <div className="flex flex-wrap items-center gap-3 sm:flex-nowrap">
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full rounded-md bg-neutral-900 px-3 py-2 ring-1 ring-neutral-700 outline-none"
            aria-label="Lecture title"
          />
          <button
            onClick={async () => {
              const newTitle = title.trim();
              if (!newTitle || newTitle.length < 3) {
                setSaveMsg('Title must be at least 3 characters.');
                return;
              }
              try {
                setIsSavingTitle(true);
                setSaveMsg(null);
                // Only call rename when changed
                if (newTitle !== initial.title) {
                  await renameLecture(initial.id, newTitle);
                }
                setSaveMsg('Saved!');
              } catch (e: any) {
                setSaveMsg(e.message || 'Failed to save.');
              } finally {
                setIsSavingTitle(false);
                setTimeout(() => setSaveMsg(null), 2000);
              }
            }}
            disabled={isSavingTitle || title.trim().length < 3}
            className="mt-2 rounded-md bg-white px-4 py-2 text-sm font-medium whitespace-nowrap text-black disabled:opacity-50 sm:mt-0 sm:ml-2"
          >
            {isSavingTitle ? 'Saving...' : 'Save'}
          </button>
        </div>
        {saveMsg && <div className="text-xs text-neutral-400">{saveMsg}</div>}

        <div className="mt-4 mb-2">
          <div className="text-sm text-neutral-400 uppercase">Title</div>
          <div className="text-lg font-semibold">{title}</div>
        </div>

        <ul className="space-y-1">
          {initial.subtopics.map((s, i) => (
            <li key={s.id}>
              <button
                onClick={() => canSelect(i) && ui.setState({ currentIndex: i })}
                disabled={!canSelect(i)}
                className={`w-full rounded-md px-3.5 py-3 text-left text-sm leading-snug transition-colors ${
                  i > ui.getState().unlockedIndex
                    ? 'text-neutral-600'
                    : i === ui.getState().currentIndex
                      ? 'bg-neutral-800 font-semibold text-white'
                      : 'text-neutral-300 hover:bg-neutral-900'
                }`}
              >
                {i + 1}. {s.title}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      {/* Center: Explanation + Quiz */}
      <main className="lg:col-span-5">
        {currentSubtopic ? (
          <div className="space-y-8">
            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="text-3xl font-bold tracking-tight">
                {currentSubtopic.title}
              </h3>
              <div className="mt-2 flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-neutral-400">
                <span>Importance: {currentSubtopic.importance}</span>{' '}
                <span>•</span>{' '}
                <span>Difficulty: {currentSubtopic.difficulty}</span>
              </div>
              <div className="mt-6 flex items-center gap-2 border-t border-neutral-800/50 pt-4">
                <span className="text-sm font-medium text-neutral-400">
                  Style:
                </span>
                <button
                  onClick={() => fetchExplanation('default')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Default
                </button>
                <button
                  onClick={() => fetchExplanation('simplified')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Simplified
                </button>
                <button
                  onClick={() => fetchExplanation('detailed')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Detailed
                </button>
                <button
                  onClick={() => fetchExplanation('example')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Example
                </button>
              </div>
              <hr className="my-6 border-neutral-800" />
              <div className="markdown">
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {explanations[currentSubtopic.id] || 'Loading...'}
                </ReactMarkdown>
              </div>
            </div>

            <div className="rounded-lg border border-neutral-800 bg-neutral-900/50 p-6 md:p-8">
              <h3 className="mb-6 text-2xl font-bold tracking-tight">
                Mastery Check
              </h3>
              <QuizPanel
                key={currentSubtopic.id}
                questions={currentSubtopic.questions}
                onPassed={async () => {
                  try {
                    const res = await fetch('/api/mastery', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ subtopicId: currentSubtopic.id }),
                    });
                    if (!res.ok)
                      throw new Error((await res.json()).error || 'HTTP');
                    // Unlock next subtopic locally
                    const idx = ui.getState().currentIndex;
                    const next = Math.min(
                      idx + 1,
                      initial.subtopics.length - 1
                    );
                    ui.setState({
                      currentIndex: next,
                      unlockedIndex: Math.max(
                        ui.getState().unlockedIndex,
                        next
                      ),
                    });
                  } catch (e) {
                    // silent
                  }
                }}
              />
            </div>
          </div>
        ) : (
          <div className="flex h-full min-h-[60vh] items-center justify-center rounded-lg border-2 border-dashed border-neutral-800 text-neutral-500">
            <p>Select a subtopic to begin</p>
          </div>
        )}
      </main>

      {/* Right: AI Tutor */}
      <aside className="sticky top-24 h-[calc(100vh-8rem)] self-start lg:col-span-3">
        <ChatPanel documentContent={initial.originalContent} />
      </aside>
    </div>
  );
}

function QuizPanel({
  questions,
  onPassed,
}: {
  questions: QuizQuestion[];
  onPassed: () => void;
}) {
  const [answers, setAnswers] = useState<number[]>([]);
  const [revealed, setRevealed] = useState(false);

  const setAns = (qIndex: number, ansIndex: number) => {
    const next = [...answers];
    next[qIndex] = ansIndex;
    setAnswers(next);
  };

  const check = () => {
    setRevealed(true);
    if (allCorrect) setTimeout(onPassed, 900);
  };

  useEffect(() => {
    setAnswers([]);
    setRevealed(false);
  }, [questions.map((q) => q.id).join('|')]);

  if (!questions || questions.length === 0) {
    return (
      <p className="text-sm text-neutral-400">
        No quiz questions for this subtopic.
      </p>
    );
  }

  return (
    <div className="space-y-4">
      <ul className="space-y-6">
        {questions.map((q, i) => (
          <li key={q.id} className="space-y-3">
            <div className="font-medium text-neutral-200">{q.prompt}</div>
            <div className="grid gap-2">
              {q.options.map((o, j) => {
                const isSelected = answers[i] === j;
                const isCorrect = revealed && j === q.answerIndex;
                const isIncorrect =
                  revealed && isSelected && j !== q.answerIndex;
                const buttonClass = `rounded-md border p-3 text-left transition-all text-sm ${
                  isCorrect
                    ? 'border-green-500 bg-green-900/30'
                    : isIncorrect
                      ? 'border-red-500 bg-red-900/30'
                      : isSelected
                        ? 'border-blue-500 bg-blue-900/20'
                        : 'border-neutral-700 hover:bg-neutral-800'
                }`;
                return (
                  <button
                    key={j}
                    onClick={() => setAns(i, j)}
                    className={buttonClass}
                    disabled={revealed && allCorrect}
                  >
                    {o}
                  </button>
                );
              })}
            </div>
            {revealed && q.explanation && (
              <div className="mt-4 border-t border-neutral-800 pt-3 text-sm text-neutral-400">
                {q.explanation}
              </div>
            )}
          </li>
        ))}
      </ul>
      <div className="flex items-center gap-4 pt-4">
        <button
          onClick={check}
          disabled={revealed || questions.length === 0}
          className="rounded-md bg-white px-5 py-2 font-semibold text-black disabled:opacity-50"
        >
          Check Answer
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/SignInOut.tsx">
'use client';

import { useSession, signIn, signOut } from 'next-auth/react';
import Link from 'next/link';

export default function SignInOut() {
  const { data: session, status } = useSession();

  if (status === 'loading') {
    return <span className="text-sm text-neutral-400">Loading...</span>;
  }

  if (!session) {
    return (
      <button
        onClick={() => signIn('google')}
        className="rounded-md bg-white px-3 py-1.5 text-black text-sm font-medium"
      >
        Sign In
      </button>
    );
  }

  return (
    <div className="flex items-center gap-3">
   
      <button
        onClick={() => signOut()}
        className="rounded-md border border-neutral-600 px-3 py-1.5 text-sm"
      >
        Sign Out
      </button>
    </div>
  );
}
</file>

<file path="src/lib/client/lectures.ts">
export async function createLectureFromText(
  content: string
): Promise<{ lectureId: string }> {
  const res = await fetch('/api/lectures', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content }),
  });
  if (!res.ok) {
    const e = await res.json().catch(() => ({}));
    throw new Error(e.error || `Failed: ${res.status}`);
  }
  return res.json();
}

export async function createLectureFromPdf(
  file: File
): Promise<{ lectureId: string }> {
  const form = new FormData();
  form.append('file', file);
  const res = await fetch('/api/lectures', { method: 'POST', body: form });
  if (!res.ok) {
    const e = await res.json().catch(() => ({}));
    throw new Error(e.error || `Failed: ${res.status}`);
  }
  return res.json();
}
</file>

<file path="src/lib/auth.ts">
import type { NextAuthOptions } from 'next-auth';
import { getServerSession } from "next-auth";
import GoogleProvider from 'next-auth/providers/google';
import { PrismaAdapter } from '@auth/prisma-adapter';
import prisma from '@/lib/prisma';

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID as string,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,
      allowDangerousEmailAccountLinking: true,
    }),
  ],
  session: { strategy: 'jwt' },
  callbacks: {
    async session({ session, token }) {
      if (session.user && token.sub) {
        (session.user as any).id = token.sub;
      }
      return session;
    },
  },
};
export async function requireSession() {
  const session = await getServerSession(authOptions as any);
  if (!session || !session.user) {
    const err: any = new Error('Unauthorized');
    err.status = 401;
    throw err;
  }
  return session;
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
.env*.local

/src/generated/prisma
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  
  /* config options here */
};

export default nextConfig;
</file>

<file path="README.md">
# LearnMax - Your Personal AI Study Companion

[![Built with Next.js](https://img.shields.io/badge/Built%20with-Next.js-black?logo=next.js)](https://nextjs.org)
[![Powered by Google Gemini](https://img.shields.io/badge/Powered%20by-Gemini%20AI-blue?logo=google)](https://ai.google.com/)
[![Styled with Tailwind CSS](https://img.shields.io/badge/Styled%20with-Tailwind%20CSS-38B2AC?logo=tailwind-css)](https://tailwindcss.com)

LearnMax is a web application designed to accelerate learning and improve comprehension. By leveraging the power of Google's Gemini AI, it transforms raw text or PDF study materials into a structured, interactive learning path.

## How It Works

1.  **Provide Content**: Paste text directly or upload a PDF of your lecture notes, an article, or any other study material into the Learn Workspace.
2.  **AI Analysis**: The application sends the content to the Gemini API, which analyzes the text and breaks it down into a logical sequence of subtopics.
3.  **Guided Learning**: For each subtopic, the AI generates a detailed explanation.
4.  **Mastery Check**: After studying a subtopic, take a quiz. You can only proceed to the next subtopic after you've passed the quiz, ensuring you've understood the concept.

## Features

-   **PDF & Text Upload**: Easily input your study materials.
-   **AI-Powered Topic Breakdown**: Automatically structures your content into a step-by-step learning plan.
-   **Detailed Explanations**: Get clear, AI-generated explanations for each subtopic.
-   **Mastery Quizzes**: Reinforce learning and ensure comprehension before moving on.
-   **Learning Dashboard**: Track your progress.
-   **Responsive Design**: Fully usable on desktop and mobile.

## Tech Stack

-   **Framework**: [Next.js](https://nextjs.org/)
-   **AI**: [Google Gemini API](https://ai.google.dev/)
-   **Styling**: [Tailwind CSS](https://tailwindcss.com/)
-   **State Management**: [Zustand](https://github.com/pmndrs/zustand)
-   **Deployment**: Vercel

## Getting Started

### Prerequisites

-   Node.js (v18 or later recommended)
-   A package manager like `npm`.
-   A Google AI API Key.

### Installation

1.  **Clone the repository:**
    ```sh
    git clone https://github.com/your-username/learnmax.git
    cd learnmax
    ```

2.  **Install dependencies:**
    ```sh
    npm install
    ```

3.  **Set up your environment variables:**
    -   Create a new file named `.env.local` in the root of the project.
    -   Copy the contents of `.env.example` into it.
    -   Get your API key from the [Google AI Studio](https://aistudio.google.com/app/apikey) and paste it into `.env.local`:
    ```env
    GOOGLE_API_KEY=your_super_secret_api_key
    ```

4.  **Run the development server:**
    ```sh
    npm run dev
    ```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## License

This project is available under the [MIT License](LICENSE).
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
      },
      borderRadius: {
        lg: `var(--radius)`,
        md: `calc(var(--radius) - 2px)`,
        sm: 'calc(var(--radius) - 4px)',
      },
    },
  },
  plugins: [
  ],
}

export default config
</file>

<file path="src/app/dashboard/page.tsx">
import Link from 'next/link';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { redirect } from 'next/navigation';
import { BookOpen, Target, BrainCircuit, Flame } from 'lucide-react';

function StatCard({
  icon: Icon,
  label,
  value,
  color,
}: {
  icon: React.ElementType;
  label: string;
  value: string | number;
  color: string;
}) {
  return (
    <div className="rounded-lg border border-neutral-800 bg-neutral-900 p-6 flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <span className="text-neutral-400">{label}</span>
        <Icon className={`w-6 h-6 ${color}`} />
      </div>
      <p className="text-4xl font-bold">{value}</p>
    </div>
  );
}

async function getData() {
  const session = await getServerSession(authOptions);
  if (!session || !session.user || !(session.user as any).id) {
    redirect('/api/auth/signin');
  }
  const userId = (session.user as any).id as string;

  const [user, lectures] = await Promise.all([
    prisma.user.findUnique({ where: { id: userId } }),
    prisma.lecture.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      include: {
        _count: { select: { subtopics: true } },
      },
    }),
  ]);

  return { user, lectures };
}

export default async function Dashboard() {
  const { user, lectures } = await getData();

  return (
    <div className="container-narrow space-y-12">
      <header>
        <h1 className="text-3xl font-bold tracking-tight">Your Dashboard</h1>
        <p className="text-neutral-400 mt-2">
          Welcome back{user?.name ? `, ${user.name}` : ''}! Here&apos;s a summary of your learning journey.
        </p>
      </header>
      <section className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="md:col-span-2 grid grid-cols-1 sm:grid-cols-2 gap-6">
          <StatCard
            label="Lectures Created"
            value={lectures.length}
            icon={BookOpen}
            color="text-blue-400"
          />
          <StatCard
            label="Subtopics Mastered"
            value={user?.masteredSubtopics ? user.masteredSubtopics.length : 0}
            icon={Target}
            color="text-green-400"
          />
          <StatCard
            label="Learning Elo"
            value={user?.elo ?? 1000}
            icon={BrainCircuit}
            color="text-purple-400"
          />
          <StatCard
            label="Current Streak"
            value={`${user?.streak ?? 0} days`}
            icon={Flame}
            color="text-orange-400"
          />
        </div>
        <div className="rounded-lg border border-neutral-800 bg-neutral-900 p-6 flex flex-col items-center justify-center text-center gap-4">
          <h3 className="text-xl font-semibold">Ready to Learn?</h3>
          <p className="text-neutral-400 text-sm">
            Create a lecture from text or PDF in the Learn Workspace.
          </p>
          <Link
            href="/learn"
            className="w-full rounded-md bg-white px-6 py-3 text-black font-semibold shadow-md transition-transform hover:scale-105"
          >
            Go to Workspace
          </Link>
        </div>
      </section>
      <section>
        <h2 className="text-2xl font-semibold">Your Lectures</h2>
        <div className="mt-6 space-y-4">
          {lectures.length === 0 && (
            <div className="text-neutral-400 text-sm">
              No lectures yet. Create one in the Learn Workspace.
            </div>
          )}
          {lectures.map((lec) => (
            <div
              key={lec.id}
              className="rounded-lg border border-neutral-800 bg-neutral-900 p-4 flex items-center justify-between hover:bg-neutral-800/50 transition-colors"
            >
              <div>
                <h4 className="font-semibold">{lec.title}</h4>
                <p className="text-sm text-neutral-400">
                  {new Date(lec.createdAt).toLocaleString()} • {lec._count.subtopics}{' '}
                  subtopics
                </p>
              </div>
              <Link
                href={`/learn/${lec.id}`}
                className="text-sm font-medium text-white hover:underline"
              >
                Open
              </Link>
            </div>
          ))}
        </div>
      </section>
    </div>
  );
}
</file>

<file path="postcss.config.mjs">
/** Tailwind CSS v4 with official PostCSS plugin */
export default {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #0a0a0a;
  --foreground: #ededed;
}

body {
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.container-narrow {
  @apply mx-auto max-w-5xl px-4 md:px-6;
}

/* BEGIN markdown-typography (Tailwind v4 safe) */
.markdown {
  color: rgb(229 229 229); /* neutral-200 */
  line-height: 1.75;
}
.markdown h2 {
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid rgb(38 38 38); /* neutral-800 */
  padding-bottom: 0.5rem;
  font-size: 1.5rem;
  font-weight: 700;
}
.markdown h3 {
  margin-top: 2rem;
  margin-bottom: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
}
.markdown p,
.markdown ul,
.markdown ol,
.markdown pre {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.markdown code {
  color: rgb(103 232 249); /* cyan-300 */
}
.markdown pre {
  background: rgba(38, 38, 38, 0.5);
  border: 1px solid rgb(38 38 38);
  border-radius: 0.5rem;
  padding: 1rem;
  overflow-x: auto;
}
.markdown ul {
  list-style: disc;
  padding-left: 1.25rem;
}
.markdown ol {
  list-style: decimal;
  padding-left: 1.25rem;
}
.markdown li::marker {
  color: rgb(115 115 115); /* neutral-500 */
}
/* END markdown-typography (Tailwind v4 safe) */

/* BEGIN markdown-typography (Tailwind v4 safe) */
.markdown {
  color: rgb(229 229 229);
  line-height: 1.75;
}
.markdown h2 {
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid rgb(38 38 38);
  padding-bottom: 0.5rem;
  font-size: 1.5rem;
  font-weight: 700;
}
.markdown h3 {
  margin-top: 2rem;
  margin-bottom: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
}
.markdown p,
.markdown ul,
.markdown ol,
.markdown pre {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.markdown code {
  color: rgb(103 232 249);
}
.markdown pre {
  background: rgba(38, 38, 38, 0.5);
  border: 1px solid rgb(38, 38, 38);
  border-radius: 0.5rem;
  padding: 1rem;
  overflow-x: auto;
}
.markdown ul {
  list-style: disc;
  padding-left: 1.25rem;
}
.markdown ol {
  list-style: decimal;
  padding-left: 1.25rem;
}
.markdown li::marker {
  color: rgb(115, 115, 115);
}
/* END markdown-typography (Tailwind v4 safe) */

/* BEGIN markdown-typography (Tailwind v4 safe) */
.markdown {
  color: rgb(229 229 229);
  line-height: 1.75;
}
.markdown h2 {
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid rgb(38 38 38);
  padding-bottom: 0.5rem;
  font-size: 1.5rem;
  font-weight: 700;
}
.markdown h3 {
  margin-top: 2rem;
  margin-bottom: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
}
.markdown p,
.markdown ul,
.markdown ol,
.markdown pre {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.markdown code {
  color: rgb(103 232 249);
}
.markdown pre {
  background: rgba(38, 38, 38, 0.5);
  border: 1px solid rgb(38, 38, 38);
  border-radius: 0.5rem;
  padding: 1rem;
  overflow-x: auto;
}
.markdown ul {
  list-style: disc;
  padding-left: 1.25rem;
}
.markdown ol {
  list-style: decimal;
  padding-left: 1.25rem;
}
.markdown li::marker {
  color: rgb(115, 115, 115);
}
/* END markdown-typography (Tailwind v4 safe) */

/* BEGIN markdown-typography (Tailwind v4 safe) */
.markdown {
  color: rgb(229 229 229);
  line-height: 1.75;
}
.markdown h2 {
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid rgb(38 38 38);
  padding-bottom: 0.5rem;
  font-size: 1.5rem;
  font-weight: 700;
}
.markdown h3 {
  margin-top: 2rem;
  margin-bottom: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
}
.markdown p,
.markdown ul,
.markdown ol,
.markdown pre {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.markdown code {
  color: rgb(103 232 249);
}
.markdown pre {
  background: rgba(38, 38, 38, 0.5);
  border: 1px solid rgb(38, 38, 38);
  border-radius: 0.5rem;
  padding: 1rem;
  overflow-x: auto;
}
.markdown ul {
  list-style: disc;
  padding-left: 1.25rem;
}
.markdown ol {
  list-style: decimal;
  padding-left: 1.25rem;
}
.markdown li::marker {
  color: rgb(115, 115, 115);
}
/* END markdown-typography (Tailwind v4 safe) */

/* BEGIN markdown-typography (Tailwind v4 safe) */
.markdown {
  color: rgb(229 229 229);
  line-height: 1.75;
}
.markdown h2 {
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid rgb(38 38 38);
  padding-bottom: 0.5rem;
  font-size: 1.5rem;
  font-weight: 700;
}
.markdown h3 {
  margin-top: 2rem;
  margin-bottom: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
}
.markdown p,
.markdown ul,
.markdown ol,
.markdown pre {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.markdown code {
  color: rgb(103 232 249);
}
.markdown pre {
  background: rgba(38, 38, 38, 0.5);
  border: 1px solid rgb(38, 38, 38);
  border-radius: 0.5rem;
  padding: 1rem;
  overflow-x: auto;
}
.markdown ul {
  list-style: disc;
  padding-left: 1.25rem;
}
.markdown ol {
  list-style: decimal;
  padding-left: 1.25rem;
}
.markdown li::marker {
  color: rgb(115, 115, 115);
}
/* END markdown-typography (Tailwind v4 safe) */
</file>

<file path="src/app/api/explain/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateText } from '@/lib/ai';

export type ExplanationStyle = 'default' | 'simplified' | 'detailed' | 'example';

export async function POST(req: NextRequest) {
  try {
    const { content, subtopicTitle, style = 'default' } = await req.json() as { content: string, subtopicTitle: string, style?: ExplanationStyle };

    if (!content || !subtopicTitle) {
      return NextResponse.json({ error: 'Content or a subtopic title is required.' }, { status: 400 });
    }

    let styleInstruction = '';
    switch (style) {
      case 'simplified':
        styleInstruction = 'Explain it in very simple terms, as if for a first-year student.';
        break;
      case 'detailed':
        styleInstruction = 'Provide a more detailed, in-depth explanation suitable for a post-graduate student, covering nuances and complexities.';
        break;
      case 'example':
        styleInstruction = 'Focus on providing a concrete, real-world example of the concept in action. Keep the theory brief and emphasize the practical application.';
        break;
      default:
        styleInstruction = 'Provide a clear and comprehensive explanation suitable for a university undergraduate.';
        break;
    }

    const prompt = `
      You are a University Professor creating a study guide. Your task is to explain the concept of "${subtopicTitle}".

      **CRITICAL INSTRUCTIONS:**
      1.  **DO NOT WRITE A PREAMBLE OR INTRODUCTION.** Your response must begin *directly* with the main Markdown heading (e.g., "### Introduction to xv6"). Do not include any conversational filler.
      2.  **Prioritize Concepts:** Your primary goal is to explain the underlying computer science concepts. Use code snippets only as supporting examples.
      3.  **Explain the "Why":** Do not just describe what a piece of code is. Explain *why* it exists and the problem it solves.
      4.  **University-Level Depth:** The explanation must be detailed and conceptually rich.
      5.  **Formatting:** Use clean Markdown with paragraphs, headings (\`###\`, \`####\`), lists, and code blocks (\`\`\`c).

      ---
      **EXAMPLE OF GOOD VS. BAD EXPLANATION:**

      **BAD (Shallow):**
      \`uint64 kstack;\` // Virtual address of kernel stack

      **GOOD (Deep, University-Level):**
      #### Kernel Stack (\`kstack\`)
      Each process has a private **kernel stack**, whose address is stored in \`kstack\`. This is separate from the process's user stack. When a process makes a system call or an interrupt occurs, the CPU switches from user mode to kernel mode. At this point, it needs a secure place to execute kernel code and save the user registers—this is what the kernel stack is for. This separation is a critical security boundary, preventing user code from interfering with the kernel's operation.
      ---

      Now, using the full lecture text below for context, generate a deep, university-level explanation for "${subtopicTitle}".

      **LECTURE TEXT:**
      ${content}
    `;

    const markdownExplanation = await generateText(prompt);

    return NextResponse.json({ explanation: markdownExplanation });

  } catch (error: any) {
    console.error("Error in explain API:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from 'next';
import ClientBoundary from '@/components/ClientBoundary';
import AuthProvider from '@/components/AuthProvider';
import Link from 'next/link';
import './globals.css';

export const metadata: Metadata = {
  title: 'LearnMax — Your AI Study Companion',
  description: 'Master any subject by breaking complex lectures into focused steps, reviewing key insights, and advancing only when you master each concept.',
};

const navLinks = [
  { href: '/', label: 'Home' },
  { href: '/dashboard', label: 'Dashboard' },
  { href: '/learn', label: 'Learn' },
];

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className="min-h-screen bg-neutral-950 text-neutral-100 antialiased">
        <AuthProvider>
        <header className="py-8 border-b border-neutral-900">
          <div className="container-narrow flex items-center justify-between">
            <Link href="/" className="text-2xl font-semibold tracking-tight hover:text-white transition-colors">
              LearnMax
            </Link>
            <nav className="flex items-center gap-4 text-sm text-neutral-300">
              {navLinks.map((link, index) => (
                <Link key={index} href={link.href} className="hover:text-white transition-colors">
                  {link.label}
                </Link>
              ))}
            </nav>
            <ClientBoundary/>
          </div>
        </header>
        <main className="py-10">{children}</main>
        <footer className="py-12 text-center text-sm text-neutral-500">
          Built with Next.js, Tailwind CSS, and Google Gemini.
        </footer>
              </AuthProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
'use client';

import Link from 'next/link';
import { BrainCircuit, Target, FileSearch } from 'lucide-react';

const PillarCard = ({
  icon: Icon,
  title,
  children,
}: {
  icon: React.ElementType;
  title: string;
  children: React.ReactNode;
}) => (
  <div className="flex flex-col text-left gap-3 p-5 rounded-lg border border-neutral-800 bg-neutral-900/50 h-full">
    <div className="flex items-center gap-3">
      <div className="flex-shrink-0 flex h-9 w-9 items-center justify-center rounded-md bg-neutral-700/50 text-white">
        <Icon className="w-5 h-5" />
      </div>
      <h3 className="text-md font-semibold">{title}</h3>
    </div>
    <p className="text-sm text-neutral-400 leading-relaxed">
      {children}
    </p>
  </div>
);

export default function HomePage() {
  return (
    <div className="container-narrow">
      <div className="flex flex-col items-center justify-center text-center h-[calc(100vh-180px)] max-w-6xl mx-auto">
        <div className="w-full">
          <h1 className="text-4xl md:text-5xl font-bold tracking-tight text-transparent bg-clip-text bg-gradient-to-br from-white to-neutral-300">
            The Science of Learning, Perfected by AI.
          </h1>
          <p className="mt-4 max-w-3xl mx-auto text-base md:text-lg text-neutral-300">
            Stop wasting hours on inefficient rereading. LearnMax applies proven cognitive science to build a hyper-efficient study path, ensuring you master every concept with minimal time and effort.
          </p>
          <div className="mt-8 flex items-center justify-center gap-3">
    <Link
      href="/learn"
      className="inline-flex items-center gap-3 rounded-md bg-white px-6 py-3 text-base text-black font-semibold shadow-lg transition-transform hover:scale-105"
    >
      Optimize Your First Lecture
    </Link>
   
  </div>
        </div>
        <div className="w-full mt-12">
          <div className="grid gap-5 md:grid-cols-3">
            <PillarCard icon={FileSearch} title="AI Deconstruction">
              Our models find the optimal learning path through dense material, so you study the right concepts in the right order.
            </PillarCard>
            <PillarCard icon={BrainCircuit} title="Guided Mastery Learning">
              Based on proven science, you focus on one core idea at a time. This prevents cognitive overload and embeds knowledge effectively.
            </PillarCard>
            <PillarCard icon={Target} title="Verified Comprehension">
              Pass a targeted quiz to prove you've mastered the concept. This guarantees a rock-solid foundation for lasting knowledge.
            </PillarCard>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/lib/ai.ts">
import { GoogleGenerativeAI } from '@google/generative-ai';

const apiKey = process.env.GOOGLE_API_KEY;

if (!apiKey) {
  throw new Error("GOOGLE_API_KEY is not set. Please add it to your .env.local file.");
}

// Client for the Flash model - for speed, cost-effectiveness, and JSON tasks
const flashAI = new GoogleGenerativeAI(apiKey);

// Client for the Pro model - for highest quality text generation
const proAI = new GoogleGenerativeAI(apiKey);

/**
 * Generates a JSON object using the 'gemini-2.0-flash' model.
 * This is the best model for high-volume, low-latency, structured output tasks.
 */
export async function generateJSON(prompt: string): Promise<any> {
  const model = flashAI.getGenerativeModel({
    model: 'gemini-2.0-flash',
    generationConfig: {
      responseMimeType: 'application/json',
    },
  });

  try {
    const result = await model.generateContent(prompt);
    const responseText = result.response?.text();
    if (!responseText) {
      throw new Error("The AI returned an empty response.");
    }
    // A simple heuristic to find the JSON object in the response string.
    const startIndex = responseText.indexOf('{');
    const endIndex = responseText.lastIndexOf('}');
    if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
      return JSON.parse(responseText.substring(startIndex, endIndex + 1));
    }
    return JSON.parse(responseText);
  } catch (e: any) {
    console.error("Failed to get valid JSON from AI response:", e.message);
    throw new Error("The AI failed to generate a valid JSON response. Please try again.");
  }
}

/**
 * Generates plain text using the 'gemini-2.0-flash' model.
 * This is the most powerful model for generating high-quality, accurate,
 * and coherent educational content.
 */
export async function generateText(prompt: string): Promise<string> {
    const model = proAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
  
    try {
      const result = await model.generateContent(prompt);
      const responseText = result.response?.text();
      if (!responseText) {
        throw new Error("The AI returned an empty response.");
      }
      return responseText;
    } catch (e: any) {
      console.error("Failed to generate text from AI response:", e.message);
      throw new Error("The AI failed to generate a valid text response. Please try again.");
    }
}
</file>

<file path="package.json">
{
  "name": "learnmax",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@auth/prisma-adapter": "^2.10.0",
    "@google/generative-ai": "^0.24.1",
    "@prisma/client": "^6.13.0",
    "lucide-react": "^0.536.0",
    "next": "15.4.5",
    "next-auth": "^4.24.11",
    "pdf-extraction": "^1.0.2",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-markdown": "^10.1.0",
    "remark-gfm": "^4.0.1",
    "zustand": "^5.0.7"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4.1.11",
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.4.5",
    "prettier": "^3.6.2",
    "prettier-plugin-tailwindcss": "^0.6.14",
    "prisma": "^6.13.0",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="src/app/learn/page.tsx">
// 'use client' makes this a valid client component with a default export.
'use client';

import { useState } from 'react';

async function createLectureFromText(
  content: string
): Promise<{ lectureId: string }> {
  const res = await fetch('/api/lectures', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content }),
  });
  if (!res.ok) {
    const e = await res.json().catch(() => ({}));
    throw new Error(e.error || `Failed: ${res.status}`);
  }
  return res.json();
}

export default function LearnWorkspacePage() {
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  const handleCreate = async () => {
    const text = input.trim();
    if (!text || loading) return;
    setLoading(true);
    setErr(null);
    try {
      const { lectureId } = await createLectureFromText(text);
      window.location.href = `/learn/${lectureId}`;
    } catch (e: any) {
      setErr(e.message || 'Failed to create lecture.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container-narrow space-y-6">
      <header>
        <h1 className="text-2xl font-bold tracking-tight">Learn Workspace</h1>
        <p className="text-sm text-neutral-400">
          Paste text and create a persistent lecture. You’ll be redirected to
          the lecture page with explanations and quizzes.
        </p>
      </header>

      <div className="space-y-4 rounded-lg border border-neutral-800 p-4">
        <textarea
          className="min-h-[160px] w-full rounded-md bg-neutral-900 p-3 ring-1 ring-neutral-700 outline-none"
          placeholder="What do you want to learn about? Paste any study notes or PDF lecture slides here"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          disabled={loading}
        />
        <div className="flex gap-2">
          <button
            onClick={handleCreate}
            disabled={loading || !input.trim()}
            className="rounded-md bg-white px-4 py-2 font-medium text-black disabled:opacity-50"
          >
            {loading ? 'Creating…' : 'Create Lecture'}
          </button>
          <button
            onClick={() => setInput('')}
            disabled={loading}
            className="rounded-md border border-neutral-700 px-4 py-2 text-neutral-200 disabled:opacity-50"
          >
            Reset
          </button>
        </div>
        {err && (
          <div className="text-sm text-red-400" role="alert">
            {err}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

</files>
