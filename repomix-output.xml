This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
prisma/
  migrations/
    20250807100731_init/
      migration.sql
    migration_lock.toml
  schema.prisma
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
scripts/
  test-explain.sh
  update-ai.sh
src/
  app/
    api/
      auth/
        [...nextauth]/
          route.ts
      breakdown/
        route.ts
      chat/
        route.ts
      explain-db/
        route.ts
      lectures/
        [lectureId]/
          route.ts
        route.ts
      mastery/
        route.ts
      quiz/
        route.ts
      upload-pdf/
        route.ts
      whoami/
        route.ts
    dashboard/
      page.tsx
    learn/
      [lectureId]/
        complete/
          page.tsx
        page.tsx
      page.tsx
    globals.css
    layout.tsx
    page.tsx
  components/
    AuthProvider.tsx
    ChatPanel.tsx
    ClientBoundary.tsx
    ContentGate.tsx
    LearnView.tsx
    SignInOut.tsx
  hooks/
    useBodyScrollLock.ts
  lib/
    client/
      learn-ui-store.ts
      lectures.ts
      rename-lecture.ts
    shared/
      learn-types.ts
    ai.ts
    auth.ts
    prisma.ts
    session-utils.ts
  types/
    next-auth.d.ts
    pdf-extraction.d.ts
    session.d.ts
types/
  pdf-extraction.d.ts
.gitignore
.prettierignore
.prettierrc.json
eslint.config.mjs
next.config.ts
package.json
PHASE5_NOTES.md
pnpm-workspace.yaml
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/migrations/20250807100731_init/migration.sql">
-- CreateTable
CREATE TABLE "public"."Account" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "provider" TEXT NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "refresh_token" TEXT,
    "access_token" TEXT,
    "expires_at" INTEGER,
    "token_type" TEXT,
    "scope" TEXT,
    "id_token" TEXT,
    "session_state" TEXT,

    CONSTRAINT "Account_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Session" (
    "id" TEXT NOT NULL,
    "sessionToken" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Session_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."VerificationToken" (
    "identifier" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL
);

-- CreateTable
CREATE TABLE "public"."User" (
    "id" TEXT NOT NULL,
    "name" TEXT,
    "email" TEXT,
    "emailVerified" TIMESTAMP(3),
    "image" TEXT,
    "elo" INTEGER NOT NULL DEFAULT 1000,
    "streak" INTEGER NOT NULL DEFAULT 0,
    "lastStudiedAt" TIMESTAMP(3),

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Lecture" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "originalContent" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Lecture_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Subtopic" (
    "id" TEXT NOT NULL,
    "order" INTEGER NOT NULL,
    "title" TEXT NOT NULL,
    "importance" TEXT NOT NULL,
    "difficulty" INTEGER NOT NULL,
    "overview" TEXT NOT NULL,
    "explanation" TEXT,
    "lectureId" TEXT NOT NULL,

    CONSTRAINT "Subtopic_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."QuizQuestion" (
    "id" TEXT NOT NULL,
    "prompt" TEXT NOT NULL,
    "options" JSONB NOT NULL,
    "answerIndex" INTEGER NOT NULL,
    "explanation" TEXT NOT NULL,
    "subtopicId" TEXT NOT NULL,

    CONSTRAINT "QuizQuestion_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."UserMastery" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "subtopicId" TEXT NOT NULL,

    CONSTRAINT "UserMastery_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Account_provider_providerAccountId_key" ON "public"."Account"("provider", "providerAccountId");

-- CreateIndex
CREATE UNIQUE INDEX "Session_sessionToken_key" ON "public"."Session"("sessionToken");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_token_key" ON "public"."VerificationToken"("token");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_identifier_token_key" ON "public"."VerificationToken"("identifier", "token");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "public"."User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Subtopic_lectureId_order_key" ON "public"."Subtopic"("lectureId", "order");

-- CreateIndex
CREATE UNIQUE INDEX "UserMastery_userId_subtopicId_key" ON "public"."UserMastery"("userId", "subtopicId");
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="prisma/schema.prisma">
// Schema generated by setup script from the migration plan.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("POSTGRES_URL")
  directUrl         = env("POSTGRES_URL_NON_POOLING")
  shadowDatabaseUrl = env("POSTGRES_SHADOW_URL")
  relationMode      = "prisma"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id                String        @id @default(cuid())
  name              String?
  email             String?       @unique
  emailVerified     DateTime?
  image             String?
  elo               Int           @default(1000)
  streak            Int           @default(0)
  lastStudiedAt     DateTime?
  accounts          Account[]
  sessions          Session[]
  lectures          Lecture[]
  masteredSubtopics UserMastery[]
}

model Lecture {
  id              String   @id @default(cuid())
  title           String
  originalContent String   @db.Text
  createdAt       DateTime @default(now())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  subtopics       Subtopic[]
}

model Subtopic {
  id          String         @id @default(cuid())
  order       Int
  title       String
  importance  String
  difficulty  Int
  overview    String
  explanation String?        @db.Text
  lectureId   String
  lecture     Lecture        @relation(fields: [lectureId], references: [id], onDelete: Cascade)
  questions   QuizQuestion[]
  masteredBy  UserMastery[]

  @@unique([lectureId, order])
}

model QuizQuestion {
  id          String   @id @default(cuid())
  prompt      String
  options     Json
  answerIndex Int
  explanation String
  subtopicId  String
  subtopic    Subtopic @relation(fields: [subtopicId], references: [id], onDelete: Cascade)
}

model UserMastery {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  subtopicId String
  subtopic   Subtopic @relation(fields: [subtopicId], references: [id], onDelete: Cascade)

  @@unique([userId, subtopicId])
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="scripts/test-explain.sh">
#!/usr/bin/env bash
set -euo pipefail
url="${1:-http://localhost:3000/api/explain-db}"
title="${2:-Trees}"
sub="${3:-Introduction}"
curl -sS -X POST "$url" -H 'Content-Type: application/json' \
  --data "{\"lectureTitle\":\"$title\",\"subtopic\":\"$sub\"}" | jq .
</file>

<file path="scripts/update-ai.sh">
#!/usr/bin/env bash
# Update src/lib/ai.ts to resilient Gemini 2.5 helpers and remove *.bak files.
# Usage: ./scripts/update-ai.sh

set -euo pipefail

TARGET="src/lib/ai.ts"
TMP="$(mktemp -t ai.ts.XXXXXX)"

echo "🔄 Writing new AI helpers to temp file…"

cat > "$TMP" <<'TS'
// src/lib/ai.ts
import { GoogleGenerativeAI } from '@google/generative-ai';

const apiKey = process.env.GOOGLE_API_KEY;
if (!apiKey) throw new Error('GOOGLE_API_KEY is not set. Add it to .env.local.');

const client = new GoogleGenerativeAI(apiKey);

/** Simple JSON parse try */
function tryParseJson(s: string): any | null { try { return JSON.parse(s); } catch { return null; } }
/** Grab ```json ... ``` */
function extractFromCodeFence(text: string): string | null {
  const m = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
  return m ? m[1].trim() : null;
}
/** First balanced {...} */
function extractFirstJSONObject(text: string): string | null {
  let depth = 0, start = -1, inString = false, esc = false;
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (inString) {
      if (esc) { esc = false; continue; }
      if (ch === '\\') { esc = true; continue; }
      if (ch === '"') { inString = false; }
      continue;
    }
    if (ch === '"') { inString = true; continue; }
    if (ch === '{') { if (depth === 0) start = i; depth++; continue; }
    if (ch === '}') { if (depth > 0 && --depth === 0 && start >= 0) return text.slice(start, i + 1); }
  }
  return null;
}

/** Treat “not found/unsupported/unavailable” as availability so we keep falling back */
function isModelAvailabilityError(err: any): boolean {
  const msg = String(err?.message || err || '').toLowerCase();
  return (
    msg.includes('404') ||
    msg.includes('not found') ||
    msg.includes('not supported') ||
    msg.includes('unavailable')
  );
}

/** Resilient JSON generation with empty-response fallback + model cascade */
export async function generateJSON(prompt: string): Promise<any> {
  const modelNames = ['gemini-2.5-flash', 'gemini-2.5-flash-lite', 'gemini-2.0-flash'];
  let lastErr: any;

  for (const name of modelNames) {
    try {
      const model = client.getGenerativeModel({
        model: name,
        generationConfig: { responseMimeType: 'application/json' },
      });

      const result = await model.generateContent(prompt);

      // Prefer response.text()
      const text = result.response?.text?.();
      if (text && text.trim()) {
        const direct = tryParseJson(text);
        if (direct !== null) return direct;

        const fenced = extractFromCodeFence(text);
        if (fenced) {
          const parsedFenced = tryParseJson(fenced);
          if (parsedFenced !== null) return parsedFenced;
        }

        const firstObj = extractFirstJSONObject(text);
        if (firstObj) {
          const parsedBalanced = tryParseJson(firstObj);
          if (parsedBalanced !== null) return parsedBalanced;
        }
      }

      // Fallback: scan candidate parts
      const parts: string[] = [];
      const candidates = (result.response as any)?.candidates ?? [];
      for (const c of candidates) {
        const p = c?.content?.parts ?? [];
        for (const part of p) if (typeof part?.text === 'string' && part.text.trim()) parts.push(part.text.trim());
      }
      for (const p of parts) {
        const direct = tryParseJson(p); if (direct !== null) return direct;
        const fenced = extractFromCodeFence(p); if (fenced) {
          const parsedFenced = tryParseJson(fenced); if (parsedFenced !== null) return parsedFenced;
        }
        const firstObj = extractFirstJSONObject(p); if (firstObj) {
          const parsedBalanced = tryParseJson(firstObj); if (parsedBalanced !== null) return parsedBalanced;
        }
      }

      // Nothing usable — continue to next model
      lastErr = new Error(\`Empty/invalid JSON from \${name}\`);
      continue;
    } catch (e) {
      if (isModelAvailabilityError(e)) { lastErr = e; continue; }
      lastErr = e;
      continue;
    }
  }

  throw new Error('The AI failed to generate a valid JSON response. ' + (lastErr?.message || ''));
}

/** Resilient text generation with empty-response fallback + model cascade */
export async function generateText(prompt: string): Promise<string> {
  const modelNames = ['gemini-2.5-pro', 'gemini-2.5-flash', 'gemini-2.5-flash-lite', 'gemini-2.0-flash'];
  let lastErr: any;

  for (const name of modelNames) {
    try {
      const model = client.getGenerativeModel({ model: name });
      const result = await model.generateContent(prompt);

      // Prefer response.text()
      const text = result.response?.text?.();
      if (text && text.trim()) return text;

      // Fallback: scan candidate parts
      const parts: string[] = [];
      const candidates = (result.response as any)?.candidates ?? [];
      for (const c of candidates) {
        const p = c?.content?.parts ?? [];
        for (const part of p) if (typeof part?.text === 'string' && part.text.trim()) parts.push(part.text.trim());
      }
      if (parts.length) return parts.join('\n\n');

      // No content — try next model
      lastErr = new Error(\`Empty response from \${name}\`);
      continue;
    } catch (e) {
      if (isModelAvailabilityError(e)) { lastErr = e; continue; }
      lastErr = e;
      continue;
    }
  }

  throw new Error('The AI failed to generate a text response. ' + (lastErr?.message || ''));
}
TS

# Ensure target dir exists
mkdir -p "$(dirname "$TARGET")"

# Atomic replace
echo "📦 Installing to $TARGET"
mv "$TMP" "$TARGET"

# Remove backups
echo "🧹 Removing .bak* files…"
find . -type f \( -name '*.bak' -o -name '*.bak-*' -o -name '*.bak2' -o -name '*.bak.*' \) -print -delete || true

echo "✅ Done."
</file>

<file path="src/app/api/breakdown/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateJSON } from '@/lib/ai';
⋮----
export async function POST(req: NextRequest)
⋮----
// A detailed prompt for generating a topic breakdown.
</file>

<file path="src/app/api/chat/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateText } from '@/lib/ai';
⋮----
export async function POST(req: NextRequest)
</file>

<file path="src/app/api/upload-pdf/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import pdf from 'pdf-extraction';
⋮----
// Set the runtime to Node.js for server-side operations.
⋮----
// Increase the timeout to handle large PDF files.
⋮----
export async function POST(req: NextRequest)
⋮----
// Convert the uploaded file's data into a Node.js Buffer.
⋮----
// Use the 'pdf-extraction' library to get text from the buffer.
⋮----
// The extracted text is in data.text.
⋮----
{ status: 422 } // Unprocessable Entity
⋮----
// Log the full error on the server for easier debugging.
</file>

<file path="src/app/api/whoami/route.ts">
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
⋮----
export async function GET()
</file>

<file path="src/app/learn/[lectureId]/complete/page.tsx">
import Link from "next/link";
⋮----
export default function CompletePage()
</file>

<file path="src/components/AuthProvider.tsx">
import { SessionProvider } from 'next-auth/react';
⋮----
export default function AuthProvider({
  children,
}: {
  children: React.ReactNode;
})
</file>

<file path="src/components/ClientBoundary.tsx">
import SignInOut from '@/components/SignInOut';
⋮----
export default function ClientBoundary()
</file>

<file path="src/components/ContentGate.tsx">
// src/components/ContentGate.tsx
⋮----
import { useEffect } from 'react';
⋮----
export default function ContentGate()
⋮----
const markQuizContainer = () =>
⋮----
const updateStateFromLesson = () =>
</file>

<file path="src/hooks/useBodyScrollLock.ts">
import { useEffect } from 'react';
⋮----
export default function useBodyScrollLock(active: boolean)
</file>

<file path="src/lib/client/learn-ui-store.ts">
import { create } from 'zustand';
⋮----
type UIState = {
  currentIndex: number;
  unlockedIndex: number;
  setCurrentIndex: (i: number) => void;
  setUnlockedIndex: (i: number) => void;
};
⋮----
export const createLearnUIStore = (initial: {
  currentIndex: number;
  unlockedIndex: number;
})
</file>

<file path="src/lib/client/rename-lecture.ts">
export async function renameLecture(lectureId: string, title: string)
</file>

<file path="src/lib/shared/learn-types.ts">
export type QuizQuestion = {
  id: string;
  prompt: string;
  options: string[];
  answerIndex: number;
  explanation: string;
};
⋮----
export type LearnSubtopic = {
  id: string;
  order: number;
  title: string;
  importance: string;
  difficulty: number;
  overview: string;
  explanation: string;
  mastered: boolean;
  questions: QuizQuestion[];
};
⋮----
export type LearnLecture = {
  id: string;
  title: string;
  originalContent: string;
  subtopics: LearnSubtopic[];
};
⋮----
export function deriveUnlockedIndex(subtopics: LearnSubtopic[]): number
⋮----
// Highest mastered index + 1 (at least 0)
</file>

<file path="src/lib/prisma.ts">
import { PrismaClient } from '@prisma/client';
⋮----
// log: ['query'], // enable for debugging
</file>

<file path="src/lib/session-utils.ts">
import type { SessionWithUser } from '@/types/session';
⋮----
export function isSessionWithUser(session: any): session is SessionWithUser
</file>

<file path="src/types/next-auth.d.ts">
// src/types/next-auth.d.ts
import { DefaultSession } from 'next-auth';
⋮----
interface Session {
    user: {
      id: string;
    } & DefaultSession['user'];
  }
⋮----
interface User {
    id: string;
  }
⋮----
interface JWT {
    id?: string;
    // `sub` is already in JWT, but we keep it in mind for the session mapping
    sub?: string;
  }
⋮----
// `sub` is already in JWT, but we keep it in mind for the session mapping
</file>

<file path="src/types/pdf-extraction.d.ts">
export interface PdfExtractionResult {
    text?: string;
    [key: string]: unknown;
  }
⋮----
// Accept common binary inputs you pass in
type Input = Buffer | ArrayBuffer | Uint8Array;
</file>

<file path="src/types/session.d.ts">
export type SessionWithUser = {
  user: {
    id: string;
    name?: string | null;
    email?: string | null;
    image?: string | null;
  };
};
</file>

<file path="types/pdf-extraction.d.ts">
export interface PdfExtractionResult {
    text?: string;
    [key: string]: unknown;
  }
type Input = Buffer | ArrayBuffer | Uint8Array;
</file>

<file path=".prettierignore">
.next
node_modules
build
dist
coverage
.env*
</file>

<file path=".prettierrc.json">
{
  "printWidth": 80,
  "singleQuote": true,
  "semi": true,
  "trailingComma": "es5",
  "tabWidth": 2,
  "plugins": ["prettier-plugin-tailwindcss"]
}
</file>

<file path="eslint.config.mjs">
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
⋮----
const compat = new FlatCompat({
⋮----
...compat.extends("next/core-web-vitals", "next/typescript"),
</file>

<file path="PHASE5_NOTES.md">
Phase 5 — Persistent-first state

What changed:
- Client-side LearnView now derives unlockedIndex from mastered subtopics returned by the server.
- UI-only state (currentIndex, unlockedIndex) lives in a tiny Zustand store created per page mount.
- On quiz pass, the client calls /api/mastery to persist mastery, then locally unlocks the next subtopic.

What you can remove/stop using:
- src/lib/learn-store.ts (old in-memory topic/subtopic/quiz store driving the entire Learn flow)
- src/lib/store.ts for global "progress" numbers; use real values from DB on server pages instead.

Next steps to complete removal:
1) Remove imports/usages of useLearnStore and useProgressStore from client components.
2) On the Dashboard, read stats from DB directly (already implemented in Phase 4 server page).
3) If you still need per-session UI (like toasts, toggles), create tiny local Zustand stores colocated with those components.

Optional enhancements:
- Refetch lecture data after mastery to reflect new mastered state from DB (SWR/React Query) or navigate refresh.
- Add optimistic UI badge "Mastered" on subtopic list after pass.
</file>

<file path="pnpm-workspace.yaml">
onlyBuiltDependencies:
  - '@prisma/client'
  - '@prisma/engines'
  - '@tailwindcss/oxide'
  - prisma
  - sharp
  - unrs-resolver
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';
</file>

<file path="src/app/api/mastery/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { requireSession } from '@/lib/auth';
import { isSessionWithUser } from '@/lib/session-utils';
⋮----
export async function POST(req: NextRequest)
</file>

<file path="src/components/SignInOut.tsx">
import { useSession, signIn, signOut } from 'next-auth/react';
import Link from 'next/link';
</file>

<file path="src/lib/client/lectures.ts">
export async function createLectureFromText(
  content: string
): Promise<
⋮----
export async function createLectureFromPdf(
  file: File
): Promise<
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
.env*.local

/src/generated/prisma
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";
⋮----
/* config options here */
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss'
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    "**/*.d.ts",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="src/app/api/explain-db/route.ts">
// src/app/api/explain-db/route.ts
import { NextResponse } from 'next/server';
import { generateText, PRIMARY_MODEL } from '@/lib/ai';
⋮----
const log = (...a: any[]) =>
const err = (...a: any[]) =>
⋮----
function stripPreamble(md: string): string
⋮----
out = out.replace(/^# .+\n+/m, ''); // drop leading H1 if any
⋮----
export async function POST(req: Request)
⋮----
// Return both keys so callers can pick either.
</file>

<file path="src/components/ChatPanel.tsx">
import { useState, useRef, useEffect } from 'react';
import { Send, Loader2, User, Bot } from 'lucide-react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
⋮----
// Normalize to avoid whole-message fenced blocks.
function sanitizeMd(md: string): string
⋮----
type Message = {
  sender: 'user' | 'ai';
  text: string;
};
⋮----
type ChatPanelProps = {
  documentContent: string;
};
⋮----
async function postJSON<T>(url: string, body: any): Promise<T>
⋮----
const handleSendMessage = async () =>
</file>

<file path="postcss.config.mjs">
/** Tailwind CSS v4 with official PostCSS plugin */
</file>

<file path="src/app/dashboard/page.tsx">
import Link from 'next/link';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { redirect } from 'next/navigation';
import { BookOpen, Target, BrainCircuit, Flame } from 'lucide-react';
import { isSessionWithUser } from '@/lib/session-utils';
⋮----
function StatCard({
  icon: Icon,
  label,
  value,
  color,
}: {
  icon: React.ElementType;
  label: string;
  value: string | number;
  color: string;
})
⋮----
async function getData()
⋮----
masteredSubtopics: true, // ensure this relation is loaded
⋮----
type LectureItem = typeof lectures[number];
</file>

<file path="src/lib/auth.ts">
// src/lib/auth.ts
import type { NextAuthOptions } from 'next-auth';
import { getServerSession } from 'next-auth';
import GoogleProvider from 'next-auth/providers/google';
import { PrismaAdapter } from '@auth/prisma-adapter';
import prisma from '@/lib/prisma';
⋮----
clientId: process.env.GOOGLE_CLIENT_ID!,       // or GOOGLE_CLIENT_ID
clientSecret: process.env.GOOGLE_CLIENT_SECRET! // or GOOGLE_CLIENT_SECRET
⋮----
session: { strategy: 'jwt' }, // keep JWT sessions; adapter still persists User/Account
secret: process.env.NEXTAUTH_SECRET,       // REQUIRED in production
⋮----
async jwt(
async session(
⋮----
// pages: { signIn: '/api/auth/signin' }, // optional; default built-in page is fine
⋮----
export async function requireSession()
</file>

<file path="README.md">
# LearnMax 🧠✨

**The Science of Learning, Perfected by AI.**

LearnMax is a full-stack web application built with Next.js that revolutionizes studying. Stop wasting hours on inefficient rereading. LearnMax applies proven cognitive science principles, powered by the Google Gemini API, to deconstruct complex materials, generate focused learning modules, and verify your understanding every step of the way.

 <img width="1470" height="787" alt="image" src="https://github.com/user-attachments/assets/7a9cf5ec-03a4-4bb6-a700-34deed0735b1" />
<img width="1470" height="789" alt="image" src="https://github.com/user-attachments/assets/5af0e37a-c1bb-4262-bf60-757bd4c7cfcc" />
<img width="725" height="575" alt="image" src="https://github.com/user-attachments/assets/8b784b6d-8fa2-4a49-a4d8-12aec793ef46" />



---

## 🚀 About The Project

This application is designed to create a hyper-efficient study path from any text-based content, like lecture notes or PDF slides. It breaks down the material, explains each part, and quizzes you to ensure you've mastered the concept before moving on.

### Core Features

*   **📚 AI Content Deconstruction**: Upload a PDF or paste raw text. The AI analyzes the material and structures it into a logical learning path of subtopics, ordered by importance and difficulty.
*   **💡 Guided Mastery Learning**: Tackle one core concept at a time. The app provides AI-generated explanations in various styles (simplified, detailed, or with examples) to prevent cognitive overload and embed knowledge effectively.
*   **🎯 Verified Comprehension**: Before advancing, pass a targeted, AI-generated quiz to prove you've mastered the current concept. This guarantees a rock-solid foundation for lasting knowledge.
*   **💬 Interactive AI Tutor**: Have a question? An AI tutor is available in a side panel, ready to answer questions about the source material or related general knowledge topics.
*   **📊 Personalized Dashboard**: Keep track of your learning journey. View stats like your total lectures, mastered subtopics, and even a "Learning Elo" score that reflects your progress.
*   **🔐 Secure Authentication**: User accounts and sessions are securely managed using NextAuth.js with Google as an OAuth provider.

---

## 🛠️ Built With

This project leverages a modern, powerful tech stack:

*   **Framework**: [Next.js](https://nextjs.org/) (v15) with App Router
*   **Language**: [TypeScript](https://www.typescriptlang.org/)
*   **AI**: [Google Gemini API](https://ai.google.dev/)
*   **Database**: [PostgreSQL](https://www.postgresql.org/)
*   **ORM**: [Prisma](https://www.prisma.io/)
*   **Authentication**: [NextAuth.js](https://next-auth.js.org/)
*   **Styling**: [Tailwind CSS](https://tailwindcss.com/)
*   **Client-side State**: [Zustand](https://github.com/pmndrs/zustand)
*   **Icons**: [Lucide React](https://lucide.dev/)

---

## 🏁 Getting Started

To get a local copy up and running, follow these simple steps.

### Prerequisites

*   **Node.js**: v20.x or higher
*   **pnpm**: `npm install -g pnpm`
*   **PostgreSQL**: A running instance of PostgreSQL.

### Installation & Setup

1.  **Clone the repository:**
    ```sh
    git clone https://github.com/your-username/learnmax.git
    cd learnmax
    ```

2.  **Install dependencies:**
    ```sh
    pnpm install
    ```

3.  **Set up environment variables:**
    Create a `.env.local` file in the root of your project and add the following variables.

    ```env
    # Google AI API Key (for Gemini)
    GOOGLE_API_KEY="your_google_api_key"

    # PostgreSQL Connection URLs (get from your provider)
    # Used by Prisma for migrations and the app
    POSTGRES_URL="postgresql://user:password@host:port/database"
    # Direct connection for Prisma Migrate/Studio
    POSTGRES_URL_NON_POOLING="postgresql://user:password@host:port/database"
    # Shadow database for development migrations
    POSTGRES_SHADOW_URL="postgresql://user:password@host:port/database_shadow"

    # NextAuth.js Configuration
    # Generate a secret with: openssl rand -base64 32
    NEXTAUTH_SECRET="your_nextauth_secret"
    # Google OAuth credentials
    GOOGLE_CLIENT_ID="your_google_client_id"
    GOOGLE_CLIENT_SECRET="your_google_client_secret"
    ```

4.  **Run database migrations:**
    This will sync the Prisma schema with your PostgreSQL database.
    ```sh
    pnpm prisma migrate dev
    ```

5.  **Run the development server:**
    ```sh
    pnpm dev
    ```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result!

---

## 📁 Project Structure

The codebase is organized to be clean and maintainable:

*   `prisma/`: Contains the database `schema.prisma` and migration files.
*   `public/`: Static assets like images and SVGs.
*   `src/app/`: The core of the Next.js application, using the App Router.
    *   `(pages)/`: Main routes like `/`, `/dashboard`, and `/learn`.
    *   `api/`: All backend API endpoints, organized by resource.
*   `src/components/`: Shared, reusable React components used across the application.
*   `src/lib/`: Essential logic and utilities.
    *   `ai.ts`: Functions for interacting with the Google Gemini API.
    *   `auth.ts`: NextAuth.js configuration.
    *   `prisma.ts`: Prisma client instance.
    *   `client/`: Client-side specific helpers and state stores (Zustand).
*   `src/types/`: TypeScript type definitions.

---

## License

Distributed under the MIT License. See `LICENSE` for more information.
</file>

<file path="src/app/api/lectures/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import pdf from 'pdf-extraction';
import prisma from '@/lib/prisma';
import { requireSession } from '@/lib/auth';
import { generateJSON } from '@/lib/ai';
import { isSessionWithUser } from '@/lib/session-utils';
⋮----
type TransactionClient = Parameters<Parameters<typeof prisma.$transaction>[0]>[0];
⋮----
type BreakdownSubtopic = {
  title: string;
  importance: string;   // 'high' | 'medium' | 'low'
  difficulty: number;   // 1..3
  overview?: string;
};
⋮----
importance: string;   // 'high' | 'medium' | 'low'
difficulty: number;   // 1..3
⋮----
type Breakdown = {
  topic: string;
  subtopics: BreakdownSubtopic[];
};
⋮----
type QuizQuestion = {
  prompt: string;
  options: string[];
  answerIndex: number;
  explanation: string;
  subtopicTitle?: string;
};
type QuizOut = { questions: QuizQuestion[] };
⋮----
// --- Helpers: shape guards & fallbacks --------------------------------------
⋮----
function normImportance(v: unknown): 'high'|'medium'|'low'
function clampDifficulty(v: unknown): 1|2|3
function clip(s: string, max = 240): string
⋮----
function sanitizeBreakdown(raw: any, text: string): Breakdown
⋮----
// Fallback: at least one subtopic
⋮----
function isGoodQuestion(q: any): q is QuizQuestion
⋮----
function fallbackQuestions(subtopics: BreakdownSubtopic[]): QuizQuestion[]
⋮----
// Cheap, deterministic questions that still tie to the breakdown.
// One per subtopic.
⋮----
function sanitizeQuiz(raw: any, subtopics: BreakdownSubtopic[]): QuizOut
⋮----
// --- Route -------------------------------------------------------------------
⋮----
export async function POST(req: NextRequest)
⋮----
// 1) Breakdown (robust)
⋮----
// 2) Quiz (robust)
⋮----
// 3) Persist
</file>

<file path="src/app/api/quiz/route.ts">
// src/app/api/quiz/route.ts
import { NextResponse } from 'next/server';
import { generateJSON } from '@/lib/ai';
⋮----
type RawQ = {
  question?: string;
  prompt?: string;
  options?: unknown;
  answerIndex?: unknown;
  explain?: string;
  explanation?: string;
};
⋮----
type CleanQ = {
  prompt: string;
  options: string[];
  answerIndex: number;
  explanation: string;
};
⋮----
function toClean(q: RawQ): CleanQ | null
⋮----
/* ------------------------ Grounding helpers ------------------------ */
⋮----
function words(s: string): string[]
function keywords(s: string, max = 12): string[]
⋮----
function containsNgramQuote(explanation: string, lesson: string, n = 4): boolean
⋮----
// normalized, punctuation-free comparison
⋮----
function overlapCount(text: string, kws: string[]): number
⋮----
function isGrounded(q: CleanQ, lessonMd: string, kws: string[]): boolean
⋮----
const hasKw = overlapCount(text, kws) >= Math.min(2, kws.length); // at least 2 keywords
⋮----
/* Deterministic fallback: builds a grounded T/F MCQ from the lesson text */
function pickDeclarativeSentence(md: string): string | null
⋮----
// Split on sentence-ish boundaries and pick something medium length
⋮----
function fallbackFromLesson(lessonMd: string): CleanQ
⋮----
/* ------------------------------ Route ------------------------------ */
⋮----
export async function POST(req: Request)
⋮----
// First attempt
⋮----
// Retry if nothing passed audit
⋮----
// Final fallback — guaranteed grounded
⋮----
// Keep just one good question
</file>

<file path="src/app/learn/[lectureId]/page.tsx">
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { redirect, notFound } from 'next/navigation';
import { isSessionWithUser } from '@/lib/session-utils';
import LearnView from '@/components/LearnView';
⋮----
export default async function LearnPage(
</file>

<file path="src/app/globals.css">
:root {
⋮----
body {
⋮----
.container-narrow {
⋮----
/* BEGIN markdown-typography (Tailwind v4 safe) */
.markdown {
⋮----
color: rgb(229 229 229); /* neutral-200 */
⋮----
.markdown h2 {
⋮----
border-bottom: 1px solid rgb(38 38 38); /* neutral-800 */
⋮----
.markdown h3 {
.markdown p,
.markdown code {
⋮----
color: rgb(103 232 249); /* cyan-300 */
⋮----
.markdown pre {
.markdown ul {
.markdown ol {
.markdown li::marker {
⋮----
color: rgb(115 115 115); /* neutral-500 */
⋮----
/* END markdown-typography (Tailwind v4 safe) */
⋮----
/* Wider container for Learn page */
.container-wide {
⋮----
/* learnmax-quiz-gate */
⋮----
/* learnmax-quiz-gate (fixed) */
body:not([data-content="ready"]) .quiz-panel { display: none; }
⋮----
/* quiz gate */
⋮----
body[data-content="ready"] .quiz-panel { display: block; }
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from 'next';
import ContentGate from "@/components/ContentGate";
import ClientBoundary from '@/components/ClientBoundary';
import AuthProvider from '@/components/AuthProvider';
import Link from 'next/link';
</file>

<file path="src/app/api/lectures/[lectureId]/route.ts">
import { isSessionWithUser } from '@/lib/session-utils';
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
⋮----
type Params = { lectureId: string };
⋮----
export async function PATCH(req: NextRequest, ctx: unknown)
</file>

<file path="src/app/page.tsx">
import Link from 'next/link';
import { BrainCircuit, Target, FileSearch } from 'lucide-react';
⋮----
const PillarCard = ({
  icon: Icon,
  title,
  children,
}: {
  icon: React.ElementType;
  title: string;
  children: React.ReactNode;
}) => (
  <div className="flex flex-col text-left gap-3 p-5 rounded-lg border border-neutral-800 bg-neutral-900/50 h-full">
    <div className="flex items-center gap-3">
      <div className="flex-shrink-0 flex h-9 w-9 items-center justify-center rounded-md bg-neutral-700/50 text-white">
        <Icon className="w-5 h-5" />
      </div>
      <h3 className="text-md font-semibold">{title}</h3>
    </div>
    <p className="text-sm text-neutral-400 leading-relaxed">
      {children}
    </p>
  </div>
);
</file>

<file path="src/app/learn/page.tsx">
// 'use client' makes this a valid client component with a default export.
⋮----
import { useState } from 'react';
⋮----
async function createLectureFromText(
  content: string
): Promise<
⋮----
const handleCreate = async () =>
</file>

<file path="src/components/LearnView.tsx">
import { useRouter } from 'next/navigation';
import { useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type QuizQuestion,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';
import { renameLecture } from '@/lib/client/rename-lecture';
import useBodyScrollLock from '@/hooks/useBodyScrollLock';
⋮----
/** Normalize model output so it never renders as one giant code block. */
function sanitizeMarkdown(md: string): string
⋮----
// 1) Unwrap a single full-document fenced block (```md / ```markdown / ``` / any)
⋮----
// 2) If every non-empty line starts with >=4 spaces or a tab, de-indent once (was treated as code)
⋮----
// 3) If there is a stray unmatched ``` fence, strip it.
⋮----
// UI-only store per page mount
⋮----
// Scroll to top of main panel on subtopic change
⋮----
const scrollToMainTop = () =>
⋮----
// Title editing
⋮----
// Explanations cache (sanitized)
⋮----
// Progress state (green progress bar in left sidebar)
⋮----
// NEW: track which subtopics are already counted to avoid double-increment
⋮----
const canSelect = (i: number)
⋮----
// Keep unlockedIndex sane if server state changes
⋮----
// eslint-disable-next-line react-hooks/exhaustive-deps
⋮----
// Our API expects lectureTitle + subtopic and returns { markdown }
⋮----
// On subtopic change: fetch explanation once and scroll to top
⋮----
// eslint-disable-next-line react-hooks/exhaustive-deps
⋮----
const handleRename = async () =>
⋮----
{/* Left: Outline */}
⋮----
{/* Progress bar */}
⋮----
{/* Bar + non-clipped glow */}
⋮----
{/* Center: Explanation + Quiz */}
⋮----
onPassed=
⋮----
/* END-OF-LECTURE */
⋮----
// Persist mastery for this subtopic
⋮----
// Let the bar finish animating, then go to completion screen
⋮----
// Optimistic advance
⋮----
// Persist mastery (duplicate call tolerated)
⋮----
{/* Right: AI Tutor */}
⋮----
/* ------------------------------ QuizPanel --------------------------------- */
⋮----
const stripABCD = (str: string)
⋮----
// Reset when subtopic questions change
⋮----
const setAns = (qIndex: number, ansIndex: number) =>
⋮----
const check = ()
const tryAgain = ()
⋮----
// Once lesson content exists, fetch a harder question that uses it.
⋮----
// Keep seed question if API fails
⋮----
const askAnother = async () =>
⋮----
// Fallback: rotate options of the first question
</file>

<file path="package.json">
{
  "name": "learnmax",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --no-lint",
    "start": "next start",
    "lint": "next lint",
    "postinstall": "prisma generate"
  },
  "dependencies": {
    "@auth/prisma-adapter": "^2.10.0",
    "@google/generative-ai": "^0.24.1",
    "@prisma/client": "^6.13.0",
    "lucide-react": "^0.536.0",
    "next": "15.4.5",
    "next-auth": "^4.24.11",
    "pdf-extraction": "^1.0.2",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-markdown": "^10.1.0",
    "remark-gfm": "^4.0.1",
    "zustand": "^5.0.7"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4.1.11",
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.4.5",
    "prettier": "^3.6.2",
    "prettier-plugin-tailwindcss": "^0.6.14",
    "prisma": "^6.13.0",
    "tailwindcss": "^4",
    "typescript": "^5"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "@prisma/client",
      "@prisma/engines",
      "prisma"
    ]
  }
}
</file>

<file path="src/lib/ai.ts">
// src/lib/ai.ts
import { GoogleGenerativeAI } from '@google/generative-ai';
⋮----
function tryParseJson(s: string): any | null
⋮----
function extractFromCodeFence(text: string): string | null
⋮----
function extractFirstJSONObject(text: string): string | null
⋮----
const log = (...a: any[]) =>
⋮----
export async function generateText(prompt: string): Promise<string>
⋮----
export async function generateJSON(prompt: string): Promise<any>
</file>

</files>
