This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
prisma/
  migrations/
    20250807100731_init/
      migration.sql
    20250808080640_add_lecture_user_starred_created_idx/
      migration.sql
    20250808120000_add_starred_to_lecture/
      migration.sql
    20250808150000_add_profile_and_quiz_attempts/
      migration.sql
    migration_lock.toml
  manual_add_rank.sql
  schema.prisma
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
scripts/
  test-explain.sh
  update-ai.sh
src/
  app/
    admin/
      ranks/
        Client.tsx
        page.tsx
      page.tsx
    api/
      admin/
        ranks/
          seed/
            route.ts
      auth/
        [...nextauth]/
          route.ts
      blob/
        upload-url/
          route.ts
      breakdown/
        route.ts
      chat/
        route.ts
      explain-db/
        route.ts
      lectures/
        [lectureId]/
          route.ts
        stream/
          route.ts
        vision/
          route.ts
        route.ts
      mastery/
        route.ts
      quiz/
        attempt/
          route.ts
        questions/
          route.ts
        route.ts
      ranks/
        route.ts
      upload-pdf/
        route.ts
      users/
        [username]/
          route.ts
        me/
          route.ts
      whoami/
        route.ts
    dashboard/
      page.tsx
    learn/
      [lectureId]/
        complete/
          page.tsx
        page.tsx
      page.tsx
    profile/
      page.tsx
    globals.css
    layout.tsx
    page.tsx
  components/
    AuthProvider.tsx
    ChatPanel.tsx
    ClientBoundary.tsx
    ContentGate.tsx
    DeleteLectureButton.tsx
    LearnView.tsx
    LectureList.tsx
    ModelSelector.tsx
    SignInOut.tsx
  hooks/
    useBodyScrollLock.ts
  lib/
    client/
      learn-ui-store.ts
      lectures.ts
      rename-lecture.ts
    shared/
      learn-types.ts
    admin.ts
    ai.ts
    auth.ts
    cached.ts
    prisma.ts
    session-utils.ts
    streak.ts
  types/
    next-auth.d.ts
    session.d.ts
types/
  pdf-extraction.d.ts
.gitignore
.prettierignore
.prettierrc.json
eslint.config.mjs
next.config.ts
package.json
PHASE5_NOTES.md
pnpm-workspace.yaml
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/migrations/20250807100731_init/migration.sql">
-- CreateTable
CREATE TABLE "public"."Account" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "provider" TEXT NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "refresh_token" TEXT,
    "access_token" TEXT,
    "expires_at" INTEGER,
    "token_type" TEXT,
    "scope" TEXT,
    "id_token" TEXT,
    "session_state" TEXT,

    CONSTRAINT "Account_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Session" (
    "id" TEXT NOT NULL,
    "sessionToken" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Session_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."VerificationToken" (
    "identifier" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL
);

-- CreateTable
CREATE TABLE "public"."User" (
    "id" TEXT NOT NULL,
    "name" TEXT,
    "email" TEXT,
    "emailVerified" TIMESTAMP(3),
    "image" TEXT,
    "elo" INTEGER NOT NULL DEFAULT 1000,
    "streak" INTEGER NOT NULL DEFAULT 0,
    "lastStudiedAt" TIMESTAMP(3),

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Lecture" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "originalContent" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Lecture_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Subtopic" (
    "id" TEXT NOT NULL,
    "order" INTEGER NOT NULL,
    "title" TEXT NOT NULL,
    "importance" TEXT NOT NULL,
    "difficulty" INTEGER NOT NULL,
    "overview" TEXT NOT NULL,
    "explanation" TEXT,
    "lectureId" TEXT NOT NULL,

    CONSTRAINT "Subtopic_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."QuizQuestion" (
    "id" TEXT NOT NULL,
    "prompt" TEXT NOT NULL,
    "options" JSONB NOT NULL,
    "answerIndex" INTEGER NOT NULL,
    "explanation" TEXT NOT NULL,
    "subtopicId" TEXT NOT NULL,

    CONSTRAINT "QuizQuestion_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."UserMastery" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "subtopicId" TEXT NOT NULL,

    CONSTRAINT "UserMastery_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Account_provider_providerAccountId_key" ON "public"."Account"("provider", "providerAccountId");

-- CreateIndex
CREATE UNIQUE INDEX "Session_sessionToken_key" ON "public"."Session"("sessionToken");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_token_key" ON "public"."VerificationToken"("token");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_identifier_token_key" ON "public"."VerificationToken"("identifier", "token");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "public"."User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Subtopic_lectureId_order_key" ON "public"."Subtopic"("lectureId", "order");

-- CreateIndex
CREATE UNIQUE INDEX "UserMastery_userId_subtopicId_key" ON "public"."UserMastery"("userId", "subtopicId");
</file>

<file path="prisma/migrations/20250808150000_add_profile_and_quiz_attempts/migration.sql">
-- Add optional profile fields
ALTER TABLE "public"."User" ADD COLUMN IF NOT EXISTS "username" TEXT;
ALTER TABLE "public"."User" ADD COLUMN IF NOT EXISTS "bio" TEXT;

DO $$ BEGIN
  IF NOT EXISTS (
      SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'User_username_key'
  ) THEN
    CREATE UNIQUE INDEX "User_username_key" ON "public"."User"("username");
  END IF;
END $$;

-- Add QuizAttempt table
CREATE TABLE IF NOT EXISTS "public"."QuizAttempt" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "questionId" TEXT NOT NULL,
    "selectedIndex" INTEGER NOT NULL,
    "isCorrect" BOOLEAN NOT NULL,
    CONSTRAINT "QuizAttempt_pkey" PRIMARY KEY ("id")
);

-- FKs
DO $$ BEGIN
  ALTER TABLE "public"."QuizAttempt"
    ADD CONSTRAINT "QuizAttempt_userId_fkey" FOREIGN KEY ("userId") REFERENCES "public"."User"("id") ON DELETE CASCADE;
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  ALTER TABLE "public"."QuizAttempt"
    ADD CONSTRAINT "QuizAttempt_questionId_fkey" FOREIGN KEY ("questionId") REFERENCES "public"."QuizQuestion"("id") ON DELETE CASCADE;
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

-- Indexes
CREATE INDEX IF NOT EXISTS "QuizAttempt_userId_createdAt_idx" ON "public"."QuizAttempt"("userId", "createdAt");
CREATE INDEX IF NOT EXISTS "QuizAttempt_userId_isCorrect_createdAt_idx" ON "public"."QuizAttempt"("userId", "isCorrect", "createdAt");
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="prisma/manual_add_rank.sql">
-- Create Rank table if it doesn't exist (manual fix)
CREATE TABLE IF NOT EXISTS "Rank" (
  "slug" TEXT PRIMARY KEY,
  "name" TEXT NOT NULL,
  "minElo" INTEGER NOT NULL,
  "iconUrl" TEXT
);
CREATE UNIQUE INDEX IF NOT EXISTS "Rank_minElo_key" ON "Rank" ("minElo");
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="scripts/test-explain.sh">
#!/usr/bin/env bash
set -euo pipefail
url="${1:-http://localhost:3000/api/explain-db}"
title="${2:-Trees}"
sub="${3:-Introduction}"
curl -sS -X POST "$url" -H 'Content-Type: application/json' \
  --data "{\"lectureTitle\":\"$title\",\"subtopic\":\"$sub\"}" | jq .
</file>

<file path="scripts/update-ai.sh">
#!/usr/bin/env bash
# Update src/lib/ai.ts to resilient Gemini 2.5 helpers and remove *.bak files.
# Usage: ./scripts/update-ai.sh

set -euo pipefail

TARGET="src/lib/ai.ts"
TMP="$(mktemp -t ai.ts.XXXXXX)"

echo "🔄 Writing new AI helpers to temp file…"

cat > "$TMP" <<'TS'
// src/lib/ai.ts
import { GoogleGenerativeAI } from '@google/generative-ai';

const apiKey = process.env.GOOGLE_API_KEY;
if (!apiKey) throw new Error('GOOGLE_API_KEY is not set. Add it to .env.local.');

const client = new GoogleGenerativeAI(apiKey);

/** Simple JSON parse try */
function tryParseJson(s: string): any | null { try { return JSON.parse(s); } catch { return null; } }
/** Grab ```json ... ``` */
function extractFromCodeFence(text: string): string | null {
  const m = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
  return m ? m[1].trim() : null;
}
/** First balanced {...} */
function extractFirstJSONObject(text: string): string | null {
  let depth = 0, start = -1, inString = false, esc = false;
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (inString) {
      if (esc) { esc = false; continue; }
      if (ch === '\\') { esc = true; continue; }
      if (ch === '"') { inString = false; }
      continue;
    }
    if (ch === '"') { inString = true; continue; }
    if (ch === '{') { if (depth === 0) start = i; depth++; continue; }
    if (ch === '}') { if (depth > 0 && --depth === 0 && start >= 0) return text.slice(start, i + 1); }
  }
  return null;
}

/** Treat “not found/unsupported/unavailable” as availability so we keep falling back */
function isModelAvailabilityError(err: any): boolean {
  const msg = String(err?.message || err || '').toLowerCase();
  return (
    msg.includes('404') ||
    msg.includes('not found') ||
    msg.includes('not supported') ||
    msg.includes('unavailable')
  );
}

/** Resilient JSON generation with empty-response fallback + model cascade */
export async function generateJSON(prompt: string): Promise<any> {
  const modelNames = ['gemini-2.5-flash', 'gemini-2.5-flash-lite', 'gemini-2.0-flash'];
  let lastErr: any;

  for (const name of modelNames) {
    try {
      const model = client.getGenerativeModel({
        model: name,
        generationConfig: { responseMimeType: 'application/json' },
      });

      const result = await model.generateContent(prompt);

      // Prefer response.text()
      const text = result.response?.text?.();
      if (text && text.trim()) {
        const direct = tryParseJson(text);
        if (direct !== null) return direct;

        const fenced = extractFromCodeFence(text);
        if (fenced) {
          const parsedFenced = tryParseJson(fenced);
          if (parsedFenced !== null) return parsedFenced;
        }

        const firstObj = extractFirstJSONObject(text);
        if (firstObj) {
          const parsedBalanced = tryParseJson(firstObj);
          if (parsedBalanced !== null) return parsedBalanced;
        }
      }

      // Fallback: scan candidate parts
      const parts: string[] = [];
      const candidates = (result.response as any)?.candidates ?? [];
      for (const c of candidates) {
        const p = c?.content?.parts ?? [];
        for (const part of p) if (typeof part?.text === 'string' && part.text.trim()) parts.push(part.text.trim());
      }
      for (const p of parts) {
        const direct = tryParseJson(p); if (direct !== null) return direct;
        const fenced = extractFromCodeFence(p); if (fenced) {
          const parsedFenced = tryParseJson(fenced); if (parsedFenced !== null) return parsedFenced;
        }
        const firstObj = extractFirstJSONObject(p); if (firstObj) {
          const parsedBalanced = tryParseJson(firstObj); if (parsedBalanced !== null) return parsedBalanced;
        }
      }

      // Nothing usable — continue to next model
      lastErr = new Error(\`Empty/invalid JSON from \${name}\`);
      continue;
    } catch (e) {
      if (isModelAvailabilityError(e)) { lastErr = e; continue; }
      lastErr = e;
      continue;
    }
  }

  throw new Error('The AI failed to generate a valid JSON response. ' + (lastErr?.message || ''));
}

/** Resilient text generation with empty-response fallback + model cascade */
export async function generateText(prompt: string): Promise<string> {
  const modelNames = ['gemini-2.5-pro', 'gemini-2.5-flash', 'gemini-2.5-flash-lite', 'gemini-2.0-flash'];
  let lastErr: any;

  for (const name of modelNames) {
    try {
      const model = client.getGenerativeModel({ model: name });
      const result = await model.generateContent(prompt);

      // Prefer response.text()
      const text = result.response?.text?.();
      if (text && text.trim()) return text;

      // Fallback: scan candidate parts
      const parts: string[] = [];
      const candidates = (result.response as any)?.candidates ?? [];
      for (const c of candidates) {
        const p = c?.content?.parts ?? [];
        for (const part of p) if (typeof part?.text === 'string' && part.text.trim()) parts.push(part.text.trim());
      }
      if (parts.length) return parts.join('\n\n');

      // No content — try next model
      lastErr = new Error(\`Empty response from \${name}\`);
      continue;
    } catch (e) {
      if (isModelAvailabilityError(e)) { lastErr = e; continue; }
      lastErr = e;
      continue;
    }
  }

  throw new Error('The AI failed to generate a text response. ' + (lastErr?.message || ''));
}
TS

# Ensure target dir exists
mkdir -p "$(dirname "$TARGET")"

# Atomic replace
echo "📦 Installing to $TARGET"
mv "$TMP" "$TARGET"

# Remove backups
echo "🧹 Removing .bak* files…"
find . -type f \( -name '*.bak' -o -name '*.bak-*' -o -name '*.bak2' -o -name '*.bak.*' \) -print -delete || true

echo "✅ Done."
</file>

<file path="src/app/admin/page.tsx">
import { requireAdmin } from '@/lib/admin';
import Link from 'next/link';

export default async function AdminHomePage() {
    await requireAdmin();
    return (
        <div className="container-narrow space-y-6">
            <h1 className="text-3xl font-bold tracking-tight">Admin Panel</h1>
            <div className="card p-6 space-y-3">
                <p className="text-neutral-400">Manage site assets and settings.</p>
                <div className="flex flex-wrap gap-3">
                    <Link href="/admin/ranks" className="btn-primary px-4 py-2">Rank Icons</Link>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="src/app/api/admin/ranks/seed/route.ts">
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { requireAdmin } from '@/lib/admin';

export async function POST() {
    await requireAdmin();
    const defaults = [
        { slug: 'bronze', name: 'Bronze', minElo: 1000 },
        { slug: 'silver', name: 'Silver', minElo: 1200 },
        { slug: 'gold', name: 'Gold', minElo: 1400 },
        { slug: 'diamond', name: 'Diamond', minElo: 1600 },
        { slug: 'master', name: 'Master', minElo: 1800 },
    ];
    for (const r of defaults) {
        await prisma.rank.upsert({
            where: { slug: r.slug },
            update: { name: r.name, minElo: r.minElo },
            create: r,
        });
    }
    return NextResponse.json({ ok: true });
}
</file>

<file path="src/app/api/quiz/questions/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { isSessionWithUser } from '@/lib/session-utils';

type IncomingQuestion = {
  prompt: string;
  options: string[];
  answerIndex: number;
  explanation: string;
};

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!isSessionWithUser(session)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    const body = (await req.json().catch(() => ({}))) as {
      subtopicId?: string;
      questions?: IncomingQuestion[];
    };
    const subtopicId = String(body?.subtopicId || '').trim();
    const questions = Array.isArray(body?.questions) ? body.questions : [];
    if (!subtopicId) {
      return NextResponse.json({ error: 'subtopicId is required' }, { status: 400 });
    }

    // Ensure ownership: subtopic belongs to a lecture owned by the current user
    const subtopic = await prisma.subtopic.findFirst({
      where: { id: subtopicId, lecture: { userId } },
      select: { id: true },
    });
    if (!subtopic) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 });
    }

    // Fetch existing questions for this subtopic
    const existing = await prisma.quizQuestion.findMany({
      where: { subtopicId },
      select: { id: true, prompt: true, options: true, answerIndex: true, explanation: true },
    });

    // Cap at two questions per subtopic for now (to match UI expectation)
    const REQUIRED = 2;
    if (existing.length >= REQUIRED) {
      return NextResponse.json({
        questions: existing.map((q) => ({
          id: q.id,
          prompt: q.prompt,
          options: q.options as unknown as string[],
          answerIndex: q.answerIndex,
          explanation: q.explanation,
        })),
      });
    }

    // Validate incoming payload; only take what we need to fill up to REQUIRED
    const toInsert: IncomingQuestion[] = [];
    for (const q of questions) {
      const ok =
        q &&
        typeof q.prompt === 'string' && q.prompt.trim() &&
        Array.isArray(q.options) && q.options.length === 4 &&
        typeof q.answerIndex === 'number' && q.answerIndex >= 0 && q.answerIndex < 4 &&
        typeof q.explanation === 'string';
      if (ok) toInsert.push({
        prompt: q.prompt.trim(),
        options: q.options.map((o) => String(o)),
        answerIndex: q.answerIndex,
        explanation: q.explanation,
      });
      if (existing.length + toInsert.length >= REQUIRED) break;
    }

    // Create individually so we can return IDs
    for (const q of toInsert) {
      await prisma.quizQuestion.create({
        data: {
          prompt: q.prompt,
          options: q.options as unknown as any,
          answerIndex: q.answerIndex,
          explanation: q.explanation,
          subtopicId,
        },
      });
    }

    const final = await prisma.quizQuestion.findMany({
      where: { subtopicId },
      select: { id: true, prompt: true, options: true, answerIndex: true, explanation: true },
    });
    return NextResponse.json({
      questions: final.map((q) => ({
        id: q.id,
        prompt: q.prompt,
        options: q.options as unknown as string[],
        answerIndex: q.answerIndex,
        explanation: q.explanation,
      })),
    });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: 500 });
  }
}
</file>

<file path="src/app/api/ranks/route.ts">
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { requireAdmin } from '@/lib/admin';

export async function GET() {
    const ranks = await prisma.rank.findMany({ orderBy: { minElo: 'asc' } });
    return NextResponse.json({ ranks });
}

export async function PATCH(req: Request) {
    await requireAdmin();
    const body = await req.json().catch(() => ({}));
    const items = Array.isArray(body?.ranks) ? (body.ranks as any[]) : [];
    for (const it of items) {
        if (!it || typeof it.slug !== 'string') continue;
        const data: any = {};
        if (typeof it.name === 'string') data.name = it.name.trim().slice(0, 40);
        if (Number.isInteger(it.minElo)) data.minElo = Math.max(0, Number(it.minElo));
        if (typeof it.iconUrl === 'string' || it.iconUrl === null) data.iconUrl = it.iconUrl ?? null;
        if (Object.keys(data).length) {
            await prisma.rank.update({ where: { slug: it.slug }, data });
        }
    }
    const ranks = await prisma.rank.findMany({ orderBy: { minElo: 'asc' } });
    return NextResponse.json({ ok: true, ranks });
}
</file>

<file path="src/app/api/upload-pdf/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import pdf from 'pdf-extraction';

// Set the runtime to Node.js for server-side operations.
export const runtime = 'nodejs';
// Increase the timeout to handle large PDF files.
export const maxDuration = 60;

export async function POST(req: NextRequest) {
  try {
    const form = await req.formData();
    const file = form.get('file');

    if (!file || !(file instanceof File)) {
      return NextResponse.json(
        { error: 'No file provided. Please upload a single PDF.' },
        { status: 400 }
      );
    }

    if (!file.name.toLowerCase().endsWith('.pdf')) {
      return NextResponse.json(
        { error: 'Invalid file type. Only PDF files are accepted.' },
        { status: 400 }
      );
    }

    // Convert the uploaded file's data into a Node.js Buffer.
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Use the 'pdf-extraction' library to get text from the buffer.
    const data = await pdf(buffer);

    // The extracted text is in data.text.
    const text = (data.text || '').replace(/\s{2,}/g, ' ').trim();

    if (!text) {
      return NextResponse.json(
        { error: 'Could not extract text from the PDF. The file may only contain images.' },
        { status: 422 } // Unprocessable Entity
      );
    }

    return NextResponse.json({
      filename: file.name,
      pages: data.numpages,
      content: text,
    });

  } catch (e: any) {
    // Log the full error on the server for easier debugging.
    console.error('UPLOAD_PDF_ERROR:', e?.stack || e?.message || e);
    const errorMessage = e.message || 'An unknown error occurred during processing.';
    return NextResponse.json({ error: `Failed to process PDF: ${errorMessage}` }, { status: 500 });
  }
}
</file>

<file path="src/app/api/whoami/route.ts">
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET() {
  const session = await getServerSession(authOptions);
  return NextResponse.json({
    ok: true,
    hasSession: !!session,
    user: session?.user ?? null,
  });
}
</file>

<file path="src/components/AuthProvider.tsx">
'use client';

import { SessionProvider } from 'next-auth/react';

export default function AuthProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  return <SessionProvider>{children}</SessionProvider>;
}
</file>

<file path="src/components/ClientBoundary.tsx">
'use client';

import SignInOut from '@/components/SignInOut';

export default function ClientBoundary() {
  return <SignInOut />;
}
</file>

<file path="src/hooks/useBodyScrollLock.ts">
import { useEffect } from 'react';

export default function useBodyScrollLock(active: boolean) {
  useEffect(() => {
    if (!active) return;
    const prevHtml = document.documentElement.style.overflow;
    const prevBody = document.body.style.overflow;

    document.documentElement.style.overflow = 'hidden';
    document.body.style.overflow = 'hidden';

    return () => {
      document.documentElement.style.overflow = prevHtml;
      document.body.style.overflow = prevBody;
    };
  }, [active]);
}
</file>

<file path="src/lib/client/learn-ui-store.ts">
import { create } from 'zustand';

type UIState = {
  currentIndex: number;
  unlockedIndex: number;
  setCurrentIndex: (i: number) => void;
  setUnlockedIndex: (i: number) => void;
};

export const createLearnUIStore = (initial: {
  currentIndex: number;
  unlockedIndex: number;
}) =>
  create<UIState>((set) => ({
    currentIndex: initial.currentIndex,
    unlockedIndex: initial.unlockedIndex,
    setCurrentIndex: (i) => set({ currentIndex: i }),
    setUnlockedIndex: (i) => set({ unlockedIndex: i }),
  }));
</file>

<file path="src/lib/shared/learn-types.ts">
export type QuizQuestion = {
  id: string;
  prompt: string;
  options: string[];
  answerIndex: number;
  explanation: string;
};

export type LearnSubtopic = {
  id: string;
  order: number;
  title: string;
  importance: string;
  difficulty: number;
  overview: string;
  explanation: string;
  mastered: boolean;
  questions: QuizQuestion[];
};

export type LearnLecture = {
  id: string;
  title: string;
  originalContent: string;
  subtopics: LearnSubtopic[];
};

export function deriveUnlockedIndex(subtopics: LearnSubtopic[]): number {
  // Highest mastered index + 1 (at least 0)
  const lastMastered = subtopics.reduce((acc, s, i) => (s.mastered ? i : acc), -1);
  return Math.min(lastMastered + 1, Math.max(0, subtopics.length - 1));
}
</file>

<file path="src/lib/admin.ts">
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export function isAdminEmail(email?: string | null): boolean {
    if (!email) return false;
    const list = (process.env.ADMIN_EMAILS || '')
        .split(',')
        .map((s) => s.trim().toLowerCase())
        .filter(Boolean);
    return list.includes(email.toLowerCase());
}

export async function requireAdmin() {
    const session = await getServerSession(authOptions);
    const email = session?.user?.email || null;
    if (!email || !isAdminEmail(email)) {
        const err = new Error('Forbidden') as Error & { status?: number };
        err.status = 403;
        throw err;
    }
    return session;
}
</file>

<file path="src/lib/prisma.ts">
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    // log: ['query'], // enable for debugging
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export default prisma;
</file>

<file path="src/lib/session-utils.ts">
import type { SessionWithUser } from '@/types/session';

export function isSessionWithUser(session: any): session is SessionWithUser {
  return !!(session?.user && typeof session.user.id === 'string');
}
</file>

<file path="src/lib/streak.ts">
import prisma from '@/lib/prisma';

function toUTCDateOnly(d: Date): { y: number; m: number; d: number } {
  return { y: d.getUTCFullYear(), m: d.getUTCMonth(), d: d.getUTCDate() };
}

function isSameUTCDay(a: Date, b: Date): boolean {
  const aa = toUTCDateOnly(a);
  const bb = toUTCDateOnly(b);
  return aa.y === bb.y && aa.m === bb.m && aa.d === bb.d;
}

function isYesterdayUTC(last: Date, now: Date): boolean {
  const prev = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() - 1));
  return isSameUTCDay(last, prev);
}

/**
 * Bump the user's daily streak if appropriate.
 * - Same UTC day: no increment; keep streak as-is, optionally update lastStudiedAt
 * - Yesterday: increment streak by 1
 * - Older: reset streak to 1
 * Always updates `lastStudiedAt` to now when incrementing/resetting.
 */
export async function bumpDailyStreak(userId: string, now: Date = new Date()): Promise<number> {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { lastStudiedAt: true, streak: true },
  });

  const last = user?.lastStudiedAt ?? null;
  const currentStreak = user?.streak ?? 0;

  if (last && isSameUTCDay(last, now)) {
    // Already counted today
    return currentStreak || 1;
  }

  let nextStreak = 1;
  if (last && isYesterdayUTC(last, now)) {
    nextStreak = Math.max(1, currentStreak + 1);
  }

  await prisma.user.update({
    where: { id: userId },
    data: { streak: nextStreak, lastStudiedAt: now },
  });

  return nextStreak;
}
</file>

<file path="src/types/next-auth.d.ts">
// src/types/next-auth.d.ts
import { DefaultSession } from 'next-auth';

declare module 'next-auth' {
  interface Session {
    user: {
      id: string;
    } & DefaultSession['user'];
  }

  interface User {
    id: string;
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    id?: string;
    // `sub` is already in JWT, but we keep it in mind for the session mapping
    sub?: string;
  }
}
</file>

<file path="src/types/session.d.ts">
export type SessionWithUser = {
  user: {
    id: string;
    name?: string | null;
    email?: string | null;
    image?: string | null;
  };
};
</file>

<file path="types/pdf-extraction.d.ts">
declare module 'pdf-extraction' {
  export interface PdfExtractionResult {
    text?: string;
    [key: string]: unknown;
  }
  type Input = Buffer | ArrayBuffer | Uint8Array;
  const pdf: (input: Input) => Promise<PdfExtractionResult>;
  export default pdf;
}
</file>

<file path=".prettierignore">
.next
node_modules
build
dist
coverage
.env*
</file>

<file path=".prettierrc.json">
{
  "printWidth": 80,
  "singleQuote": true,
  "semi": true,
  "trailingComma": "es5",
  "tabWidth": 2,
  "plugins": ["prettier-plugin-tailwindcss"]
}
</file>

<file path="PHASE5_NOTES.md">
Phase 5 — Persistent-first state

What changed:
- Client-side LearnView now derives unlockedIndex from mastered subtopics returned by the server.
- UI-only state (currentIndex, unlockedIndex) lives in a tiny Zustand store created per page mount.
- On quiz pass, the client calls /api/mastery to persist mastery, then locally unlocks the next subtopic.

What you can remove/stop using:
- src/lib/learn-store.ts (old in-memory topic/subtopic/quiz store driving the entire Learn flow)
- src/lib/store.ts for global "progress" numbers; use real values from DB on server pages instead.

Next steps to complete removal:
1) Remove imports/usages of useLearnStore and useProgressStore from client components.
2) On the Dashboard, read stats from DB directly (already implemented in Phase 4 server page).
3) If you still need per-session UI (like toasts, toggles), create tiny local Zustand stores colocated with those components.

Optional enhancements:
- Refetch lecture data after mastery to reflect new mastered state from DB (SWR/React Query) or navigate refresh.
- Add optimistic UI badge "Mastered" on subtopic list after pass.
</file>

<file path="pnpm-workspace.yaml">
onlyBuiltDependencies:
  - '@prisma/client'
  - '@prisma/engines'
  - '@tailwindcss/oxide'
  - prisma
  - sharp
  - unrs-resolver
</file>

<file path="prisma/migrations/20250808080640_add_lecture_user_starred_created_idx/migration.sql">
-- Ensure the required column exists before creating the index
ALTER TABLE "public"."Lecture" ADD COLUMN IF NOT EXISTS "starred" BOOLEAN NOT NULL DEFAULT false;

-- Create the composite index if it does not already exist
CREATE INDEX IF NOT EXISTS "Lecture_userId_starred_createdAt_idx" ON "public"."Lecture"("userId", "starred", "createdAt");
</file>

<file path="prisma/migrations/20250808120000_add_starred_to_lecture/migration.sql">
-- Safely add the column only if it does not already exist
ALTER TABLE "public"."Lecture" ADD COLUMN IF NOT EXISTS "starred" BOOLEAN NOT NULL DEFAULT false;
</file>

<file path="src/app/admin/ranks/Client.tsx">
"use client";

import { useEffect, useRef, useState } from 'react';
import { upload } from '@vercel/blob/client';

type Rank = { slug: string; name: string; minElo: number; iconUrl: string | null };

export default function RankManagerClient({ initial }: { initial: Rank[] }) {
    const [ranks, setRanks] = useState<Rank[]>(initial || []);
    const [saving, setSaving] = useState(false);
    const fileInputs = useRef<Record<string, HTMLInputElement | null>>({});

    useEffect(() => {
        // If server provided no data, fetch as a fallback (shouldn't happen)
        (async () => {
            if (!ranks?.length) {
                const res = await fetch('/api/ranks');
                if (res.ok) {
                    const data = await res.json();
                    setRanks(data.ranks || []);
                }
            }
        })();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    const onPick = async (slug: string, file: File) => {
        const pathname = `ranks/${slug}.${file.type === 'image/webp' ? 'webp' : file.type === 'image/png' ? 'png' : file.type === 'image/gif' ? 'gif' : 'jpg'}`;
        const { url } = await upload(pathname, file, {
            access: 'public',
            handleUploadUrl: '/api/blob/upload-url',
            contentType: file.type,
        });
        setRanks((prev) => prev.map((r) => (r.slug === slug ? { ...r, iconUrl: url } : r)));
    };

    const save = async () => {
        setSaving(true);
        try {
            const res = await fetch('/api/ranks', {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ranks }),
            });
            if (!res.ok) {
                const e = await res.json().catch(() => ({}));
                alert(e.error || 'Failed to save');
                return;
            }
            const data = await res.json();
            setRanks(data.ranks || ranks);
        } finally {
            setSaving(false);
        }
    };

    return (
        <div className="space-y-6">
            <div className="grid gap-4">
                {ranks.map((r) => (
                    <div key={r.slug} className="flex items-center gap-4 p-3 rounded-md border border-neutral-800">
                        {/* eslint-disable-next-line @next/next/no-img-element */}
                        <img src={r.iconUrl || '/window.svg'} alt={r.name} className="h-10 w-10 rounded bg-neutral-900 object-cover" />
                        <div className="grid gap-1 flex-1">
                            <div className="font-medium">{r.name}</div>
                            <div className="text-sm text-neutral-400">Min ELO</div>
                            <input
                                type="number"
                                className="input max-w-[160px]"
                                value={r.minElo}
                                onChange={(e) => setRanks((prev) => prev.map((x) => (x.slug === r.slug ? { ...x, minElo: Number(e.target.value) } : x)))}
                            />
                        </div>
                        <div className="flex items-center gap-2">
                            <label className="btn-ghost cursor-pointer">
                                <input
                                    type="file"
                                    accept="image/png,image/jpeg,image/webp,image/gif"
                                    className="hidden"
                                    ref={(el) => {
                                        fileInputs.current[r.slug] = el;
                                    }}
                                    onChange={(e) => e.target.files && onPick(r.slug, e.target.files[0])}
                                />
                                Change Icon
                            </label>
                        </div>
                    </div>
                ))}
            </div>
            <div>
                <button onClick={save} disabled={saving} className="btn-primary px-4 py-2">
                    {saving ? 'Saving…' : 'Save Changes'}
                </button>
            </div>
        </div>
    );
}
</file>

<file path="src/app/admin/ranks/page.tsx">
import { requireAdmin } from '@/lib/admin';
import prisma from '@/lib/prisma';
import RankManagerClient from './Client';

async function getRanks() {
    // Query DB directly to avoid server-fetching relative URLs
    const ranks = await prisma.rank.findMany({ orderBy: { minElo: 'asc' } });
    return ranks as Array<{ slug: string; name: string; minElo: number; iconUrl: string | null }>;
}

export default async function AdminRanksPage() {
    await requireAdmin();
    const ranks = await getRanks();
    return (
        <div className="container-narrow space-y-6">
            <h1 className="text-3xl font-bold tracking-tight">Rank Icons</h1>
            <p className="text-neutral-400">Edit thresholds and upload/change icons for each rank.</p>
            <div className="card p-6">
                <RankManagerClient initial={ranks} />
            </div>
        </div>
    );
}
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
</file>

<file path="src/app/api/lectures/vision/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { GoogleAIFileManager } from '@google/generative-ai/server';
import prisma from '@/lib/prisma';
import { requireSession } from '@/lib/auth';
import { isSessionWithUser } from '@/lib/session-utils';

export const runtime = 'nodejs';
export const maxDuration = 60;

export async function POST(req: NextRequest) {
  try {
    const session = await requireSession();
    if (!isSessionWithUser(session)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    const contentType = req.headers.get('content-type') || '';
    if (!contentType.includes('multipart/form-data')) {
      return NextResponse.json({ error: 'Upload a PDF via multipart/form-data' }, { status: 415 });
    }
    const form = await req.formData();
    const file = form.get('file');
    if (!file || !(file instanceof File)) {
      return NextResponse.json({ error: 'No file provided.' }, { status: 400 });
    }
    if (!file.name.toLowerCase().endsWith('.pdf')) {
      return NextResponse.json({ error: 'Invalid file type. Only PDF files are accepted.' }, { status: 400 });
    }

    const apiKey = process.env.GOOGLE_API_KEY;
    if (!apiKey) return NextResponse.json({ error: 'GOOGLE_API_KEY not set' }, { status: 500 });
    const client = new GoogleGenerativeAI(apiKey);
    const files = new GoogleAIFileManager(apiKey);

    // Upload PDF to Gemini File API
    const arrayBuffer = await file.arrayBuffer();
    const uploaded = await files.uploadFile(
      Buffer.from(arrayBuffer),
      { mimeType: 'application/pdf', displayName: file.name }
    );

    // Poll until ACTIVE
    let fileRec = uploaded.file as any;
    const tStart = Date.now();
    while (fileRec.state !== 'ACTIVE') {
      if (Date.now() - tStart > 45000) {
        return NextResponse.json({ error: 'Timed out waiting for file processing' }, { status: 504 });
      }
      await new Promise((r) => setTimeout(r, 1200));
      fileRec = await files.getFile(fileRec.name);
    }

    // Ask Gemini to analyze full PDF (text + images)
    const preferred = (form.get('model') as string | null)?.trim();
    const modelName = preferred || process.env.GEMINI_MODEL || 'gemini-2.5-flash';
    const model = client.getGenerativeModel({ model: modelName });

    const prompt = [
      'Analyze this PDF end-to-end (text and images).',
      'Return ONLY valid JSON in this exact shape (no extra prose):',
      '{ "topic": string, "subtopics": [ { "title": string, "importance": "high"|"medium"|"low", "difficulty": 1|2|3, "overview": string } ] }',
      'Generate between 8 and 15 subtopics total. Aim for about 12 on average. Never exceed 15.',
    ].join('\n');

    const res = await model.generateContent([
      { fileData: { fileUri: (fileRec as any).uri, mimeType: 'application/pdf' } },
      { text: prompt },
    ]);
    const text = res.response.text?.() || '';
    let json: any = {};
    try { json = JSON.parse(text); } catch { return NextResponse.json({ error: 'Invalid JSON from model', raw: text }, { status: 502 }); }

    // Persist minimal lecture from JSON
    const topic = typeof json?.topic === 'string' && json.topic.trim() ? json.topic.trim() : 'Generating lesson... Please Wait';
    const subs = Array.isArray(json?.subtopics) ? json.subtopics : [];
    const cappedSubs = subs.slice(0, 15);

    const lecture = await prisma.lecture.create({ data: { title: topic, originalContent: 'PDF (vision) upload', userId } });
    if (cappedSubs.length) {
      await prisma.subtopic.createMany({
        data: cappedSubs.map((s: any, idx: number) => ({
          order: idx,
          title: String(s?.title || `Section ${idx + 1}`),
          importance: String(s?.importance || 'medium'),
          difficulty: Number(s?.difficulty || 2),
          overview: String(s?.overview || ''),
          lectureId: lecture.id,
        })),
      });
    }

    return NextResponse.json({ lectureId: lecture.id });
  } catch (e: any) {
    console.error('VISION_UPLOAD_ERROR', e);
    return NextResponse.json({ error: e?.message || 'server error' }, { status: 500 });
  }
}
</file>

<file path="src/app/api/quiz/attempt/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { bumpDailyStreak } from '@/lib/streak';
import { requireSession } from '@/lib/auth';

export async function POST(req: NextRequest) {
  try {
    const session = await requireSession();
    const userId = (session.user as any)?.id as string;
    const { questionId, selectedIndex, isCorrect } = (await req.json()) as {
      questionId: string;
      selectedIndex: number;
      isCorrect: boolean;
    };
    if (!questionId || typeof selectedIndex !== 'number' || typeof isCorrect !== 'boolean') {
      return NextResponse.json({ error: 'Invalid payload' }, { status: 400 });
    }

    await prisma.quizAttempt.create({
      data: { userId, questionId, selectedIndex, isCorrect },
    });
    // Bump streak on any attempt
    await bumpDailyStreak(userId);
    return NextResponse.json({ ok: true });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: e?.status || 500 });
  }
}
</file>

<file path="src/app/api/users/[username]/route.ts">
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

export async function GET(_req: Request, context: { params: Promise<{ username: string }> }) {
  try {
    const { username } = await context.params;
    const uname = decodeURIComponent(username || '').toLowerCase();
    if (!uname) return NextResponse.json({ error: 'username required' }, { status: 400 });

    const user = await prisma.user.findFirst({
      where: { username: uname },
      select: {
        id: true,
        name: true,
        username: true,
        bio: true,
        image: true,
        elo: true,
        streak: true,
        masteredSubtopics: { select: { id: true } },
        _count: { select: { masteredSubtopics: true } },
      },
    });
    if (!user) return NextResponse.json({ error: 'Not found' }, { status: 404 });

    // Compute accuracy
    const agg = await prisma.quizAttempt.groupBy({
      by: ['isCorrect'],
      where: { userId: user.id },
      _count: { _all: true },
    });
    const total = agg.reduce((a, r) => a + r._count._all, 0);
    const correct = agg.find((r) => r.isCorrect)?._count._all || 0;
    const accuracy = total ? Math.round((correct / total) * 100) : 0;

    // Determine rank based on ELO
    const rank = await prisma.rank.findFirst({ where: { minElo: { lte: user.elo } }, orderBy: { minElo: 'desc' } });

    return NextResponse.json({
      user: {
        id: user.id,
        name: user.name,
        username: user.username,
        bio: user.bio,
        image: user.image,
        elo: user.elo,
        streak: user.streak,
        masteredCount: user._count.masteredSubtopics,
        quiz: { totalAttempts: total, correct, accuracy },
        rank: rank ? { slug: rank.slug, name: rank.name, minElo: rank.minElo, iconUrl: rank.iconUrl } : null,
      },
    });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: e?.status || 500 });
  }
}
</file>

<file path="src/app/api/users/me/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { requireSession } from '@/lib/auth';
import { isAdminEmail } from '@/lib/admin';

export async function PATCH(req: NextRequest) {
  try {
    const session = await requireSession();
    const userId = (session.user as any)?.id as string;
    const body = await req.json().catch(() => ({}));
    const data: any = {};
    if (typeof body.name === 'string') data.name = body.name.trim().slice(0, 80);
    if (typeof body.username === 'string') data.username = body.username.trim().slice(0, 40).toLowerCase();
    if (typeof body.bio === 'string') data.bio = body.bio.trim().slice(0, 280);
    if (typeof body.image === 'string') data.image = body.image.trim();

    if (Object.keys(data).length === 0) {
      return NextResponse.json({ error: 'No valid fields' }, { status: 400 });
    }

    // Ensure username unique if provided
    if (data.username) {
      const exists = await prisma.user.findFirst({ where: { username: data.username, NOT: { id: userId } }, select: { id: true } });
      if (exists) return NextResponse.json({ error: 'Username taken' }, { status: 409 });
    }

    const user = await prisma.user.update({ where: { id: userId }, data, select: { id: true, name: true, username: true, bio: true, image: true, elo: true, streak: true } });
    return NextResponse.json({ ok: true, user });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: e?.status || 500 });
  }
}

export async function GET() {
  try {
    const session = await requireSession();
    const userId = (session.user as any)?.id as string;
    let user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        name: true,
        username: true,
        bio: true,
        image: true,
        elo: true,
        streak: true,
        _count: { select: { masteredSubtopics: true } },
      },
    });
    if (!user) return NextResponse.json({ error: 'Not found' }, { status: 404 });

    // If no stored avatar, fall back to provider (e.g., Google) and persist once
    const providerImage = (session.user as any)?.image as string | undefined;
    if (!user.image && providerImage && typeof providerImage === 'string') {
      try {
        user = await prisma.user.update({
          where: { id: userId },
          data: { image: providerImage },
          select: {
            id: true,
            name: true,
            username: true,
            bio: true,
            image: true,
            elo: true,
            streak: true,
            _count: { select: { masteredSubtopics: true } },
          },
        });
      } catch {
        // non-fatal if update fails; still return a response with fallback image below
        user = { ...user, image: providerImage } as typeof user;
      }
    }
    const agg = await prisma.quizAttempt.groupBy({
      by: ['isCorrect'],
      where: { userId },
      _count: { _all: true },
    });
    const total = agg.reduce((a, r) => a + r._count._all, 0);
    const correct = agg.find((r) => r.isCorrect)?._count._all || 0;
    const accuracy = total ? Math.round((correct / total) * 100) : 0;

    // Determine rank based on ELO
    const userElo = user.elo;
    const rank = await prisma.rank.findFirst({ where: { minElo: { lte: userElo } }, orderBy: { minElo: 'desc' } });
    const isAdmin = isAdminEmail((session.user as any)?.email || null);
    return NextResponse.json({
      user: {
        id: user.id,
        name: user.name,
        username: user.username,
        bio: user.bio,
        image: user.image || providerImage || null,
        elo: user.elo,
        streak: user.streak,
        masteredCount: user._count.masteredSubtopics,
        quiz: { totalAttempts: total, correct, accuracy },
        rank: rank ? { slug: rank.slug, name: rank.name, minElo: rank.minElo, iconUrl: rank.iconUrl } : null,
        isAdmin,
      },
    });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: e?.status || 500 });
  }
}
</file>

<file path="src/components/ContentGate.tsx">
// src/components/ContentGate.tsx
'use client';
import { useEffect } from 'react';

/**
 * The CSS hides .quiz-panel unless <body data-content="ready">.
 * On some navigations/subtopic changes that flag was lost, hiding the quiz.
 * We set it once on mount and never remove it.
 */
export default function ContentGate() {
  useEffect(() => {
    try {
      document.body.setAttribute('data-content', 'ready');
    } catch {}
  }, []);
  return null;
}
</file>

<file path="src/components/DeleteLectureButton.tsx">
'use client';

import { useState, useTransition } from 'react';
import { useRouter } from 'next/navigation';
import { Trash2 } from 'lucide-react';

export default function DeleteLectureButton({
  lectureId,
  onDeleted,
}: {
  lectureId: string;
  onDeleted?: () => void;
}) {
  const router = useRouter();
  const [isPending, startTransition] = useTransition();
  const [busy, setBusy] = useState(false);

  const onDelete = async () => {
    if (busy || isPending) return;
    const ok = typeof window !== 'undefined' ? window.confirm('Delete this lecture? This cannot be undone.') : false;
    if (!ok) return;

    try {
      setBusy(true);
      // Optimistic removal: update UI immediately
      if (onDeleted) onDeleted();
      // Perform delete in background
      const res = await fetch(`/api/lectures/${lectureId}`, { method: 'DELETE' });
      if (!res.ok) {
        const data = await res.json().catch(() => ({}));
        throw new Error(data?.error || 'Failed to delete');
      }
      // If no optimistic handler, fall back to refresh
      if (!onDeleted) startTransition(() => router.refresh());
    } catch (e) {
      // eslint-disable-next-line no-alert
      alert((e as Error)?.message || 'Failed to delete');
      // Re-sync UI from server in case optimistic update removed item locally
      startTransition(() => router.refresh());
    } finally {
      setBusy(false);
    }
  };

  return (
    <button
      type="button"
      onClick={onDelete}
      disabled={busy || isPending}
      className="inline-flex items-center gap-2 rounded-md border border-red-700/50 bg-red-900/30 px-3 py-1.5 text-sm text-red-100 hover:bg-red-800/40 disabled:opacity-60"
      aria-disabled={busy || isPending}
      title="Delete lecture"
    >
      <Trash2 className="w-4 h-4" />
      Delete
    </button>
  );
}
</file>

<file path="src/components/LectureList.tsx">
'use client';

import Link from 'next/link';
import { useState } from 'react';
import { Star, StarOff, Pencil } from 'lucide-react';
import DeleteLectureButton from '@/components/DeleteLectureButton';

export type ClientLecture = {
  id: string;
  title: string;
  createdAtISO: string; // serialized for client component props
  subtopicCount: number;
  starred: boolean;
};

export default function LectureList({ initialLectures }: { initialLectures: ClientLecture[] }) {
  const [lectures, setLectures] = useState<ClientLecture[]>(initialLectures);

  return (
    <div className="mt-6 space-y-4">
      {lectures.length === 0 && (
        <div className="text-neutral-400 text-sm">No lectures yet. Create one in the Learn Workspace.</div>
      )}
      {lectures.map((lec) => (
        <div key={lec.id} className="card p-4 flex items-center justify-between hover:bg-neutral-900 transition-colors">
          <div>
            <h4 className="font-semibold">{lec.title}</h4>
            <p className="text-sm text-neutral-400">
              {new Date(lec.createdAtISO).toLocaleString()} • {lec.subtopicCount} subtopics
            </p>
          </div>
          <div className="flex items-center gap-3">
            <Link href={`/learn/${lec.id}`} className="text-sm font-medium text-white hover:underline">
              Open
            </Link>
            <button
              type="button"
              onClick={async () => {
                try {
                  const next = !lec.starred;
                  setLectures((prev) => {
                    const updated = prev.map((p) => (p.id === lec.id ? { ...p, starred: next } : p));
                    // Reorder: starred first, then by createdAt desc
                    return [...updated].sort((a, b) => (b.starred === a.starred ? 0 : b.starred ? 1 : -1));
                  });
                  const res = await fetch(`/api/lectures/${lec.id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ starred: next }),
                  });
                  if (!res.ok) {
                    throw new Error('Failed');
                  }
                } catch {
                  // Revert pessimistically by refetching state from server on next load
                }
              }}
              className={`inline-flex items-center gap-1 rounded-md border px-2 py-1 text-xs ${
                lec.starred
                  ? 'border-yellow-500/40 bg-yellow-900/20 text-yellow-200 hover:bg-yellow-900/30'
                  : 'border-neutral-700 bg-neutral-800 text-neutral-200 hover:bg-neutral-700'
              }`}
              title={lec.starred ? 'Unstar' : 'Star'}
            >
              {lec.starred ? <Star className="w-4 h-4 fill-yellow-400 text-yellow-400" /> : <StarOff className="w-4 h-4" />}
              {lec.starred ? 'Starred' : 'Star'}
            </button>
            <button
              type="button"
              onClick={async () => {
                const newTitle = typeof window !== 'undefined' ? window.prompt('Rename lecture', lec.title) : null;
                if (!newTitle) return;
                const t = newTitle.trim();
                if (t.length < 3) {
                  // eslint-disable-next-line no-alert
                  alert('Title must be at least 3 characters.');
                  return;
                }
                try {
                  setLectures((prev) => prev.map((p) => (p.id === lec.id ? { ...p, title: t } : p)));
                  const res = await fetch(`/api/lectures/${lec.id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: t }),
                  });
                  if (!res.ok) {
                    throw new Error('Failed');
                  }
                } catch (e) {
                  // eslint-disable-next-line no-alert
                  alert((e as Error)?.message || 'Failed to rename');
                }
              }}
              className="inline-flex items-center gap-1 rounded-md border border-neutral-700 bg-neutral-800 px-2 py-1 text-xs text-neutral-200 hover:bg-neutral-700"
              title="Rename"
            >
              <Pencil className="w-4 h-4" /> Rename
            </button>
            <DeleteLectureButton
              lectureId={lec.id}
              onDeleted={() => setLectures((prev) => prev.filter((l) => l.id !== lec.id))}
            />
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/components/SignInOut.tsx">
'use client';

import { useSession, signIn, signOut } from 'next-auth/react';
import Link from 'next/link';

export default function SignInOut() {
  const { data: session, status } = useSession();

  if (status === 'loading') {
    return <span className="text-sm text-neutral-400">Loading...</span>;
  }

  if (!session) {
    return (
      <button
        onClick={() => signIn('google')}
        className="rounded-md bg-white px-3 py-1.5 text-black text-sm font-medium"
      >
        Sign In
      </button>
    );
  }

  return (
    <div className="flex items-center gap-3">
   
      <button
        onClick={() => signOut()}
        className="rounded-md border border-neutral-600 px-3 py-1.5 text-sm"
      >
        Sign Out
      </button>
    </div>
  );
}
</file>

<file path="src/lib/client/rename-lecture.ts">
export async function renameLecture(lectureId: string, title: string) {
  const res = await fetch(`/api/lectures/${lectureId}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ title }),
  });
  if (!res.ok) {
    const e = await res.json().catch(() => ({}));
    throw new Error(e.error || `Failed (${res.status})`);
  }
  return res.json() as Promise<{
    ok: true;
    lecture: { id: string; title: string; starred: boolean };
  }>;
}

export async function starLecture(lectureId: string, starred: boolean) {
  const res = await fetch(`/api/lectures/${lectureId}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ starred }),
  });
  if (!res.ok) {
    const e = await res.json().catch(() => ({}));
    throw new Error(e.error || `Failed (${res.status})`);
  }
  return res.json() as Promise<{
    ok: true;
    lecture: { id: string; title: string; starred: boolean };
  }>;
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
.env*.local

/src/generated/prisma
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    rules: {
      "@typescript-eslint/no-explicit-any": "off",
    },
  },
];

export default eslintConfig;
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
      },
      borderRadius: {
        lg: `var(--radius)`,
        md: `calc(var(--radius) - 2px)`,
        sm: 'calc(var(--radius) - 4px)',
      },
    },
  },
  plugins: [
  ],
}

export default config
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    "**/*.d.ts",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="src/app/api/lectures/stream/route.ts">
import { NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { requireSession } from '@/lib/auth';
import { isSessionWithUser } from '@/lib/session-utils';
import { generateJSON } from '@/lib/ai';

function sanitizeDbText(s: string): string {
  return (s || '').replace(/\u0000/g, '');
}

export const runtime = 'nodejs';
export const maxDuration = 60;

export async function GET(req: NextRequest) {
  try {
    const session = await requireSession();
    if (!isSessionWithUser(session)) {
      return new Response(JSON.stringify({ error: 'Unauthorised' }), { status: 401 });
    }
    const url = new URL(req.url);
    const lectureId = String(url.searchParams.get('lectureId') || '').trim();
    const preferredModel = String(url.searchParams.get('model') || '').trim() || undefined;
    if (!lectureId) {
      return new Response(JSON.stringify({ error: 'lectureId required' }), { status: 400 });
    }
    const userId = session.user.id;
    const lecture = await prisma.lecture.findFirst({
      where: { id: lectureId, userId },
      select: { id: true, title: true, originalContent: true },
    });
    if (!lecture) return new Response(JSON.stringify({ error: 'not found' }), { status: 404 });

    const encoder = new TextEncoder();
    const stream = new ReadableStream<Uint8Array>({
      async start(controller) {
        try {
          const existing = await prisma.subtopic.findMany({ where: { lectureId }, orderBy: { order: 'asc' } });
          const offset = existing.length;
          // Emit already-present subtopics immediately
          for (const s of existing) {
            controller.enqueue(
              encoder.encode(
                `data: ${JSON.stringify({
                  type: 'subtopic',
                  subtopic: {
                    id: s.id,
                    order: s.order,
                    title: s.title,
                    importance: s.importance,
                    difficulty: s.difficulty,
                    overview: s.overview,
                    explanation: s.explanation || '',
                  },
                })}\n\n`,
              ),
            );
          }

          // Compute breakdown and insert any missing subtopics progressively
          const text = lecture.originalContent || '';
          if (!text) throw new Error('Lecture has no content');

          const charLen = text.length;
          const breakdownPrompt = `
You are an expert instructional designer. Create an exhaustive, sequential breakdown of the entire document below.

Goals:
- Cover ALL major sections and distinct concepts. Do not merge unrelated topics.
- Preserve the original document order from start to finish.
- Be concise but complete: each subtopic should map to a coherent portion of the document.
 - Generate between 8 and 15 subtopics in total. Aim for about 12 on average. Never exceed 15.

Return ONLY a single JSON object with exactly these keys:
{
  "topic": "string",
  "subtopics": [
    { "title": "string", "importance": "high" | "medium" | "low", "difficulty": 1 | 2 | 3, "overview": "string" }
  ]
}

Document:
---
${text}
          `;
          const bdRaw = await generateJSON(breakdownPrompt, preferredModel);
          const DEFAULT_TITLE = 'Generating lesson... Please Wait';
          const topic = typeof bdRaw?.topic === 'string' && bdRaw.topic.trim() ? bdRaw.topic.trim() : DEFAULT_TITLE;
          const subtopics: Array<{ title: string; importance: string; difficulty: number; overview?: string }>
            = Array.isArray(bdRaw?.subtopics) ? bdRaw.subtopics : [];

          // Update title if different
          if (topic && topic !== lecture.title) {
            await prisma.lecture.update({ where: { id: lectureId }, data: { title: topic } });
            controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'title', title: topic })}\n\n`));
          }

          // Select the most important subtopics instead of the first ones
          const cap = 15;
          const scored = subtopics.map((s, idx) => ({
            idx,
            s,
            rank: (() => {
              const imp = String(s?.importance || 'medium').toLowerCase();
              return imp === 'high' ? 3 : imp === 'low' ? 1 : 2;
            })(),
          }));
          // Pick top by importance rank, then keep original document order among the selected for readability
          const top = scored
            .sort((a, b) => b.rank - a.rank || a.idx - b.idx)
            .slice(0, cap)
            .sort((a, b) => a.idx - b.idx);

          for (let i = offset; i < top.length; i++) {
            const s = top[i].s;
            const created = await prisma.subtopic.create({
              data: {
                order: i,
                title: String(s?.title || `Section ${i + 1}`),
                importance: String(s?.importance || 'medium'),
                difficulty: Number(s?.difficulty || 2),
                overview: sanitizeDbText(String(s?.overview || '')),
                explanation: null,
                lectureId,
              },
            });
            controller.enqueue(
              encoder.encode(
                `data: ${JSON.stringify({
                  type: 'subtopic',
                  subtopic: {
                    id: created.id,
                    order: created.order,
                    title: created.title,
                    importance: created.importance,
                    difficulty: created.difficulty,
                    overview: created.overview,
                    explanation: '',
                  },
                })}\n\n`,
              ),
            );
            // Small delay for UI pacing
            await new Promise((r) => setTimeout(r, 50));
          }

          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'done' })}\n\n`));
          controller.close();
        } catch (e: any) {
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'error', error: e?.message || 'stream failed' })}\n\n`));
          controller.close();
        }
      },
    });
    return new Response(stream, {
      status: 200,
      headers: {
        'Content-Type': 'text/event-stream; charset=utf-8',
        'Cache-Control': 'no-cache, no-transform',
        Connection: 'keep-alive',
        'X-Accel-Buffering': 'no',
      },
    });
  } catch (e: any) {
    return new Response(JSON.stringify({ error: e?.message || 'failed' }), { status: 500 });
  }
}
</file>

<file path="src/app/learn/[lectureId]/complete/page.tsx">
'use client';
import Link from "next/link";
import { useEffect } from "react";
import useBodyScrollLock from "@/hooks/useBodyScrollLock";

/** Measure real header height so we center below it */
function useHeaderHeightVar() {
  useEffect(() => {
    const header = document.querySelector('header');
    if (!header) return;
    const set = () =>
      document.body.style.setProperty('--header-h', `${header.getBoundingClientRect().height}px`);
    requestAnimationFrame(set);
    window.addEventListener('resize', set);
    return () => {
      window.removeEventListener('resize', set);
      document.body.style.removeProperty('--header-h');
    };
  }, []);
}

export default function CompletePage() {
  useBodyScrollLock(true);
  useHeaderHeightVar();

  useEffect(() => {
    const prev = document.body.getAttribute("data-page");
    document.body.setAttribute("data-page", "complete");
    return () => {
      if (prev) document.body.setAttribute("data-page", prev);
      else document.body.removeAttribute("data-page");
    };
  }, []);

  return (
    <main
      className="flex items-center justify-center px-4"
      style={{ minHeight: "calc(100svh - var(--header-h, 64px))" }}
    >
      <div className="relative w-full max-w-4xl"
           style={{ transform: "translateY(var(--complete-y, -48px))" }}>
        {/* Even softer halo */}
        <div
          aria-hidden
          className="pointer-events-none absolute -inset-x-16 -inset-y-8 rounded-[32px] blur-md"
          style={{
            /* green-500 rgb(34,197,94) */
            background:
              "radial-gradient(120% 85% at 50% 50%, rgba(34,197,94,0.08) 0%, rgba(34,197,94,0.05) 42%, rgba(34,197,94,0.025) 62%, transparent 76%)",
          }}
        />
        {/* Balanced outer softness */}
        <div
          aria-hidden
          className="pointer-events-none absolute inset-0 rounded-[24px]"
          style={{ boxShadow: "0 0 36px rgba(34,197,94,0.10), 0 0 12px rgba(34,197,94,0.06)" }}
        />
        {/* Card */}
        <div className="relative rounded-2xl border border-green-400/30 bg-neutral-900/70 backdrop-blur-sm p-10 text-center">
          <div className="mx-auto mb-6 grid h-16 w-16 place-items-center rounded-full bg-green-500/20 ring-1 ring-green-500/40">
            <span className="text-3xl leading-none text-green-400">✓</span>
          </div>
          <h1 className="text-2xl font-semibold text-green-400">Lecture Complete</h1>
          <p className="mt-3 text-neutral-300">
            Nicely done. You mastered every subtopic in this lecture.
          </p>
          <div className="mt-8 flex justify-center gap-3">
            <Link
              href="/learn"
              className="rounded-md bg-green-600 px-4 py-2 text-sm font-medium text-white hover:bg-green-500"
            >
              Learn something new
            </Link>
            <Link
              href="/dashboard"
              className="rounded-md border border-neutral-700 px-4 py-2 text-sm font-medium text-neutral-200 hover:bg-neutral-800"
            >
              Go to dashboard
            </Link>
          </div>
        </div>
      </div>
    </main>
  );
}
</file>

<file path="src/components/ModelSelector.tsx">
'use client';

import { useEffect, useState } from 'react';

const STORAGE_KEY = 'ai:model';
const MODELS = [
  { id: 'gemini-2.5-pro', label: 'Gemini 2.5 Pro' },
  { id: 'gemini-2.5-flash', label: 'Gemini 2.5 Flash' },
  { id: 'gpt-5-mini', label: 'GPT-5 Mini' },
];

export default function ModelSelector() {
  const [model, setModel] = useState<string>('gemini-2.5-flash');

  useEffect(() => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const isAllowed = MODELS.some((m) => m.id === saved);
        const fallback = 'gemini-2.5-flash';
        const next = isAllowed ? saved : fallback;
        if (!isAllowed) {
          localStorage.setItem(STORAGE_KEY, next);
        }
        setModel(next);
      }
    } catch {}
  }, []);

  const onChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const next = e.target.value;
    setModel(next);
    try { localStorage.setItem(STORAGE_KEY, next); } catch {}
  };

  return (
    <div className="flex items-center gap-2 text-sm">
      <span className="text-neutral-400">Model:</span>
      <select
        value={model}
        onChange={onChange}
        className="rounded-md bg-neutral-900 border border-neutral-700 px-2 py-1 text-neutral-200"
        aria-label="AI model selector"
      >
        {MODELS.map((m) => (
          <option key={m.id} value={m.id}>{m.label}</option>
        ))}
      </select>
    </div>
  );
}
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  images: {
    remotePatterns: [
      { protocol: 'https', hostname: 'lh3.googleusercontent.com' },
      { protocol: 'https', hostname: 'lh4.googleusercontent.com' },
      { protocol: 'https', hostname: 'lh5.googleusercontent.com' },
      { protocol: 'https', hostname: 'lh6.googleusercontent.com' },
      { protocol: 'https', hostname: 'public.blob.vercel-storage.com' },
    ],
  },
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
/** Tailwind CSS v4 with official PostCSS plugin */
export default {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};
</file>

<file path="src/app/api/blob/upload-url/route.ts">
import { NextResponse } from 'next/server';
import { handleUpload } from '@vercel/blob/client';
import { requireAdmin } from '@/lib/admin';

export const maxDuration = 60;

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const result = await handleUpload({
      request: req,
      body,
      token: process.env.BLOB_READ_WRITE_TOKEN,
      onBeforeGenerateToken: async (pathname) => {
        // Lock down rank icon uploads to admins only
        if (typeof pathname === 'string' && pathname.startsWith('ranks/')) {
          await requireAdmin();
        }
        const isAvatar = typeof pathname === 'string' && pathname.startsWith('avatars/');
        const allowedImages = isAvatar
          ? ['image/png', 'image/jpeg', 'image/webp'] // no GIFs for avatars
          : ['image/png', 'image/jpeg', 'image/webp', 'image/gif'];
        return {
          allowedContentTypes: ['application/pdf', ...allowedImages],
          maximumSizeInBytes: 100 * 1024 * 1024, // 100MB
          addRandomSuffix: false,
          allowOverwrite: true,
          cacheControlMaxAge: 60 * 60 * 24 * 7, // 7 days
        };
      },
      onUploadCompleted: async () => {
        // no-op: client will send resulting url to /api/lectures
      },
    });
    return NextResponse.json(result);
  } catch (e: any) {
    return NextResponse.json(
      { error: e?.message || 'Failed to handle blob upload' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/breakdown/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateJSON } from '@/lib/ai';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { isSessionWithUser } from '@/lib/session-utils';
import { bumpDailyStreak } from '@/lib/streak';

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    const userId = isSessionWithUser(session) ? session.user.id : null;
    const { content, model } = await req.json();

    if (!content) {
      return NextResponse.json({ error: 'Content is required.' }, { status: 400 });
    }

    // A detailed prompt for generating a topic breakdown.
    const prompt = `
      As an expert instructional designer, analyze the following text and break it down into a structured learning path.
      The output must be a JSON object with two keys: "topic" (a concise title for the overall subject) and "subtopics" (an array of objects).
      Each subtopic object must have the following keys:
      - "title": A clear, concise title for the subtopic.
      - "importance": A rating of "high", "medium", or "low".
      - "difficulty": A number from 1 (easy) to 3 (hard).
      - "overview": A one-sentence summary of what the subtopic covers.
      - Generate between 8 and 15 subtopics in total. Aim for about 12 on average. Never exceed 15.

      Here is the text to analyze:
      ---
      ${content}
      ---
    `;

    const aiResponse = await generateJSON(prompt, model);
    if (userId) {
      await bumpDailyStreak(userId);
    }
    return NextResponse.json(aiResponse);

  } catch (error: any) {
    console.error("Error in breakdown API:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
</file>

<file path="src/app/api/chat/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateText, streamTextChunks } from '@/lib/ai';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { isSessionWithUser } from '@/lib/session-utils';
import { bumpDailyStreak } from '@/lib/streak';

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    const userId = isSessionWithUser(session) ? session.user.id : null;
    const { userQuestion, documentContent, model } = await req.json() as { userQuestion: string, documentContent: string, model?: string };

    if (!userQuestion) {
      return NextResponse.json({ error: 'A question is required.' }, { status: 400 });
    }

    const systemPrompt = `
      You are an expert academic tutor. Your primary goal is to help the user learn, both by explaining the provided study material and by answering general knowledge questions that aid in their understanding.

      **YOUR BEHAVIOR:**
      1.  **Prioritize the Document:** First, check if the user's question can be answered using the "DOCUMENT CONTENT" provided below. If it can, base your answer primarily on the document.
      2.  **Use General Knowledge:** If the question is about a general topic or is unrelated to the document, use your own extensive knowledge to provide an accurate and helpful answer.
      3.  **Acknowledge Your Source (If Possible):** When it feels natural, clarify the source of your information. For example:
          - "According to the provided text, the xv6 operating system..."
          - "That's a great general question. Apple Silicon processors are based on the ARM architecture, not RISC-V. Here's a bit more on that..."
      4.  **Be a Helpful Tutor:** Your tone should always be encouraging, clear, and helpful.

      ---
      **DOCUMENT CONTENT (for context, if available):**
      ${documentContent || 'No document has been provided yet.'}
      ---
      
      **USER'S QUESTION:**
      ${userQuestion}
    `;

    const t0 = Date.now();

    // If query param stream=1, return Server-Sent Events style text/event-stream
    const url = new URL(req.url);
    const doStream = url.searchParams.get('stream') === '1';

    if (doStream) {
      const encoder = new TextEncoder();
      const stream = new ReadableStream<Uint8Array>({
        async start(controller) {
          try {
            for await (const chunk of streamTextChunks(systemPrompt, model)) {
              controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'chunk', delta: chunk })}\n\n`));
            }
            const ms = Date.now() - t0;
            const used = model || process.env.GEMINI_MODEL || 'default';
            controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'done', debug: { model: used, ms } })}\n\n`));
            controller.close();
            if (userId) { try { await bumpDailyStreak(userId); } catch {} }
          } catch (e: any) {
            controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'error', error: e?.message || 'stream failed' })}\n\n`));
            controller.close();
          }
        },
      });
      return new Response(stream, {
        status: 200,
        headers: {
          'Content-Type': 'text/event-stream; charset=utf-8',
          'Cache-Control': 'no-cache, no-transform',
          Connection: 'keep-alive',
          'X-Accel-Buffering': 'no',
        },
      });
    }

    // Fallback: non-streaming JSON
    const aiTextResponse = await generateText(systemPrompt, model);
    const ms = Date.now() - t0;
    const used = model || process.env.GEMINI_MODEL || 'default';
    if (userId) {
      await bumpDailyStreak(userId);
    }
    return NextResponse.json({ response: aiTextResponse, debug: { model: used, ms } });

  } catch (error: any) {
    console.error("Error in chat API:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
</file>

<file path="src/app/api/mastery/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { requireSession } from '@/lib/auth';
import { isSessionWithUser } from '@/lib/session-utils';
import { bumpDailyStreak } from '@/lib/streak';

export async function POST(req: NextRequest) {
  try {
    const session = await requireSession();
    if (!isSessionWithUser(session)) {
      return NextResponse.json({ error: 'Unauthorised' }, { status: 401 });
    }
    const userId = session.user.id;

    const { subtopicId, eloDelta = 5 } = (await req.json()) as {
      subtopicId: string;
      eloDelta?: number;
    };

    if (!subtopicId) {
      return NextResponse.json({ error: 'subtopicId is required.' }, { status: 400 });
    }

    // Increment Elo ONLY if a new mastery record is created.
    const { created } = await prisma.$transaction(async (tx) => {
      try {
        await tx.userMastery.create({ data: { userId, subtopicId } });
        await tx.user.update({ where: { id: userId }, data: { elo: { increment: eloDelta } } });
        return { created: true };
      } catch (e: any) {
        // Unique constraint violation => already mastered; do not increment Elo
        if (e && typeof e === 'object' && (e as any).code === 'P2002') {
          return { created: false };
        }
        throw e;
      }
    });

    // Keep streak behavior unchanged
    await bumpDailyStreak(userId);

    return NextResponse.json({ ok: true, eloIncremented: created });
  } catch (e: any) {
    console.error('MASTERY_API_ERROR:', e);
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: e?.status || 500 });
  }
}
</file>

<file path="src/app/profile/page.tsx">
'use client';
import { useEffect, useMemo, useState } from 'react';
import { BrainCircuit, Flame, Target, User as UserIcon, Image as ImageIcon } from 'lucide-react';
import { upload } from '@vercel/blob/client';

type PublicProfile = {
  id: string;
  name: string | null;
  username: string | null;
  bio: string | null;
  image: string | null;
  elo: number;
  streak: number;
  masteredCount: number;
  quiz: { totalAttempts: number; correct: number; accuracy: number };
  isAdmin?: boolean;
};

export default function ProfilePage() {
  const [me, setMe] = useState<PublicProfile | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [name, setName] = useState('');
  const [username, setUsername] = useState('');
  const [bio, setBio] = useState('');
  const [image, setImage] = useState<string | null>(null);

  useEffect(() => {
    (async () => {
      try {
        const profRes = await fetch('/api/users/me');
        const data = await profRes.json();
        if (!profRes.ok) throw new Error(data.error || 'Failed to load profile');
        setMe(data.user as PublicProfile);
        setName(data.user.name || '');
        setUsername(data.user.username || '');
        setBio(data.user.bio || '');
        setImage(data.user.image || null);
      } catch (e: any) {
        setError(e?.message || 'Failed to load');
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  const tier = useMemo(() => {
    const elo = me?.elo || 0;
    if (elo >= 2000) return 'Legend';
    if (elo >= 1700) return 'Master';
    if (elo >= 1400) return 'Expert';
    if (elo >= 1200) return 'Skilled';
    return 'Learner';
  }, [me?.elo]);

  // No dynamic color; keep header consistently green per request

  const tierColor = useMemo(() => {
    const elo = me?.elo || 0;
    if (elo >= 2000) return 'from-yellow-300 via-amber-200 to-rose-300';
    if (elo >= 1700) return 'from-purple-300 via-indigo-300 to-cyan-300';
    if (elo >= 1400) return 'from-green-300 via-emerald-300 to-teal-300';
    if (elo >= 1200) return 'from-blue-300 via-cyan-300 to-sky-300';
    return 'from-neutral-300 via-neutral-200 to-neutral-100';
  }, [me?.elo]);

  async function onSave() {
    try {
      const res = await fetch('/api/users/me', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, username, bio, image }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || 'Failed to save');
      setMe((m) => (m ? { ...m, name, username, bio, image: image || null } : m));
    } catch (e: any) {
      alert(e?.message || 'Save failed');
    }
  }

  async function onPickAvatar(file: File) {
    try {
      if (file.type === 'image/gif') {
        throw new Error('GIFs are not allowed for profile pictures');
      }
      const ext = file.type === 'image/png'
        ? 'png'
        : file.type === 'image/webp'
          ? 'webp'
          : 'jpg';
      const pathname = `avatars/${me?.id}.${ext}`;
      const { url } = await upload(pathname, file, {
        access: 'public',
        handleUploadUrl: '/api/blob/upload-url',
        contentType: file.type,
      });
      const bust = `${url}${url.includes('?') ? '&' : '?'}v=${Date.now()}`;
      setImage(bust);
      // Persist immediately so the avatar survives reloads
      try {
        const res = await fetch('/api/users/me', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ image: bust }),
        });
        if (res.ok) {
          setMe((m) => (m ? { ...m, image: bust } : m));
        } else {
          const data = await res.json().catch(() => ({}));
          console.warn('Failed to persist avatar:', data);
        }
      } catch (persistErr) {
        console.warn('Error persisting avatar', persistErr);
      }
    } catch (e: any) {
      alert(e?.message || 'Avatar upload failed');
    }
  }

  if (loading) {
    return (
      <div className="container-narrow space-y-6">
        <div className="card h-44 animate-pulse" />
        <div className="grid gap-6 md:grid-cols-2">
          <div className="card h-64 animate-pulse" />
          <div className="card h-64 animate-pulse" />
        </div>
      </div>
    );
  }
  if (error) return <div className="container-narrow text-red-400">{error}</div>;
  if (!me) return <div className="container-narrow">No profile.</div>;

  return (
    <div className="container-narrow space-y-10">
      {/* Hero */}
      <section className="relative overflow-hidden card">
        <div className="absolute inset-0 bg-gradient-to-r from-emerald-500/20 via-emerald-400/10 to-transparent" />
        <div className="p-5 md:p-6 pb-8 md:pb-10">
          <div className="flex items-center justify-between gap-6">
            <div className="flex items-center gap-4 min-w-0 flex-1">
              <div className="relative self-center top-[6px]">
                <div className="h-20 w-20 rounded-full ring-2 ring-neutral-800 overflow-hidden bg-neutral-900">
                  {image ? (
                    // eslint-disable-next-line @next/next/no-img-element
                    <img
                      src={image}
                      alt="avatar"
                      className="h-full w-full object-cover"
                      referrerPolicy="no-referrer"
                    />
                  ) : (
                    <div className="flex h-full w-full items-center justify-center text-neutral-500">
                      <UserIcon className="h-8 w-8" />
                    </div>
                  )}
                </div>
              </div>

              <div className="min-w-0">
                <div className="flex flex-wrap items-center gap-3">
                  <h1 className="text-2xl md:text-3xl font-bold tracking-tight">
                    {me.name || 'Your Profile'}
                  </h1>
                  <span className={`inline-flex items-center gap-2 rounded-full bg-neutral-900/70 ring-1 ring-neutral-800 px-3 py-1 text-xs`}
                  >
                    <span className={`bg-gradient-to-r ${tierColor} bg-clip-text text-transparent font-semibold`}>{tier}</span>
                    <span className="text-neutral-400">Elo {me.elo}</span>
                  </span>
                </div>
                <p className="mt-1 text-sm text-neutral-400">
                  {me.username ? `@${me.username}` : 'Pick a username to claim your handle'}
                </p>
              </div>
            </div>

            <div className="hidden md:flex items-center gap-2 shrink-0 relative top-[2px]">
              <Chip icon={Flame} label={`${me.streak} day${me.streak === 1 ? '' : 's'} streak`} />
              <Chip icon={Target} label={`${me.masteredCount} mastered`} />
            </div>
          </div>
        </div>
      </section>

      <section className="grid gap-6 md:grid-cols-2">
        {/* Edit card */}
        <div className="card p-6 space-y-5">
          <h2 className="text-xl font-semibold">Edit Profile</h2>
          <div className="grid gap-4">
            <label className="grid gap-2 text-sm">
              <span className="muted">Name</span>
              <input value={name} onChange={(e) => setName(e.target.value)} className="input" />
            </label>
            <label className="grid gap-2 text-sm">
              <span className="muted">Username</span>
              <input value={username} onChange={(e) => setUsername(e.target.value)} className="input" placeholder="your-handle" />
            </label>
            <label className="grid gap-2 text-sm">
              <span className="muted">Bio</span>
              <textarea value={bio} onChange={(e) => setBio(e.target.value)} rows={3} className="input" />
            </label>
          </div>
          <div className="flex items-center gap-3">
            <label className="btn-ghost cursor-pointer">
              <input
                type="file"
                accept="image/png,image/jpeg,image/webp"
                className="hidden"
                onChange={(e) => e.target.files && onPickAvatar(e.target.files[0])}
              />
              <ImageIcon className="h-4 w-4" />
              Change Avatar
            </label>
            <button onClick={onSave} className="btn-primary">Save Changes</button>
          </div>
          {error && <div className="text-sm text-red-400">{error}</div>}
        </div>

        {/* Stats card */}
        <div className="card p-6">
          <h2 className="text-xl font-semibold mb-4">Learning Stats</h2>
          <div className="grid gap-4 sm:grid-cols-3">
            <Stat label="Mastered" value={String(me.masteredCount)} icon={Target} />
            <Stat label="Accuracy" value={`${me.quiz.accuracy}%`} sub={`${me.quiz.correct}/${me.quiz.totalAttempts}`} icon={BrainCircuit} />
            <Stat label="Streak" value={String(me.streak)} icon={Flame} />
          </div>
        </div>
        {me?.isAdmin && (
          <div className="card p-6">
            <h2 className="text-xl font-semibold mb-3">Admin Panel</h2>
            <p className="text-neutral-400 text-sm mb-4">You have admin access.</p>
            <div className="flex flex-wrap gap-3">
              <a href="/admin" className="btn-primary px-4 py-2">Open Admin Panel</a>
              <a href="/admin/ranks" className="btn-ghost px-4 py-2">Manage Rank Icons</a>
            </div>
          </div>
        )}
      </section>
    </div>
  );
}

function Chip({ icon: Icon, label }: { icon: React.ElementType; label: string }) {
  return (
    <span className="inline-flex items-center gap-2 rounded-full bg-neutral-900/70 px-3 py-1 text-xs ring-1 ring-neutral-800">
      <Icon className="h-3.5 w-3.5 text-neutral-300" />
      <span>{label}</span>
    </span>
  );
}

function Stat({ label, value, sub, icon: Icon }: { label: string; value: string; sub?: string; icon: React.ElementType }) {
  return (
    <div className="rounded-lg border border-neutral-800 p-4">
      <div className="flex items-center justify-between">
        <div className="text-sm text-neutral-400">{label}</div>
        <Icon className="h-4 w-4 text-neutral-300" />
      </div>
      <div className="mt-1 text-2xl font-semibold">{value}</div>
      {sub && <div className="text-xs text-neutral-500">{sub}</div>}
    </div>
  );
}
</file>

<file path="src/lib/auth.ts">
// src/lib/auth.ts
import type { NextAuthOptions } from 'next-auth';
import { getServerSession } from 'next-auth';
import GoogleProvider from 'next-auth/providers/google';
import { PrismaAdapter } from '@auth/prisma-adapter';
import prisma from '@/lib/prisma';

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,       // or GOOGLE_CLIENT_ID
      clientSecret: process.env.GOOGLE_CLIENT_SECRET! // or GOOGLE_CLIENT_SECRET
    }),
  ],
  session: { strategy: 'jwt' }, // keep JWT sessions; adapter still persists User/Account
  secret: process.env.NEXTAUTH_SECRET,       // REQUIRED in production
  callbacks: {
    async jwt({ token, user }) {
      if (user?.id) {
        token.id = user.id;
        token.sub = user.id;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        (session.user as { id?: string }).id = (token.sub || token.id || '') as string;
      }
      return session;
    },
  },
  // pages: { signIn: '/api/auth/signin' }, // optional; default built-in page is fine
};

export async function requireSession() {
  const session = await getServerSession(authOptions);
  if (!session || !session.user) {
    const err = new Error('Unauthorized') as Error & { status?: number };
    err.status = 401;
    throw err;
  }
  return session;
}
</file>

<file path="src/lib/cached.ts">
import { unstable_cache } from 'next/cache';
import prisma from '@/lib/prisma';

export async function getUserStatsCached(userId: string) {
  const fn = unstable_cache(
    async () => {
      const [userLite, masteredCount] = await Promise.all([
        prisma.user.findUnique({ where: { id: userId }, select: { id: true, name: true, elo: true, streak: true } }),
        prisma.userMastery.count({ where: { userId } }),
      ]);
      return { user: userLite, masteredCount };
    },
    ['user-stats', userId],
    { revalidate: 15, tags: [`user-stats:${userId}`] }
  );
  return fn();
}

export async function getLecturesCached(userId: string) {
  const fn = unstable_cache(
    async () => {
      const lectures = await prisma.lecture.findMany({
        where: { userId },
        orderBy: [{ starred: 'desc' }, { createdAt: 'desc' }],
        take: 50,
        include: { _count: { select: { subtopics: true } } },
      });
      return lectures;
    },
    ['user-lectures', userId],
    { revalidate: 30, tags: [`user-lectures:${userId}`] }
  );
  return fn();
}
</file>

<file path="README.md">
# LearnMax 🧠✨

**The Science of Learning, Perfected by AI.**

LearnMax is a full-stack web application built with Next.js that revolutionizes studying. Stop wasting hours on inefficient rereading. LearnMax applies proven cognitive science principles, powered by the Google Gemini API, to deconstruct complex materials, generate focused learning modules, and verify your understanding every step of the way.

 <img width="1470" height="787" alt="image" src="https://github.com/user-attachments/assets/7a9cf5ec-03a4-4bb6-a700-34deed0735b1" />
<img width="1470" height="789" alt="image" src="https://github.com/user-attachments/assets/5af0e37a-c1bb-4262-bf60-757bd4c7cfcc" />
<img width="725" height="575" alt="image" src="https://github.com/user-attachments/assets/8b784b6d-8fa2-4a49-a4d8-12aec793ef46" />



---

## 🚀 About The Project

This application is designed to create a hyper-efficient study path from any text-based content, like lecture notes or PDF slides. It breaks down the material, explains each part, and quizzes you to ensure you've mastered the concept before moving on.

### Core Features

*   **📚 AI Content Deconstruction**: Upload a PDF or paste raw text. The AI analyzes the material and structures it into a logical learning path of subtopics, ordered by importance and difficulty.
*   **💡 Guided Mastery Learning**: Tackle one core concept at a time. The app provides AI-generated explanations in various styles (simplified, detailed, or with examples) to prevent cognitive overload and embed knowledge effectively.
*   **🎯 Verified Comprehension**: Before advancing, pass a targeted, AI-generated quiz to prove you've mastered the current concept. This guarantees a rock-solid foundation for lasting knowledge.
*   **💬 Interactive AI Tutor**: Have a question? An AI tutor is available in a side panel, ready to answer questions about the source material or related general knowledge topics.
*   **📊 Personalized Dashboard**: Keep track of your learning journey. View stats like your total lectures, mastered subtopics, and even a "Learning Elo" score that reflects your progress.
*   **🔐 Secure Authentication**: User accounts and sessions are securely managed using NextAuth.js with Google as an OAuth provider.

---

## 🛠️ Built With

This project leverages a modern, powerful tech stack:

*   **Framework**: [Next.js](https://nextjs.org/) (v15) with App Router
*   **Language**: [TypeScript](https://www.typescriptlang.org/)
*   **AI**: [Google Gemini API](https://ai.google.dev/)
*   **Database**: [PostgreSQL](https://www.postgresql.org/)
*   **ORM**: [Prisma](https://www.prisma.io/)
*   **Authentication**: [NextAuth.js](https://next-auth.js.org/)
*   **Styling**: [Tailwind CSS](https://tailwindcss.com/)
*   **Client-side State**: [Zustand](https://github.com/pmndrs/zustand)
*   **Icons**: [Lucide React](https://lucide.dev/)

---

## 🏁 Getting Started

To get a local copy up and running, follow these simple steps.

### Prerequisites

*   **Node.js**: v20.x or higher
*   **pnpm**: `npm install -g pnpm`
*   **PostgreSQL**: A running instance of PostgreSQL.

### Installation & Setup

1.  **Clone the repository:**
    ```sh
    git clone https://github.com/your-username/learnmax.git
    cd learnmax
    ```

2.  **Install dependencies:**
    ```sh
    pnpm install
    ```

3.  **Set up environment variables:**
    Create a `.env.local` file in the root of your project and add the following variables.

    ```env
    # Google AI API Key (for Gemini)
    GOOGLE_API_KEY="your_google_api_key"

    # PostgreSQL Connection URLs (get from your provider)
    # Used by Prisma for migrations and the app
    POSTGRES_URL="postgresql://user:password@host:port/database"
    # Direct connection for Prisma Migrate/Studio
    POSTGRES_URL_NON_POOLING="postgresql://user:password@host:port/database"
    # Shadow database for development migrations
    POSTGRES_SHADOW_URL="postgresql://user:password@host:port/database_shadow"

    # NextAuth.js Configuration
    # Generate a secret with: openssl rand -base64 32
    NEXTAUTH_SECRET="your_nextauth_secret"
    # Google OAuth credentials
    GOOGLE_CLIENT_ID="your_google_client_id"
    GOOGLE_CLIENT_SECRET="your_google_client_secret"
    ```

4.  **Run database migrations:**
    This will sync the Prisma schema with your PostgreSQL database.
    ```sh
    pnpm prisma migrate dev
    ```

5.  **Run the development server:**
    ```sh
    pnpm dev
    ```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result!

---

## 📁 Project Structure

The codebase is organized to be clean and maintainable:

*   `prisma/`: Contains the database `schema.prisma` and migration files.
*   `public/`: Static assets like images and SVGs.
*   `src/app/`: The core of the Next.js application, using the App Router.
    *   `(pages)/`: Main routes like `/`, `/dashboard`, and `/learn`.
    *   `api/`: All backend API endpoints, organized by resource.
*   `src/components/`: Shared, reusable React components used across the application.
*   `src/lib/`: Essential logic and utilities.
    *   `ai.ts`: Functions for interacting with the Google Gemini API.
    *   `auth.ts`: NextAuth.js configuration.
    *   `prisma.ts`: Prisma client instance.
    *   `client/`: Client-side specific helpers and state stores (Zustand).
*   `src/types/`: TypeScript type definitions.

---

## License

Distributed under the MIT License. See `LICENSE` for more information.
</file>

<file path="src/app/learn/[lectureId]/page.tsx">
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { redirect, notFound } from 'next/navigation';
import { isSessionWithUser } from '@/lib/session-utils';
import LearnView from '@/components/LearnView';

export default async function LearnPage({ params }: { params: Promise<{ lectureId: string }> }) {
  const session = await getServerSession(authOptions);
  if (!isSessionWithUser(session)) {
    redirect('/api/auth/signin');
  }
  const userId = session.user.id;
  const { lectureId } = await params;

  const lecture = await prisma.lecture.findFirst({
    where: { id: lectureId, userId },
    include: {
      subtopics: {
        orderBy: { order: 'asc' },
        include: {
          questions: true,
          masteredBy: { where: { userId } },
        },
      },
    },
  });

  if (!lecture) notFound();

  const initial = {
    id: lecture.id,
    title: lecture.title,
    originalContent: lecture.originalContent,
    subtopics: lecture.subtopics.map((s) => ({
      id: s.id,
      order: s.order,
      title: s.title,
      importance: s.importance,
      difficulty: s.difficulty,
      overview: s.overview || '',
      explanation: s.explanation || '',
      mastered: (s.masteredBy?.length ?? 0) > 0,
      questions: s.questions.map((q) => ({
        id: q.id,
        prompt: q.prompt,
        options: (q.options as unknown as string[]) || [],
        answerIndex: q.answerIndex,
        explanation: q.explanation,
      })),
    })),
  };

  return (
    <div className="container-wide">
      <LearnView initial={initial} />
    </div>
  );
}
</file>

<file path="src/lib/client/lectures.ts">
export async function createLectureFromText(
  content: string
): Promise<{ lectureId: string }> {
  let model: string | undefined;
  try { model = localStorage.getItem('ai:model') || undefined; } catch {}
  const res = await fetch('/api/lectures', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content, model }),
  });
  if (!res.ok) {
    const e = await res.json().catch(() => ({}));
    throw new Error(e.error || `Failed: ${res.status}`);
  }
  return res.json();
}

export async function createLectureFromPdf(
  file: File
): Promise<{ lectureId: string }> {
  // Always use Blob direct upload to avoid server body limits
  // Request a client token and upload via SDK helper route
  const pathname = `uploads/${Date.now()}-${file.name}`;
  const tokenRes = await fetch('/api/blob/upload-url', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      type: 'blob.generate-client-token',
      payload: { pathname, callbackUrl: '', multipart: file.size > 5_000_000, clientPayload: null },
    }),
  });
  if (!tokenRes.ok) {
    const e = await tokenRes.json().catch(() => ({}));
    throw new Error(e.error || `Failed to init upload (${tokenRes.status})`);
  }
  const tokenData = await tokenRes.json();
  if (tokenData?.type !== 'blob.generate-client-token' || !tokenData?.clientToken) {
    throw new Error('Invalid upload token response');
  }
  // Use client-side SDK put with token
  const { put } = await import('@vercel/blob/client');
  const uploaded = await put(pathname, file, {
    access: 'public',
    token: tokenData.clientToken,
    contentType: file.type || 'application/pdf',
    multipart: file.size > 10_000_000,
  } as any);
  const body: any = { blobUrl: uploaded.url };
  try { const m = localStorage.getItem('ai:model'); if (m) body.model = m; } catch {}
  const res = await fetch('/api/lectures', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });
  if (!res.ok) {
    const e = await res.json().catch(() => ({}));
    throw new Error(e.error || `Failed: ${res.status}`);
  }
  return res.json();
}

export async function createLectureFromPdfVision(
  file: File
): Promise<{ lectureId: string }> {
  const form = new FormData();
  form.append('file', file);
  try { const m = localStorage.getItem('ai:model'); if (m) form.append('model', m); } catch {}
  const res = await fetch('/api/lectures/vision', { method: 'POST', body: form });
  if (!res.ok) {
    const e = await res.json().catch(() => ({}));
    throw new Error(e.error || `Failed: ${res.status}`);
  }
  return res.json();
}
</file>

<file path="prisma/schema.prisma">
// Schema generated by setup script from the migration plan.

generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "linux-arm64-openssl-3.0.x"]
}

datasource db {
  provider          = "postgresql"
  url               = env("POSTGRES_URL")
  directUrl         = env("POSTGRES_URL_NON_POOLING")
  shadowDatabaseUrl = env("POSTGRES_SHADOW_URL")
  relationMode      = "prisma"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id                String        @id @default(cuid())
  name              String?
  email             String?       @unique
  emailVerified     DateTime?
  image             String?
  elo               Int           @default(1000)
  streak            Int           @default(0)
  lastStudiedAt     DateTime?
  accounts          Account[]
  sessions          Session[]
  lectures          Lecture[]
  masteredSubtopics UserMastery[]
  username          String?       @unique
  bio               String?
  quizAttempts      QuizAttempt[]
}

model Lecture {
  id              String   @id @default(cuid())
  title           String
  originalContent String   @db.Text
  createdAt       DateTime @default(now())
  starred         Boolean  @default(false)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  subtopics       Subtopic[]

  @@index([userId, starred, createdAt])
}

model Subtopic {
  id          String         @id @default(cuid())
  order       Int
  title       String
  importance  String
  difficulty  Int
  overview    String
  explanation String?        @db.Text
  lectureId   String
  lecture     Lecture        @relation(fields: [lectureId], references: [id], onDelete: Cascade)
  questions   QuizQuestion[]
  masteredBy  UserMastery[]

  @@unique([lectureId, order])
}

model QuizQuestion {
  id          String   @id @default(cuid())
  prompt      String
  options     Json
  answerIndex Int
  explanation String
  subtopicId  String
  subtopic    Subtopic @relation(fields: [subtopicId], references: [id], onDelete: Cascade)
  attempts    QuizAttempt[]
}

model UserMastery {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  subtopicId String
  subtopic   Subtopic @relation(fields: [subtopicId], references: [id], onDelete: Cascade)

  @@unique([userId, subtopicId])
}

model QuizAttempt {
  id            String       @id @default(cuid())
  createdAt     DateTime     @default(now())
  userId        String
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionId    String
  question      QuizQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  selectedIndex Int
  isCorrect     Boolean

  @@index([userId, createdAt])
  @@index([userId, isCorrect, createdAt])
}

model Rank {
  slug    String  @id
  name    String
  minElo  Int     @unique
  iconUrl String?
}
</file>

<file path="src/app/dashboard/page.tsx">
import Link from 'next/link';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { redirect } from 'next/navigation';
import { BookOpen, Target, BrainCircuit, Flame } from 'lucide-react';
import { isSessionWithUser } from '@/lib/session-utils';
import LectureList, { type ClientLecture } from '@/components/LectureList';
import { Suspense } from 'react';
import { getLecturesCached, getUserStatsCached } from '@/lib/cached';

function StatCard({
  icon: Icon,
  label,
  value,
  color,
}: {
  icon: React.ElementType;
  label: string;
  value: string | number;
  color: string;
}) {
  return (
    <div className="card p-6 flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <span className="text-neutral-400">{label}</span>
        <Icon className={`w-6 h-6 ${color}`} />
      </div>
      <p className="text-4xl font-bold">{value}</p>
    </div>
  );
}

async function getData() {
  const session = await getServerSession(authOptions);
  if (!isSessionWithUser(session)) {
    redirect('/api/auth/signin');
  }
  const userId = session.user.id;

  const [{ user: userLite, masteredCount }, lectures] = await Promise.all([
    getUserStatsCached(userId),
    getLecturesCached(userId),
  ]);

  return { user: userLite, masteredCount, lectures };
}

export default async function Dashboard() {
  const { user, masteredCount, lectures } = await getData();
  type LectureItem = typeof lectures[number];
  const clientLectures: ClientLecture[] = lectures.map((l: any) => ({
    id: l.id,
    title: l.title,
    createdAtISO: new Date(l.createdAt).toISOString(),
    subtopicCount: l._count.subtopics,
    starred: l.starred ?? false,
  }));

  return (
    <div className="container-narrow space-y-12">
      <header>
        <h1 className="text-3xl font-bold tracking-tight">Your Dashboard</h1>
        <p className="text-neutral-400 mt-2">
          Welcome back{user?.name ? `, ${user.name}` : ''}! Here&apos;s a summary of your learning journey.
        </p>
      </header>
      <section className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="md:col-span-2 grid grid-cols-1 sm:grid-cols-2 gap-6">
          <StatCard
            label="Lectures Created"
            value={lectures.length}
            icon={BookOpen}
            color="text-blue-400"
          />
          <StatCard
            label="Subtopics Mastered"
            value={masteredCount ?? 0}
            icon={Target}
            color="text-green-400"
          />
          <StatCard
            label="Learning Elo"
            value={user?.elo ?? 1000}
            icon={BrainCircuit}
            color="text-purple-400"
          />
          <StatCard
            label="Current Streak"
            value={`${user?.streak ?? 0} days`}
            icon={Flame}
            color="text-orange-400"
          />
        </div>
        <div className="card p-6 flex flex-col items-center justify-center text-center gap-4">
          <h3 className="text-xl font-semibold">Ready to Learn?</h3>
          <p className="text-neutral-400 text-sm">
            Create a lecture from text or PDF in the Learn Workspace.
          </p>
          <Link
            href="/learn"
            className="w-full btn-primary px-6 py-3 font-semibold transition-transform hover:scale-105"
          >
            Go to Workspace
          </Link>
        </div>
      </section>
      <section>
        <h2 className="text-2xl font-semibold">Your Lectures</h2>
        <Suspense fallback={<div className="mt-6 text-sm text-neutral-500">Loading your lectures…</div>}>
          {/* Already fetched above, but Suspense boundary lets the header paint instantly if cache misses */}
          <LectureList initialLectures={clientLectures} />
        </Suspense>
        {lectures.length >= 50 && (
          <p className="mt-2 text-sm text-neutral-500">Showing latest 50. Older lectures are available via search; we can add paging if you need it.</p>
        )}
      </section>
    </div>
  );
}
</file>

<file path="src/app/api/explain-db/route.ts">
// src/app/api/explain-db/route.ts
import { NextResponse } from 'next/server';
import { generateText, PRIMARY_MODEL, streamTextChunks } from '@/lib/ai';
import prisma from '@/lib/prisma';

const L = process.env.LOG_EXPLAIN === '1';
const log = (...a: any[]) => { if (L) console.log('[explain-db]', ...a); };
const err = (...a: any[]) => { if (L) console.error('[explain-db]', ...a); };

type StripOpts = { title?: string; isChunk?: boolean };

function stripPreamble(md: string, opts?: StripOpts): string {
  // Avoid trimming for streaming chunks to prevent word concatenation across boundaries
  let out = String(md ?? '');

  // Common filler/preamble phrases at the start
  out = out.replace(/^(?:\s*)(of course|sure\,?|here (?:is|are)|crafting learning module\.\.\.)[^\n]*\n*/i, '');

  // Drop leading ATX headings (H1–H6)
  out = out.replace(/^\s{0,3}#{1,6}\s+[^\n]+\n+/m, '');

  // Drop leading setext headings (Title\n==== or ----)
  out = out.replace(/^\s*([^\n]+)\n(?:=+|-+)\s*\n+/m, '');

  // If first non-empty line equals the provided title, remove it
  if (opts?.title) {
    const lines = out.split('\n');
    const firstIdx = lines.findIndex((l) => l.trim() !== '');
    if (firstIdx !== -1) {
      const firstLine = lines[firstIdx].trim();
      if (firstLine.localeCompare(opts.title.trim(), undefined, { sensitivity: 'accent' }) === 0) {
        lines.splice(firstIdx, 1);
        out = lines.join('\n');
      }
    }
  }

  // Drop generic disclaimers about context/section at the very start
  const paras = out.split(/\n{2,}/);
  if (paras.length) {
    const first = paras[0].trim();
    const preambleRe = /\b(document\s+context|provided\s+context|limited\s+context|this\s+(section|explanation)\s+will|in\s+this\s+(section|lesson)|overview\s+of)\b/i;
    if (first.length <= 400 && preambleRe.test(first)) {
      paras.shift();
      out = paras.join('\n\n');
    }
  }

  if (!opts?.isChunk) out = out.trim();
  return out;
}

// Merge streaming chunks without gluing words together across boundaries.
function appendChunkSafely(previous: string, next: string): string {
  if (!next) return previous || '';
  if (!previous) return next;
  const lastChar = previous.slice(-1);
  const firstChar = next[0];
  const isWordChar = (ch: string) => /[A-Za-z0-9]/.test(ch);
  const needsSpace = (
    (isWordChar(lastChar) && isWordChar(firstChar)) ||
    (/[\.:;!?]$/.test(previous) && isWordChar(firstChar))
  ) && !/^\s/.test(next);
  return needsSpace ? previous + ' ' + next : previous + next;
}

  function sanitizeDbText(s: string): string {
    return (s || '').replace(/\u0000/g, '');
  }

export async function POST(req: Request) {
  const t0 = Date.now();
  try {
    const body = await req.json().catch(() => ({} as any));
    const subtopicIn = typeof body?.subtopic === 'string' ? body.subtopic.trim() : '';
    const subtopicIdIn = typeof body?.subtopicId === 'string' ? body.subtopicId.trim() : '';
    const lectureIdIn = typeof body?.lectureId === 'string' ? body.lectureId.trim() : '';
    const docIn = typeof body?.documentContent === 'string' ? body.documentContent : '';
    const titleIn =
      typeof body?.lectureTitle === 'string' && body.lectureTitle.trim()
        ? body.lectureTitle.trim()
        : typeof body?.title === 'string' && body.title.trim()
        ? body.title.trim()
        : 'Lecture';
    const styleIn =
      typeof body?.style === 'string' && body.style.trim()
        ? body.style.trim().toLowerCase()
        : 'default';
    const coveredList = Array.isArray(body?.covered)
      ? (body.covered as any[])
          .map((c) => ({
            title: String((c as any)?.title || '').trim(),
            overview: String((c as any)?.overview || '').trim(),
          }))
          .filter((c) => c.title)
      : [];

    const subtopic = subtopicIn || 'Overview';
    const lectureTitle = titleIn;

    const styleHint =
      styleIn === 'simplified' ? 'Explain as simply as possible for a beginner.'
      : styleIn === 'detailed' ? 'Go a bit deeper on nuances and edge cases.'
      : styleIn === 'example' ? 'Center the explanation around a concrete, realistic example.'
      : 'Use a balanced, concise explanation.';

    const preferredModel = typeof body?.model === 'string' && body.model.trim() ? body.model.trim() : undefined;
    const effectiveModel = preferredModel || PRIMARY_MODEL;
    log('IN', { lectureTitle, subtopic, style: styleIn, model: effectiveModel });

    // Resolve document content for grounding
    let documentContent = '';
    if (lectureIdIn) {
      try {
        const lecture = await prisma.lecture.findUnique({ where: { id: lectureIdIn }, select: { originalContent: true } });
        documentContent = lecture?.originalContent || '';
      } catch {}
    }
    if (!documentContent && docIn) documentContent = docIn;
    documentContent = sanitizeDbText(documentContent);
    // Clip to keep prompts manageable
    const clip = (s: string, max = 20000) => {
      const t = (s || '').trim();
      return t.length > max ? t.slice(0, max) : t;
    };

    const prompt = [
      `You are writing ONE section of an in-progress lecture.`,
      `Lecture title: "${lectureTitle}"`,
      `Subtopic: "${subtopic}"`,
      `Style: ${styleHint}`,
      (coveredList.length
        ? `Previously covered subtopics (avoid repeating their content; build upon them where natural):\n${JSON.stringify(coveredList, null, 2)}`
        : ''),
      `Ground your explanation STRICTLY in the DOCUMENT CONTEXT below when relevant. If the context is missing or does not cover the subtopic, say so briefly and provide a best-effort general explanation without inventing specifics from the document.`,
      `Write 300–600 words of clean Markdown.`,
      `Start directly with content. No preamble (e.g., "Of course", "Here is", etc.).`,
      `Do NOT number subtopics. Do NOT add a standalone H1.`,
      `Keep the tone concise and instructional; use short paragraphs, bullet lists, or small inline examples when useful.`,
      `---`,
      `DOCUMENT CONTEXT (may be truncated):`,
      clip(documentContent, 20000),
    ].join('\n');

    // Streaming mode: return text/event-stream with incremental chunks
    const url = new URL(req.url);
    const doStream = url.searchParams.get('stream') === '1';
    if (doStream) {
      const encoder = new TextEncoder();
      let full = '';
      const stream = new ReadableStream<Uint8Array>({
        async start(controller) {
          try {
            for await (const chunk of streamTextChunks(prompt, preferredModel)) {
              const clean = stripPreamble(chunk, { title: subtopic, isChunk: true });
              full = appendChunkSafely(full, clean);
              controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'chunk', delta: clean })}\n\n`));
            }
            const markdown = stripPreamble(full, { title: subtopic });
            // Persist best-effort
            if (subtopicIdIn && markdown) {
              try {
                await prisma.subtopic.update({ where: { id: subtopicIdIn }, data: { explanation: sanitizeDbText(markdown) } });
              } catch {}
            }
            const ms = Date.now() - t0;
            controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'done', debug: { model: effectiveModel, ms } })}\n\n`));
            controller.close();
          } catch (e: any) {
            controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'error', error: e?.message || 'stream failed' })}\n\n`));
            controller.close();
          }
        },
      });
      return new Response(stream, {
        status: 200,
        headers: {
          'Content-Type': 'text/event-stream; charset=utf-8',
          'Cache-Control': 'no-cache, no-transform',
          Connection: 'keep-alive',
          'X-Accel-Buffering': 'no',
        },
      });
    }

    // Non-streaming fallback
    const raw = await generateText(prompt, preferredModel);
    const markdown = stripPreamble(raw, { title: subtopic });
    const ms = Date.now() - t0;

    log('OUT', { ok: !!markdown, chars: markdown.length, ms });

    if (!markdown) {
      return NextResponse.json({ error: 'empty' }, { status: 502 });
    }
    if (subtopicIdIn) {
      try {
        await prisma.subtopic.update({
          where: { id: subtopicIdIn },
          data: { explanation: sanitizeDbText(markdown) },
        });
      } catch {}
    }
    return NextResponse.json({ markdown, explanation: markdown, debug: { model: effectiveModel, ms } });
  } catch (e: any) {
    const ms = Date.now() - t0;
    err('ERR', { ms, message: e?.message });
    return NextResponse.json(
      { error: e?.message || 'internal error' },
      { status: 500 },
    );
  }
}
</file>

<file path="src/components/ChatPanel.tsx">
'use client';

import { useState, useRef, useEffect } from 'react';
import { Send, Loader2, User, Bot } from 'lucide-react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import rehypeKatex from 'rehype-katex';


// Normalize to avoid whole-message fenced blocks.
function sanitizeMd(md: string): string {
  if (!md) return md;
  let t = md.trim();
  const exactFence = t.match(/^```(?:markdown|md|text)?\s*\n([\s\S]*?)\n```$/i);
  if (exactFence) t = exactFence[1].trim();
  else {
    const m = t.match(/^```([A-Za-z0-9+_.-]*)\s*\n([\s\S]*?)\n```$/);
    if (m) {
      const lang = (m[1] || "").toLowerCase();
      const inner = m[2];
      if (lang === "" || lang === "markdown" || lang === "md" || /^(#{1,6}\s|[-*]\s|\d+\.\s)/m.test(inner) || /\n\n/.test(inner)) {
        t = inner.trim();
      }
    }
  }
  const lines = t.split("\n");
  const nonEmpty = lines.filter(l => l.trim() !== "");
  if (nonEmpty.length && nonEmpty.every(l => /^ {4,}|\t/.test(l))) {
    t = lines.map(l => l.replace(/^ {4}/, "")).join("\n").trim();
  }
  const ticks = (t.match(/```/g) || []).length;
  if (ticks === 1) t = t.replace(/```/g, "");
  return t;
}


type Message = {
  sender: 'user' | 'ai';
  text: string;
};

type ChatPanelProps = {
  documentContent: string;
};

async function postJSON<T>(url: string, body: any): Promise<T> {
  const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
  if (!res.ok) { const err = await res.json().catch(() => ({})); throw new Error(err.error || `Request failed: ${res.status}`); }
  return res.json();
}

export default function ChatPanel({ documentContent }: ChatPanelProps) {
  const [history, setHistory] = useState<Message[]>([
    { sender: 'ai', text: "I'm your AI Tutor. Ask me anything about the content on the left!" }
  ]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [supportsStreaming, setSupportsStreaming] = useState(true);
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    const scrollContainer = scrollContainerRef.current;
    if (scrollContainer) {
      scrollContainer.scrollTop = scrollContainer.scrollHeight;
    }
  }, [history]);

  const autosize = () => {
    const el = inputRef.current;
    if (!el) return;
    el.style.height = 'auto';
    const max = 160; // px, ~5-6 lines
    el.style.height = Math.min(el.scrollHeight, max) + 'px';
  };
  useEffect(() => { autosize(); }, []);

  const handleSendMessage = async () => {
    if (!input.trim() || isLoading || !documentContent) {
        if (!documentContent) {
            setHistory(prev => [...prev, { sender: 'ai', text: 'Please analyze some content first before asking questions.'}]);
        }
        return;
    };

    const userMessage: Message = { sender: 'user', text: input };
    setHistory(prev => [...prev, userMessage]);
    setInput('');
    // reset height after clearing
    setTimeout(autosize, 0);
    setIsLoading(true);

    try {
      let model: string | undefined;
      try { model = localStorage.getItem('ai:model') || undefined; } catch {}

      if (supportsStreaming) {
        const qs = new URLSearchParams({ stream: '1' });
        const res = await fetch('/api/chat?' + qs.toString(), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userQuestion: userMessage.text, documentContent, model }),
        });
        if (!res.ok) throw new Error(`Request failed: ${res.status}`);

        // Add an empty AI message we will append to
        let aiIndex = -1;
        setHistory(prev => {
          aiIndex = prev.length;
          return [...prev, { sender: 'ai', text: '' }];
        });

        const reader = (res.body as ReadableStream<Uint8Array>)?.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        if (!reader) throw new Error('No stream reader');
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          let idx: number;
          while ((idx = buffer.indexOf('\n\n')) !== -1) {
            const event = buffer.slice(0, idx).trim();
            buffer = buffer.slice(idx + 2);
            if (!event.startsWith('data:')) continue;
            const json = event.slice(5).trim();
            let payload: any;
            try { payload = JSON.parse(json); } catch { continue; }
            if (payload?.type === 'chunk' && typeof payload.delta === 'string') {
              const delta = sanitizeMd(payload.delta);
              setHistory(prev => {
                const copy = prev.slice();
                const i = aiIndex >= 0 ? aiIndex : copy.length - 1;
                const current = copy[i];
                copy[i] = { ...current, text: (current?.text || '') + delta };
                return copy;
              });
            } else if (payload?.type === 'done') {
              // nothing extra
            } else if (payload?.type === 'error') {
              throw new Error(payload.error || 'stream error');
            }
          }
        }
      } else {
        const res = await postJSON<{ response: string; debug?: { model?: string; ms?: number } }>('/api/chat', {
          userQuestion: userMessage.text,
          documentContent,
          model,
        });
        const aiMessage: Message = { sender: 'ai', text: sanitizeMd(res.response) };
        setHistory(prev => [...prev, aiMessage]);
      }
    } catch (error) {
      const errorMessage: Message = { sender: 'ai', text: 'Sorry, I ran into an error. Please try again.' };
      setHistory(prev => [...prev, errorMessage]);
      // If streaming failed once, fallback next time
      setSupportsStreaming(false);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex flex-col h-full card">
      <header className="flex items-center justify-between p-4 border-b border-neutral-800/80">
        <h3 className="font-semibold text-lg">AI Tutor</h3>
      </header>

      <div ref={scrollContainerRef} className="flex-1 p-4 space-y-4 overflow-y-auto">
        {history.map((msg, index) => (
          <div key={index} className={`flex items-start gap-3 ${msg.sender === 'user' ? 'justify-end' : ''}`}>
            {msg.sender === 'ai' && <div className="flex-shrink-0 w-8 h-8 rounded-full bg-neutral-700 flex items-center justify-center"><Bot className="w-5 h-5" /></div>}
            <div className={`max-w-xs md:max-w-md rounded-lg px-3 py-2 ${msg.sender === 'user' ? 'bg-[rgb(var(--accent))] text-black' : 'bg-neutral-800'}`}>
              {msg.sender === 'ai' ? (
                <div className="markdown chat-md text-sm">
                  <ReactMarkdown remarkPlugins={[remarkGfm, remarkMath]} rehypePlugins={[rehypeKatex]}>
                    {msg.text}
                  </ReactMarkdown>
                </div>
              ) : (
                <p className="text-sm whitespace-pre-wrap">{msg.text}</p>
              )}
            </div>
            {msg.sender === 'user' && <div className="flex-shrink-0 w-8 h-8 rounded-full bg-neutral-700 flex items-center justify-center"><User className="w-5 h-5" /></div>}
          </div>
        ))}
        {isLoading && (
            <div className="flex items-start gap-3">
                <div className="flex-shrink-0 w-8 h-8 rounded-full bg-neutral-700 flex items-center justify-center"><Bot className="w-5 h-5" /></div>
                <div className="max-w-xs md:max-w-md rounded-lg px-4 py-2 bg-neutral-800 flex items-center">
                    <Loader2 className="w-5 h-5 animate-spin text-neutral-400" />
                </div>
            </div>
        )}
      </div>

      <footer className="p-4 border-t border-neutral-800">
        <div className="flex items-center gap-2">
          <textarea
            ref={inputRef}
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onInput={autosize}
            onKeyDown={(e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                }
            }}
            placeholder="Ask about the content..."
            className="input flex-1 pl-4 py-2 resize-none ring-1 ring-transparent focus:ring-[rgb(var(--accent))] bg-[rgba(var(--accent),0.12)] border border-[rgba(var(--accent),0.35)] placeholder:text-neutral-400"
            rows={1}
            style={{ minHeight: 44, maxHeight: 160, overflowY: 'auto' }}
            disabled={isLoading || !documentContent}
          />
          <button
            onClick={handleSendMessage}
            disabled={isLoading || !input.trim() || !documentContent}
            className="rounded-md bg-[rgb(var(--accent))] text-black disabled:opacity-50 h-[44px] w-[44px] md:h-[48px] md:w-[48px] flex items-center justify-center"
          >
            <Send className="w-4 h-4" />
          </button>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="src/app/api/lectures/[lectureId]/route.ts">
import { isSessionWithUser } from '@/lib/session-utils';
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { revalidateTag } from 'next/cache';
import { authOptions } from '@/lib/auth';

type Params = { lectureId: string };

export async function PATCH(req: NextRequest, ctx: { params: Promise<Params> }) {
  try {
    const session = await getServerSession(authOptions);
    if (!isSessionWithUser(session)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { lectureId } = await ctx.params;
    const userId = session.user.id;

    const body = await req.json().catch(() => ({} as any));
    const { title, starred } = body as { title?: string; starred?: boolean };
    const data: Record<string, any> = {};
    if (typeof title !== 'undefined') {
      if (!title || typeof title !== 'string' || title.trim().length < 3) {
        return NextResponse.json(
          { error: 'Title must be at least 3 characters' },
          { status: 400 }
        );
      }
      data.title = title.trim();
    }
    if (typeof starred !== 'undefined') {
      if (typeof starred !== 'boolean') {
        return NextResponse.json({ error: 'Invalid starred value' }, { status: 400 });
      }
      data.starred = starred;
    }
    if (Object.keys(data).length === 0) {
      return NextResponse.json({ error: 'No valid fields to update' }, { status: 400 });
    }

    const owned = await prisma.lecture.findFirst({
      where: { id: lectureId, userId },
      select: { id: true },
    });
    if (!owned) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 });
    }

    const updated = await prisma.lecture.update({
      where: { id: lectureId },
      data,
      select: { id: true, title: true, starred: true },
    });
    try { revalidateTag(`user-lectures:${userId}`); } catch {}
    try { revalidateTag(`user-stats:${userId}`); } catch {}
    return NextResponse.json({ ok: true, lecture: updated });
  } catch (e: any) {
    console.error('LECTURE_PATCH_ERROR', e);
    return NextResponse.json(
      { error: e?.message || 'Server error' },
      { status: 500 }
    );
  }
}

export async function DELETE(req: NextRequest, ctx: { params: Promise<Params> }) {
  try {
    const session = await getServerSession(authOptions);
    if (!isSessionWithUser(session)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { lectureId } = await ctx.params;
    const userId = session.user.id;

    // Ensure the lecture belongs to the current user
    const owned = await prisma.lecture.findFirst({
      where: { id: lectureId, userId },
      select: { id: true },
    });
    if (!owned) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 });
    }

    // Cascade deletes will remove related Subtopics, QuizQuestions, and UserMastery via Prisma schema
    await prisma.lecture.delete({ where: { id: lectureId } });
    try { revalidateTag(`user-lectures:${userId}`); } catch {}
    try { revalidateTag(`user-stats:${userId}`); } catch {}
    return NextResponse.json({ ok: true });
  } catch (e: any) {
    console.error('LECTURE_DELETE_ERROR', e);
    return NextResponse.json(
      { error: e?.message || 'Server error' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from 'next';
import ContentGate from "@/components/ContentGate";
import ClientBoundary from '@/components/ClientBoundary';
import AuthProvider from '@/components/AuthProvider';
import ModelSelector from '@/components/ModelSelector';
import Link from 'next/link';
import './globals.css';
import 'katex/dist/katex.min.css';
export const metadata: Metadata = {
  title: 'LearnMax — Your AI Study Companion',
  description: 'Master any subject by breaking complex lectures into focused steps, reviewing key insights, and advancing only when you master each concept.',
};
const navLinks = [
  { href: '/', label: 'Home' },
  { href: '/dashboard', label: 'Dashboard' },
  { href: '/learn', label: 'Learn' },
  { href: '/profile', label: 'Profile' },
];
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className="min-h-screen bg-neutral-950 text-neutral-100 antialiased">
        <AuthProvider>
          <header className="app-header py-6">
            <div className="container-narrow flex items-center justify-between">
              <Link href="/" className="text-xl font-semibold tracking-tight hover:opacity-90 transition-opacity">
                <span className="bg-gradient-to-r from-white via-neutral-200 to-neutral-400 bg-clip-text text-transparent">LearnMax</span>
              </Link>
              <nav className="flex items-center gap-4 text-sm text-neutral-300">
                {navLinks.map((link, index) => (
                  <Link key={index} href={link.href} className="hover:text-white transition-colors">
                    {link.label}
                  </Link>
                ))}
              </nav>
              <div className="flex items-center gap-3">
                <ModelSelector />
                <ClientBoundary />
              </div>
            </div>
          </header>
          <main className="py-10">{children}</main>
          <footer className="py-12 text-center text-sm text-neutral-500">
            Built with Next.js, Tailwind CSS, and Google Gemini.
          </footer>
        </AuthProvider>
        <ContentGate />
      </body>
    </html>
  );
}
</file>

<file path="src/app/api/quiz/route.ts">
// src/app/api/quiz/route.ts
import { NextResponse } from 'next/server';
import { generateJSON } from '@/lib/ai';
import prisma from '@/lib/prisma';

type RawQ = {
  question?: string;
  prompt?: string;
  options?: unknown;
  answerIndex?: unknown;
  explain?: string;
  explanation?: string;
};

type CleanQ = {
  prompt: string;
  options: string[];
  answerIndex: number;
  explanation: string;
};

// Clip helper to keep prompts bounded for latency and cost
function clip(text: string, max = 8000): string {
  const t = String(text || '').trim();
  return t.length > max ? t.slice(0, max) : t;
}

function toClean(q: RawQ): CleanQ | null {
  const prompt = String((q.prompt ?? q.question ?? '') || '').trim();
  const explanation = String((q.explanation ?? q.explain ?? '') || '').trim();
  const options = Array.isArray(q.options)
    ? q.options.map((o) => String(o ?? '').trim()).filter(Boolean)
    : [];
  const answerIndex = Number(q.answerIndex);
  if (!prompt || !explanation) return null;
  if (options.length !== 4) return null;
  if (!Number.isInteger(answerIndex) || answerIndex < 0 || answerIndex > 3) return null;
  return { prompt, options, answerIndex, explanation };
}

/* ------------------------ Grounding helpers ------------------------ */

const STOP = new Set([
  'the','a','an','and','or','of','for','to','in','on','at','by','is','are','was',
  'were','be','with','as','that','this','it','its','from','into','than','then',
  'but','not','if','any','all','no','one','two','there','their','between','you',
  'can','will','have','has','had','which'
]);

function words(s: string): string[] {
  return (s.toLowerCase().match(/[a-z0-9]+/g) || []);
}
function keywords(s: string, max = 12): string[] {
  const freq = new Map<string, number>();
  for (const w of words(s)) {
    if (w.length < 4 || STOP.has(w)) continue;
    freq.set(w, (freq.get(w) || 0) + 1);
  }
  return [...freq.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, max)
    .map(([w]) => w);
}

function containsNgramQuote(explanation: string, lesson: string, n = 4): boolean {
  // normalized, punctuation-free comparison
  const lw = words(lesson);
  const ew = words(explanation);
  if (lw.length < n || ew.length < n) return false;
  const eText = ew.join(' ');
  for (let i = 0; i <= lw.length - n; i++) {
    const gram = lw.slice(i, i + n).join(' ');
    if (gram.length >= 12 && eText.includes(gram)) return true;
  }
  return false;
}

function overlapCount(text: string, kws: string[]): number {
  const set = new Set(words(text));
  let c = 0;
  for (const k of kws) if (set.has(k)) c++;
  return c;
}

function isGrounded(q: CleanQ, lessonMd: string, kws: string[]): boolean {
  const text = [q.prompt, q.explanation, ...q.options].join(' ').toLowerCase();
  const hasKw = overlapCount(text, kws) >= Math.min(2, kws.length); // at least 2 keywords
  const hasQuote = containsNgramQuote(q.explanation, lessonMd, 3);
  return hasKw && hasQuote;
}

function scoreCandidate(q: CleanQ, lessonMd: string, kws: string[]): number {
  const text = [q.prompt, q.explanation, ...q.options].join(' ').toLowerCase();
  const kwScore = overlapCount(text, kws);
  const quoteScore = containsNgramQuote(q.explanation, lessonMd, 3) ? 3 : 0;
  // light penalty for true/false style
  const tfPenalty = q.options.join(' ').toLowerCase().includes('true') ? 1 : 0;
  return kwScore + quoteScore - tfPenalty;
}

/* -------------------- Single-correctness auditor (LLM) -------------------- */
async function hasExactlyOneCorrect(
  q: CleanQ,
  lessonMd: string,
  model: string,
): Promise<boolean> {
  const auditPrompt = `You are auditing a multiple-choice question for strict single-correctness.

Using ONLY the LESSON below, determine which options are strictly and unambiguously correct.

Return ONLY JSON:
{ "correctIndices": number[] }

Rules:
- Consider an option correct only if it is explicitly supported by the LESSON.
- If two options could both be correct, include both; do not force a single choice.
- If none is correct, return an empty array.

---
LESSON:
${lessonMd}
---
QUESTION:
${q.prompt}
OPTIONS (0-based):
${JSON.stringify(q.options, null, 2)}
`;
  const withTimeout = <T,>(p: Promise<T>, ms = 8000): Promise<T> =>
    Promise.race([
      p,
      new Promise<T>((_, rej) => setTimeout(() => rej(new Error('timeout')), ms)),
    ]);
  try {
    const res = await withTimeout(generateJSON(auditPrompt, model));
    const arr = Array.isArray(res?.correctIndices)
      ? res.correctIndices
          .map((n: any) => Number(n))
          .filter((n: any) => Number.isInteger(n) && n >= 0 && n < q.options.length)
      : [];
    if (arr.length !== 1) return false;
    return arr[0] === q.answerIndex;
  } catch {
    return false;
  }
}

/* Deterministic fallback: builds a grounded T/F MCQ from the lesson text */
function pickDeclarativeSentence(md: string): string | null {
  // Split on sentence-ish boundaries and pick something medium length
  const pieces = (md.replace(/\s+/g, ' ').trim().match(/[^.?!]+[.?!]/g) || [])
    .map(s => s.trim());
  const candidates = pieces.filter(s => {
    const wc = words(s).length;
    return wc >= 8 && wc <= 24 && !/:$/.test(s);
  });
  return candidates[0] || pieces[0] || null;
}
// Fallback completely disabled for quality: if no acceptable question, return 422

/* ------------------------------ Route ------------------------------ */

export async function POST(req: Request) {
  try {
    const body = await req.json().catch(() => ({}));
    const t0 = Date.now();
    const preferredModel =
      typeof (body as any)?.model === 'string' && (body as any).model.trim()
        ? ((body as any).model as string).trim()
        : undefined;
    const modelForQuiz = preferredModel || 'gemini-2.5-flash';
    let lessonMd = String(body?.lessonMd || '').trim();
    const subtopicTitle = String(body?.subtopicTitle || '').trim();
    const lectureId = String((body as any)?.lectureId || '').trim();
    const overview = String((body as any)?.overview || '').trim();
    const difficulty = String(body?.difficulty || 'hard').toLowerCase();

    // If lesson is short, try to augment from server-side stored original content using lectureId
    if (lessonMd.length < 50 && lectureId) {
      try {
        const lec = await prisma.lecture.findUnique({ where: { id: lectureId }, select: { originalContent: true } });
        const original = String(lec?.originalContent || '').trim();
        const composite = [overview, lessonMd, original].filter(Boolean).join('\n\n');
        if (composite.length >= 50) lessonMd = composite;
      } catch {}
    }
    if (lessonMd.length < 50) {
      return NextResponse.json({ error: 'lessonMd (≥50 chars) is required' }, { status: 400 });
    }

    const kws = keywords(lessonMd, 12);
    const kwHint = kws.length ? `Use the lesson’s domain. Keywords you should naturally touch: ${kws.slice(0, 8).join(', ')}.` : '';

    const rigor =
      difficulty === 'hard'
        ? 'Make it application-level with a subtle trap for superficial readers.'
        : 'Keep it focused and fair, not trivial.';

    const basePrompt = `
You are an exacting exam writer. Using ONLY the LESSON MARKDOWN below, write exactly ONE multiple-choice question ${subtopicTitle ? `that specifically tests the subtopic "${subtopicTitle}".` : 'about its core idea.'}

Return ONE JSON object in this shape:
{
  "questions": [
    { "prompt": "string", "options": ["A","B","C","D"], "answerIndex": 0, "explanation": "string" }
  ]
}

Rules:
- ${rigor}
- ${kwHint}
- In the explanation, include a short DIRECT quote (6–12 words) from the lesson, in "double quotes". The quote must be verbatim and not generic filler.
- Do NOT invent facts not supported by the lesson.
- Do NOT prefix options with letters or numbers.
- Exactly four options. Correct answer index must be 0..3.
- Exactly ONE option must be correct; the other three must be clearly incorrect given the LESSON.
- Avoid ambiguous, overlapping, or "All/None of the above" answers.
- Prefer conceptual or applied questions over trivial factual restatement.

Context hints to avoid triviality:
- Do not ask "is this sentence true" questions.
- Avoid simply echoing a single sentence; synthesize across two or more details where possible.

---
LESSON MARKDOWN (truncated):
${clip(lessonMd, 6000)}
---`.trim();

    const withTimeout = <T,>(p: Promise<T>, ms = 20000): Promise<T> =>
      Promise.race([
        p,
        new Promise<T>((_, rej) => setTimeout(() => rej(new Error('timeout')), ms)),
      ]);

    // First attempt (with timeout)
    let attempt1Ms = 0; let timedOut1 = false;
    let json: any = {};
    try {
      const a0 = Date.now();
      json = await withTimeout(generateJSON(basePrompt, modelForQuiz));
      attempt1Ms = Date.now() - a0;
    } catch (e: any) {
      attempt1Ms = attempt1Ms || 0;
      timedOut1 = String(e?.message || '').toLowerCase().includes('timeout');
      json = {} as any;
    }
    let raw = Array.isArray(json?.questions) ? json.questions : [];
    let cleaned = raw.map(toClean).filter(Boolean) as CleanQ[];
    const cleaned1 = cleaned.slice();
    const initiallyGrounded = cleaned.filter((q) => isGrounded(q, lessonMd, kws));
    // Enforce exactly-one-correct via a dedicated auditor (parallelized)
    let auditMs = 0;
    let grounded: CleanQ[] = [];
    if (initiallyGrounded.length) {
      const auditStart = Date.now();
      const results = await Promise.allSettled(
        initiallyGrounded.map((q) => hasExactlyOneCorrect(q, lessonMd, modelForQuiz)),
      );
      auditMs += Date.now() - auditStart;
      grounded = initiallyGrounded.filter((_, i) => results[i].status === 'fulfilled' && (results[i] as PromiseFulfilledResult<boolean>).value);
    }

    // Retry if nothing passed audit
    if (!grounded.length) {
      const retryPrompt = `
Your previous attempt was rejected for not being grounded in the LESSON.
Try again and follow these STRICT requirements:

- The question and explanation MUST be consistent with the LESSON only.
- Include at least TWO of these keywords in the prompt or explanation: ${kws.join(', ')}.
- In the explanation, include one exact quote (6–12 words) from the LESSON in "double quotes". The quote must be verbatim.
 - Exactly ONE option must be correct; ensure the other three are unambiguously incorrect.
 - Do NOT use "All of the above" or "None of the above".
 - Do NOT produce a boolean true/false wrapper around a copied sentence.
 - Prefer a question that requires understanding a relationship, mechanism, or constraint stated in the lesson.

Return ONLY the same JSON shape as before.

      ---
      LESSON MARKDOWN (truncated):
      ${clip(lessonMd, 8000)}
      ---`.trim();

      let attempt2Ms = 0; let timedOut2 = false;
      try {
        const b0 = Date.now();
        json = await withTimeout(generateJSON(retryPrompt, modelForQuiz));
        attempt2Ms = Date.now() - b0;
      } catch (e: any) {
        attempt2Ms = attempt2Ms || 0;
        timedOut2 = String(e?.message || '').toLowerCase().includes('timeout');
        json = {} as any;
      }
      raw = Array.isArray(json?.questions) ? json.questions : [];
      cleaned = raw.map(toClean).filter(Boolean) as CleanQ[];
      const cleaned2 = cleaned.slice();
      const groundedRetry = cleaned.filter((q) => isGrounded(q, lessonMd, kws));
      if (groundedRetry.length) {
        const auditStart2 = Date.now();
        const results2 = await Promise.allSettled(
          groundedRetry.map((q) => hasExactlyOneCorrect(q, lessonMd, modelForQuiz)),
        );
        auditMs += Date.now() - auditStart2;
        const auditedRetry = groundedRetry.filter((_, i) => results2[i].status === 'fulfilled' && (results2[i] as PromiseFulfilledResult<boolean>).value);
        grounded = auditedRetry.length ? auditedRetry : [];
      } else {
        grounded = [];
      }
      const msTotal = Date.now() - t0;
      if (!grounded.length) {
        return NextResponse.json({ error: 'no_acceptable_question', debug: { model: modelForQuiz, ms: msTotal, auditMs, attempt1Ms, attempt2Ms, timedOut1, timedOut2, cleaned1: cleaned1.length, grounded1: initiallyGrounded.length, cleaned2: cleaned2.length, grounded2: groundedRetry.length } }, { status: 422 });
      }
    }

    // Decide acceptance path and return
    if (!grounded.length) {
      return NextResponse.json({ error: 'no_acceptable_question', debug: { model: modelForQuiz, ms: Date.now() - t0, auditMs, attempt1Ms, timedOut1, cleaned1: cleaned.length, grounded1: initiallyGrounded.length } }, { status: 422 });
    }

    // Keep just one good question (already audited)
    const acceptPath = 'audited';
    return NextResponse.json({ questions: [grounded[0]], debug: { model: modelForQuiz, ms: Date.now() - t0, auditMs, accepted: acceptPath, attempt1Ms, timedOut1, cleaned1: cleaned?.length || 0, grounded1: initiallyGrounded?.length || 0 } });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'quiz failed' }, { status: 500 });
  }
}
</file>

<file path="src/app/page.tsx">
'use client';

import Link from 'next/link';
import { BrainCircuit, Target, FileSearch } from 'lucide-react';
import { useEffect } from 'react';
import { useRouter } from 'next/navigation';

const PillarCard = ({
  icon: Icon,
  title,
  children,
}: {
  icon: React.ElementType;
  title: string;
  children: React.ReactNode;
}) => (
  <div className="flex flex-col text-left gap-3 p-5 rounded-lg border border-neutral-800 bg-neutral-900/50 h-full">
    <div className="flex items-center gap-3">
      <div className="flex-shrink-0 flex h-9 w-9 items-center justify-center rounded-md bg-neutral-700/50 text-white">
        <Icon className="w-5 h-5" />
      </div>
      <h3 className="text-md font-semibold">{title}</h3>
    </div>
    <p className="text-sm text-neutral-400 leading-relaxed">
      {children}
    </p>
  </div>
);

export default function HomePage() {
  // Prevent body scroll while on home page
  useEffect(() => {
    const prev = document.body.getAttribute('data-page');
    document.body.setAttribute('data-page', 'home');
    return () => {
      if (prev) document.body.setAttribute('data-page', prev);
      else document.body.removeAttribute('data-page');
    };
  }, []);
  function PrefetchRoutes() {
    const router = useRouter();
    useEffect(() => {
      ['/dashboard', '/learn'].forEach((r) => {
        try { router.prefetch(r); } catch {}
      });
    }, [router]);
    return null;
  }
  return (
    <div className="container-narrow" style={{ minHeight: 'calc(100svh - 120px)' }}>
      <PrefetchRoutes />
      <div className="flex flex-col items-center justify-center text-center min-h-[calc(100svh-160px)] max-w-6xl mx-auto">
        <div className="w-full">
          <h1 className="text-4xl md:text-5xl font-bold tracking-tight text-transparent bg-clip-text bg-gradient-to-b from-white via-neutral-200 to-neutral-400 leading-[1.18] md:leading-[1.14] lg:leading-[1.12] pb-1.5">
            The Science of Learning, Perfected by AI.
          </h1>
          <p className="mt-4 max-w-3xl mx-auto text-base md:text-lg text-neutral-300">
            Stop wasting hours on inefficient rereading. LearnMax applies proven cognitive science to build a hyper-efficient study path, ensuring you master every concept with minimal time and effort.
          </p>
          <div className="mt-8 flex items-center justify-center gap-3">
    <Link
      href="/learn"
      className="btn-primary shadow-lg hover:scale-105"
    >
      Optimize Your First Lecture
    </Link>
   
  </div>
        </div>
        <div className="w-full mt-12">
          <div className="grid gap-5 md:grid-cols-3">
            <PillarCard icon={FileSearch} title="AI Deconstruction">
              Our models find the optimal learning path through dense material, so you study the right concepts in the right order.
            </PillarCard>
            <PillarCard icon={BrainCircuit} title="Guided Mastery Learning">
              Based on proven science, you focus on one core idea at a time. This prevents cognitive overload and embeds knowledge effectively.
            </PillarCard>
            <PillarCard icon={Target} title="Verified Comprehension">
              Pass a targeted quiz to prove you&apos;ve mastered the concept. This guarantees a rock-solid foundation for lasting knowledge.
            </PillarCard>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #0a0a0a;
  --foreground: #ededed;
}

body {
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Design tokens */
:root {
  --accent: 34 197 94;
  --bg: 10 10 10;
  --panel: 23 23 23;
  --border: 38 38 38;
  --muted: 163 163 163;
}

body {
  background: radial-gradient(120% 80% at 20% -10%, rgba(34, 197, 94, 0.06) 0%, rgba(0,0,0,0) 50%), rgb(var(--bg));
  /* Prevent the radial gradient from tiling, which causes repeating green bands */
  background-repeat: no-repeat, no-repeat;
  /* Keep the gradient anchored to the viewport */
  background-attachment: fixed, fixed;
  /* Make the gradient cover the viewport width; keep the base color layer auto */
  background-size: 160% 100%, auto;
  color: rgb(245 245 245);
}
html, body { height: 100%; }

.container-narrow {
  @apply mx-auto max-w-5xl px-4 md:px-6;
}

.container-wide {
  @apply mx-auto max-w-[1600px] px-6 md:px-8;
}

/* UI primitives */
.card { background: rgba(var(--panel), 0.7); border: 1px solid rgb(var(--border)); border-radius: 14px; }
.btn { @apply inline-flex items-center justify-center gap-2 rounded-md px-4 py-2 text-sm font-medium transition-all; }
.btn-primary { @apply inline-flex items-center justify-center gap-2 rounded-md px-4 py-2 text-sm font-medium transition-all; color: #020617; background: rgb(var(--accent)); box-shadow: 0 4px 14px rgba(34, 197, 94, 0.16), 0 0 24px rgba(34, 197, 94, 0.24), 0 -4px 14px rgba(34, 197, 94, 0.18); }
.btn-primary:hover { filter: brightness(1.04); transform: translateY(-0.5px); box-shadow: 0 6px 18px rgba(34, 197, 94, 0.18), 0 0 36px rgba(34, 197, 94, 0.30), 0 -6px 18px rgba(34, 197, 94, 0.22); }
.btn-ghost { @apply inline-flex items-center justify-center gap-2 rounded-md px-4 py-2 text-sm font-medium transition-all border border-neutral-700/60 text-neutral-200; }
.btn-ghost:hover { @apply bg-neutral-800/60; }
.input { @apply w-full rounded-md bg-neutral-900/80 px-3 py-2 ring-1 ring-neutral-700 outline-none text-sm; }
.muted { color: rgb(var(--muted)); }

/* Compact markdown for chat bubbles */
.chat-md p, .chat-md ul, .chat-md ol { margin-top: 0.25rem; margin-bottom: 0.25rem; }
.chat-md p:first-child, .chat-md ul:first-child, .chat-md ol:first-child { margin-top: 0; }
.chat-md p:last-child, .chat-md ul:last-child, .chat-md ol:last-child { margin-bottom: 0; }

/* Size modifiers */
.btn-xl { @apply text-lg px-6 py-3; }

/* BEGIN markdown-typography (Tailwind v4 safe) */
.markdown {
  color: rgb(229 229 229); /* neutral-200 */
  line-height: 1.75;
}
.markdown h2 {
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid rgb(38 38 38); /* neutral-800 */
  padding-bottom: 0.5rem;
  font-size: 1.5rem;
  font-weight: 700;
}
.markdown h3 {
  margin-top: 2rem;
  margin-bottom: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
}
.markdown p,
.markdown ul,
.markdown ol,
.markdown pre {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.markdown code {
  color: rgb(103 232 249); /* cyan-300 */
}
.markdown pre {
  background: rgba(38, 38, 38, 0.5);
  border: 1px solid rgb(38 38 38);
  border-radius: 0.5rem;
  padding: 1rem;
  overflow-x: auto;
}
.markdown ul {
  list-style: disc;
  padding-left: 1.25rem;
}
.markdown ol {
  list-style: decimal;
  padding-left: 1.25rem;
}
.markdown li::marker {
  color: rgb(115 115 115); /* neutral-500 */
}
/* END markdown-typography (Tailwind v4 safe) */

/* BEGIN markdown-typography (Tailwind v4 safe) */
.markdown {
  color: rgb(229 229 229);
  line-height: 1.75;
}
.markdown h2 {
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid rgb(38 38 38);
  padding-bottom: 0.5rem;
  font-size: 1.5rem;
  font-weight: 700;
}
.markdown h3 {
  margin-top: 2rem;
  margin-bottom: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
}
.markdown p,
.markdown ul,
.markdown ol,
.markdown pre {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.markdown code {
  color: rgb(103 232 249);
}
.markdown pre {
  background: rgba(38, 38, 38, 0.5);
  border: 1px solid rgb(38, 38, 38);
  border-radius: 0.5rem;
  padding: 1rem;
  overflow-x: auto;
}
.markdown ul {
  list-style: disc;
  padding-left: 1.25rem;
}
.markdown ol {
  list-style: decimal;
  padding-left: 1.25rem;
}
.markdown li::marker {
  color: rgb(115, 115, 115);
}
/* END markdown-typography (Tailwind v4 safe) */

/* BEGIN markdown-typography (Tailwind v4 safe) */
.markdown {
  color: rgb(229 229 229);
  line-height: 1.75;
}
.markdown h2 {
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid rgb(38 38 38);
  padding-bottom: 0.5rem;
  font-size: 1.5rem;
  font-weight: 700;
}
.markdown h3 {
  margin-top: 2rem;
  margin-bottom: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
}
.markdown p,
.markdown ul,
.markdown ol,
.markdown pre {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.markdown code {
  color: rgb(103 232 249);
}
.markdown pre {
  background: rgba(38, 38, 38, 0.5);
  border: 1px solid rgb(38, 38, 38);
  border-radius: 0.5rem;
  padding: 1rem;
  overflow-x: auto;
}
.markdown ul {
  list-style: disc;
  padding-left: 1.25rem;
}
.markdown ol {
  list-style: decimal;
  padding-left: 1.25rem;
}
.markdown li::marker {
  color: rgb(115, 115, 115);
}
/* END markdown-typography (Tailwind v4 safe) */

/* BEGIN markdown-typography (Tailwind v4 safe) */
.markdown {
  color: rgb(229 229 229);
  line-height: 1.75;
}
.markdown h2 {
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid rgb(38 38 38);
  padding-bottom: 0.5rem;
  font-size: 1.5rem;
  font-weight: 700;
}
.markdown h3 {
  margin-top: 2rem;
  margin-bottom: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
}
.markdown p,
.markdown ul,
.markdown ol,
.markdown pre {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.markdown code {
  color: rgb(103 232 249);
}
.markdown pre {
  background: rgba(38, 38, 38, 0.5);
  border: 1px solid rgb(38, 38, 38);
  border-radius: 0.5rem;
  padding: 1rem;
  overflow-x: auto;
}
.markdown ul {
  list-style: disc;
  padding-left: 1.25rem;
}
.markdown ol {
  list-style: decimal;
  padding-left: 1.25rem;
}
.markdown li::marker {
  color: rgb(115, 115, 115);
}
/* END markdown-typography (Tailwind v4 safe) */

/* BEGIN markdown-typography (Tailwind v4 safe) */
.markdown {
  color: rgb(229 229 229);
  line-height: 1.75;
}
.markdown h2 {
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid rgb(38 38 38);
  padding-bottom: 0.5rem;
  font-size: 1.5rem;
  font-weight: 700;
}
.markdown h3 {
  margin-top: 2rem;
  margin-bottom: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
}
.markdown p,
.markdown ul,
.markdown ol,
.markdown pre {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.markdown code {
  color: rgb(103 232 249);
}
.markdown pre {
  background: rgba(38, 38, 38, 0.5);
  border: 1px solid rgb(38, 38, 38);
  border-radius: 0.5rem;
  padding: 1rem;
  overflow-x: auto;
}
.markdown ul {
  list-style: disc;
  padding-left: 1.25rem;
}
.markdown ol {
  list-style: decimal;
  padding-left: 1.25rem;
}
.markdown li::marker {
  color: rgb(115, 115, 115);
}
/* END markdown-typography (Tailwind v4 safe) */

/* Wider container for Learn page */
.container-wide {
  @apply mx-auto max-w-[1600px] px-6 md:px-8;
}

/* learnmax-quiz-gate */
/* learnmax-quiz-gate */

/* learnmax-quiz-gate (fixed) */
body:not([data-content="ready"]) .quiz-panel { display: none; }

/* quiz gate */
body:not([data-content="ready"]) .quiz-panel { display: none; }
body[data-content="ready"] .quiz-panel { display: block !important; }

/* quiz gate */
body:not([data-content="ready"]) .quiz-panel { display: none; }
body[data-content="ready"] .quiz-panel { display: block !important; }

/* learnmax-complete-noscroll */
/* Only while the completion page is mounted */
body[data-page="complete"] { overflow: hidden !important; overscroll-behavior: contain; }
body[data-page="complete"] footer { display: none !important; }

/* Home page: disable scroll */
body[data-page="home"] { overflow: hidden !important; overscroll-behavior: none; }
</file>

<file path="src/app/learn/page.tsx">
// 'use client' makes this a valid client component with a default export.
'use client';

import { useRef, useState } from 'react';
import { createLectureFromPdf } from '@/lib/client/lectures';

async function createLectureFromText(
  content: string
): Promise<{ lectureId: string }> {
  let model: string | undefined;
  try { model = localStorage.getItem('ai:model') || undefined; } catch {}
  const res = await fetch('/api/lectures', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content, model }),
  });
  if (!res.ok) {
    const e = await res.json().catch(() => ({}));
    throw new Error(e.error || `Failed: ${res.status}`);
  }
  return res.json();
}

export default function LearnWorkspacePage() {
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);
  const [uploading, setUploading] = useState(false);
  const [dragOver, setDragOver] = useState(false);
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  const handleCreate = async () => {
    const text = input.trim();
    if (!text || loading) return;
    setLoading(true);
    setErr(null);
    try {
      const { lectureId } = await createLectureFromText(text);
      window.location.href = `/learn/${lectureId}`;
    } catch (e: any) {
      setErr(e.message || 'Failed to create lecture.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container-narrow space-y-6">
      <header>
        <h1 className="text-2xl font-bold tracking-tight">Learn Workspace</h1>
        <p className="text-sm text-neutral-400">
          Paste text and create a persistent lecture. You’ll be redirected to
          the lecture page with explanations and quizzes.
        </p>
      </header>

      <div className="space-y-4 card p-5">
        <textarea
          className="min-h-[160px] input"
          placeholder="What do you want to learn about? Paste any study notes or PDF lecture slides here"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          disabled={loading}
        />
        <div className="flex gap-2">
          <button
            onClick={handleCreate}
            disabled={loading || !input.trim()}
            className="btn-primary disabled:opacity-50"
          >
            {loading || uploading ? 'Analysing Content…' : 'Create Lecture'}
          </button>
          <button
            onClick={() => setInput('')}
            disabled={loading}
            className="btn-ghost disabled:opacity-50"
          >
            Reset
          </button>
        </div>

        {/* Upload PDF */}
        <div className="pt-2">
          <div
            className={`rounded-md border-2 border-dashed p-6 text-center transition-colors ${
              dragOver ? 'border-[rgb(var(--accent))] bg-[rgba(var(--accent),0.06)]' : 'border-neutral-700'
            }`}
            onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
            onDragLeave={() => setDragOver(false)}
            onDrop={async (e) => {
              e.preventDefault(); setDragOver(false);
              const f = e.dataTransfer.files?.[0];
              if (!f) return;
              if (!/pdf$/i.test(f.name)) { setErr('Please drop a single PDF file.'); return; }
              try {
                setUploading(true); setErr(null);
                const { lectureId } = await createLectureFromPdf(f);
                window.location.href = `/learn/${lectureId}`;
              } catch (e: any) {
                setErr(e.message || 'Upload failed');
              } finally { setUploading(false); }
            }}
          >
            <p className="text-sm text-neutral-300">Drag & drop a PDF here to create a lecture</p>
            <div className="mt-3 flex items-center justify-center gap-2">
              <input ref={fileInputRef} type="file" accept="application/pdf" className="hidden" onChange={async (e) => {
                const f = e.target.files?.[0];
                if (!f) return;
                try {
                  setUploading(true); setErr(null);
                  const { lectureId } = await createLectureFromPdf(f);
                  window.location.href = `/learn/${lectureId}`;
                } catch (e: any) {
                  setErr(e.message || 'Upload failed');
                } finally { setUploading(false); if (fileInputRef.current) fileInputRef.current.value = ''; }
              }} />
              <button
                type="button"
                className="btn-ghost"
                onClick={() => fileInputRef.current?.click()}
                disabled={uploading}
              >
                {uploading ? 'Uploading…' : 'Upload PDF'}
              </button>
            </div>
          </div>
        </div>
        {err && (
          <div className="text-sm text-red-400" role="alert">
            {err}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/lib/ai.ts">
// src/lib/ai.ts
import { GoogleGenerativeAI } from '@google/generative-ai';
import OpenAI from 'openai';

/**
 * Primary/default model, preferring explicitly configured OpenAI model
 * if present, otherwise falling back to configured Gemini model, and then
 * a sensible Gemini default. This value is only used when a caller doesn't
 * pass an explicit preferredModel.
 */
export const PRIMARY_MODEL =
  (process.env.OPENAI_MODEL?.trim()) ||
  (process.env.GEMINI_MODEL?.trim()) ||
  'gemini-2.5-flash';

// Lazy-init clients so we don't require both providers to be configured.
let googleClient: GoogleGenerativeAI | null = null;
let openaiClient: OpenAI | null = null;

function getGoogleClient(): GoogleGenerativeAI {
  if (!googleClient) {
    const key = process.env.GOOGLE_API_KEY;
    if (!key) throw new Error('GOOGLE_API_KEY is not set. Add it to .env.local.');
    googleClient = new GoogleGenerativeAI(key);
  }
  return googleClient;
}

function getOpenAIClient(): OpenAI {
  if (!openaiClient) {
    const key = process.env.OPENAI_API_KEY;
    if (!key) throw new Error('OPENAI_API_KEY is not set. Add it to .env.local.');
    openaiClient = new OpenAI({ apiKey: key });
  }
  return openaiClient;
}

function isOpenAIModel(name: string | undefined): boolean {
  if (!name) return false;
  const n = name.trim().toLowerCase();
  return n.startsWith('gpt-') || n.startsWith('openai:');
}

function normalizeModelId(name: string): string {
  // Allow an explicit provider prefix like "openai:gpt-5"
  const idx = name.indexOf(':');
  return idx > -1 ? name.slice(idx + 1) : name;
}

function isGPT5Mini(name: string | undefined): boolean {
  if (!name) return false;
  const id = normalizeModelId(name).toLowerCase();
  return id.startsWith('gpt-5-mini');
}

function tryParseJson(s: string): any | null { try { return JSON.parse(s); } catch { return null; } }

function extractFromCodeFence(text: string): string | null {
  const m = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
  return m ? m[1].trim() : null;
}

function extractFirstJSONObject(text: string): string | null {
  let depth = 0, start = -1, inString = false, esc = false;
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (inString) {
      if (esc) { esc = false; continue; }
      if (ch === '\\') { esc = true; continue; }
      if (ch === '"') { inString = false; }
      continue;
    }
    if (ch === '"') { inString = true; continue; }
    if (ch === '{') { if (depth === 0) start = i; depth++; continue; }
    if (ch === '}') { if (depth > 0 && --depth === 0 && start >= 0) return text.slice(start, i + 1); }
  }
  return null;
}

const L = process.env.LOG_AI === '1';
const log = (...a: any[]) => { if (L) console.log('[ai]', ...a); };

function buildFallbackList(preferredModel?: string): string[] {
  const list: string[] = [];
  const base = preferredModel?.trim() || PRIMARY_MODEL;
  list.push(base);
  if (isOpenAIModel(base)) {
    // Only allow GPT-5 Mini as the OpenAI fallback option
    list.push('gpt-5-mini');
  } else {
    // Gemini fallbacks
    list.push('gemini-2.5-pro');
    list.push('gemini-2.0-pro');
    list.push('gemini-2.5-flash-lite');
    list.push('gemini-2.0-flash');
  }
  return Array.from(new Set(list));
}

async function generateTextWithGemini(prompt: string, modelName: string): Promise<string> {
  const client = getGoogleClient();
  const model = client.getGenerativeModel({ model: modelName });
  const result = await model.generateContent(prompt);
  const text = result.response?.text?.();
  if (text && text.trim()) return text;
  const parts: string[] = [];
  const candidates = (result.response as any)?.candidates ?? [];
  for (const c of candidates) {
    const p = c?.content?.parts ?? [];
    for (const part of p) if (typeof part?.text === 'string' && part.text.trim()) parts.push(part.text.trim());
  }
  if (parts.length) return parts.join('\n\n');
  throw new Error(`Empty response from ${modelName}`);
}

async function generateTextWithOpenAI(prompt: string, modelName: string): Promise<string> {
  const openai = getOpenAIClient();
  const model = normalizeModelId(modelName);
  const params: any = {
    model,
    messages: [ { role: 'user', content: prompt } ],
  };
  if (!isGPT5Mini(model)) {
    params.temperature = 0.2;
  }
  const completion = await openai.chat.completions.create(params);
  const content = completion.choices?.[0]?.message?.content || '';
  if (content && content.trim()) return content;
  throw new Error(`Empty response from ${model}`);
}

export async function generateText(prompt: string, preferredModel?: string): Promise<string> {
  const names = buildFallbackList(preferredModel);
  let lastErr: any;
  for (const name of names) {
    try {
      const t = isOpenAIModel(name)
        ? await generateTextWithOpenAI(prompt, name)
        : await generateTextWithGemini(prompt, name);
      log('ok', name, t.length);
      return t;
    } catch (e: any) {
      lastErr = e;
      continue;
    }
  }
  throw new Error('The AI returned an empty response. ' + (lastErr?.message || ''));
}

export async function generateJSON(prompt: string, preferredModel?: string): Promise<any> {
  const names = buildFallbackList(preferredModel);
  let lastErr: any;
  for (const name of names) {
    try {
      if (isOpenAIModel(name)) {
        const openai = getOpenAIClient();
        const model = normalizeModelId(name);
        const params: any = {
          model,
          messages: [ { role: 'user', content: prompt } ],
        };
        if (!isGPT5Mini(model)) {
          params.temperature = 0;
          params.response_format = { type: 'json_object' };
        }
        const completion = await openai.chat.completions.create(params);
        const text = completion.choices?.[0]?.message?.content || '';
        if (text && text.trim()) {
          const parsed = tryParseJson(text);
          if (parsed !== null) return parsed;
        }
        lastErr = new Error(`Empty/invalid JSON from ${model}`);
        continue;
      } else {
        const client = getGoogleClient();
        const model = client.getGenerativeModel({
          model: name,
          generationConfig: { responseMimeType: 'application/json' },
        });
        const result = await model.generateContent(prompt);
        const text = result.response?.text?.();
        if (text && text.trim()) {
          const direct = tryParseJson(text); if (direct !== null) return direct;
          const fenced = extractFromCodeFence(text); if (fenced) {
            const p = tryParseJson(fenced); if (p !== null) return p;
          }
          const obj = extractFirstJSONObject(text); if (obj) {
            const p = tryParseJson(obj); if (p !== null) return p;
          }
        }
        const parts: string[] = [];
        const candidates = (result.response as any)?.candidates ?? [];
        for (const c of candidates) {
          const p = c?.content?.parts ?? [];
          for (const part of p) if (typeof part?.text === 'string' && part.text.trim()) parts.push(part.text.trim());
        }
        for (const p of parts) {
          const direct = tryParseJson(p); if (direct !== null) return direct;
          const fenced = extractFromCodeFence(p); if (fenced) {
            const pf = tryParseJson(fenced); if (pf !== null) return pf;
          }
          const obj = extractFirstJSONObject(p); if (obj) {
            const pb = tryParseJson(obj); if (pb !== null) return pb;
          }
        }
        lastErr = new Error(`Empty/invalid JSON from ${name}`);
        continue;
      }
    } catch (e: any) {
      lastErr = e;
      continue;
    }
  }
  throw new Error('The AI failed to generate JSON. ' + (lastErr?.message || ''));
}

/**
 * Stream text chunks from the model as they are generated.
 * Yields incremental text segments (may be partial tokens or sentences).
 */
export async function* streamTextChunks(
  prompt: string,
  preferredModel?: string,
): AsyncGenerator<string, void, void> {
  const names = buildFallbackList(preferredModel);
  let lastErr: any;

  for (const name of names) {
    try {
      if (isOpenAIModel(name)) {
        const openai = getOpenAIClient();
        const model = normalizeModelId(name);
        // GPT-5 Mini currently may not support streaming for some orgs; simulate streaming by
        // falling back to a single non-streaming generation to keep the SSE contract alive.
        if (isGPT5Mini(model)) {
          const text = await generateText(prompt, name);
          if (text) { yield text; }
          return;
        }
        const params: any = {
          model,
          messages: [ { role: 'user', content: prompt } ],
          stream: true,
        };
        if (!isGPT5Mini(model)) {
          params.temperature = 0.2;
        }
        const stream: any = await openai.chat.completions.create(params);
        let yielded = false;
        for await (const part of stream) {
          const delta: string | undefined = part?.choices?.[0]?.delta?.content;
          if (delta && delta.trim()) { yield delta; yielded = true; }
        }
        if (!yielded) {
          // Fallback to non-streaming single shot
          const text = await generateText(prompt, name);
          if (text) { yield text; }
        }
        return;
      } else {
        const client = getGoogleClient();
        const model = client.getGenerativeModel({ model: name });
        const result: any = await (model as any).generateContentStream(prompt);
        if (!result?.stream || typeof result.stream[Symbol.asyncIterator] !== 'function') {
          const text = await generateText(prompt, name);
          if (text) { yield text; return; }
          continue;
        }
        for await (const chunk of result.stream) {
          try {
            const textPart = typeof chunk?.text === 'function' ? chunk.text() : '';
            if (textPart && textPart.trim()) { yield textPart; }
          } catch {}
        }
        return;
      }
    } catch (e: any) {
      lastErr = e;
      continue;
    }
  }
  throw new Error('The AI failed to stream a response. ' + (lastErr?.message || ''));
}
</file>

<file path="package.json">
{
  "name": "learnmax",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "migrate:deploy": "prisma migrate deploy || prisma db push",
    "build": "pnpm run migrate:deploy && next build --no-lint",
    "start": "next start",
    "lint": "next lint",
    "postinstall": "prisma generate"
  },
  "dependencies": {
    "@auth/prisma-adapter": "^2.10.0",
    "@google/generative-ai": "^0.24.1",
    "@prisma/client": "^6.13.0",
    "@vercel/blob": "^1.1.1",
    "katex": "^0.16.22",
    "lucide-react": "^0.536.0",
    "next": "15.4.5",
    "next-auth": "^4.24.7",
    "openai": "^5.12.2",
    "pdf-extraction": "^1.0.2",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-markdown": "^10.1.0",
    "rehype-katex": "^7.0.1",
    "remark-gfm": "^4.0.1",
    "remark-math": "^6.0.0",
    "zustand": "^5.0.7"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4.1.11",
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.4.5",
    "prettier": "^3.6.2",
    "prettier-plugin-tailwindcss": "^0.6.14",
    "prisma": "^6.13.0",
    "tailwindcss": "^4",
    "typescript": "^5"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "@prisma/client",
      "@prisma/engines",
      "prisma"
    ]
  }
}
</file>

<file path="src/app/api/lectures/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import pdf from 'pdf-extraction';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { GoogleAIFileManager } from '@google/generative-ai/server';
import prisma from '@/lib/prisma';
import { requireSession } from '@/lib/auth';
import { generateJSON, generateText } from '@/lib/ai';
import { isSessionWithUser } from '@/lib/session-utils';
import { bumpDailyStreak } from '@/lib/streak';

type TransactionClient = Parameters<Parameters<typeof prisma.$transaction>[0]>[0];

export const runtime = 'nodejs';
export const maxDuration = 60;
const DEFAULT_TITLE = 'Generating lesson... Please Wait';

type BreakdownSubtopic = {
  title: string;
  importance: string;   // 'high' | 'medium' | 'low'
  difficulty: number;   // 1..3
  overview?: string;
};
type Breakdown = {
  topic: string;
  subtopics: BreakdownSubtopic[];
};

type QuizQuestion = {
  prompt: string;
  options: string[];
  answerIndex: number;
  explanation: string;
  subtopicTitle?: string;
};
type QuizOut = { questions: QuizQuestion[] };

// --- Helpers: shape guards & fallbacks --------------------------------------

function sanitizeDbText(s: string): string {
  // Postgres TEXT cannot contain NUL (0x00). Remove any null bytes.
  return (s || '').replace(/\u0000/g, '');
}

function normalizeExtractedText(s: string): string {
  const collapsed = (s || '').replace(/\s{2,}/g, ' ').trim();
  return sanitizeDbText(collapsed);
}

function normImportance(v: unknown): 'high'|'medium'|'low' {
  const s = String(v || '').toLowerCase();
  return s === 'high' || s === 'low' ? (s as any) : 'medium';
}
function clampDifficulty(v: unknown): 1|2|3 {
  const n = Number(v);
  if (n <= 1) return 1;
  if (n >= 3) return 3;
  return 2;
}
function clip(s: string, max = 240): string {
  const t = (s || '').replace(/\s+/g, ' ').trim();
  return t.length > max ? t.slice(0, max - 1) + '…' : t;
}

function sanitizeBreakdown(raw: any, text: string): Breakdown {
  const topic =
    typeof raw?.topic === 'string' && raw.topic.trim()
      ? raw.topic.trim()
      : DEFAULT_TITLE;

  let subs: BreakdownSubtopic[] = [];
  if (Array.isArray(raw?.subtopics)) {
    subs = raw.subtopics
      .map((s: any) => {
        const title =
          typeof s?.title === 'string' && s.title.trim()
            ? s.title.trim()
            : '';
        if (!title) return null;
        return {
          title,
          importance: normImportance(s?.importance),
          difficulty: clampDifficulty(s?.difficulty),
          overview:
            typeof s?.overview === 'string' && s.overview.trim()
              ? clip(s.overview, 500)
              : undefined,
        } as BreakdownSubtopic;
      })
      .filter(Boolean) as BreakdownSubtopic[];
  }

  // Fallback: at least one subtopic
  if (subs.length === 0) {
    const firstChunk = clip(text, 500);
    subs = [
      {
        title: topic !== DEFAULT_TITLE ? `${topic} — Overview` : 'Overview',
        importance: 'high',
        difficulty: 1,
        overview: firstChunk || 'Overview of the provided content.',
      },
    ];
  }

  return { topic, subtopics: subs };
}

function isGoodQuestion(q: any): q is QuizQuestion {
  return (
    q &&
    typeof q.prompt === 'string' &&
    Array.isArray(q.options) &&
    q.options.length === 4 &&
    typeof q.answerIndex === 'number' &&
    q.answerIndex >= 0 &&
    q.answerIndex < 4 &&
    typeof q.explanation === 'string'
  );
}

function fallbackQuestions(subtopics: BreakdownSubtopic[]): QuizQuestion[] {
  // Cheap, deterministic questions that still tie to the breakdown.
  // One per subtopic.
  return subtopics.map((s) => {
    const correct = String(s.difficulty);
    const opts = ['1', '2', '3', 'Not specified'];
    const answerIndex =
      correct === '1' ? 0 : correct === '2' ? 1 : correct === '3' ? 2 : 3;
    return {
      prompt: `What difficulty was assigned to "${s.title}"?`,
      options: opts,
      answerIndex,
      explanation: `The breakdown labeled "${s.title}" with difficulty ${s.difficulty}.`,
      subtopicTitle: s.title,
    };
  });
}

function fallbackPairForSubtopic(s: BreakdownSubtopic): [QuizQuestion, QuizQuestion] {
  // Q1: difficulty (existing logic)
  const dCorrect = String(s.difficulty);
  const dOpts = ['1', '2', '3', 'Not specified'];
  const dIdx = dCorrect === '1' ? 0 : dCorrect === '2' ? 1 : dCorrect === '3' ? 2 : 3;
  const q1: QuizQuestion = {
    prompt: `What difficulty was assigned to "${s.title}"?`,
    options: dOpts,
    answerIndex: dIdx,
    explanation: `The breakdown labeled "${s.title}" with difficulty ${s.difficulty}.`,
    subtopicTitle: s.title,
  };
  // Q2: importance
  const imp = (s.importance || 'medium').toLowerCase();
  const iOpts = ['high', 'medium', 'low', 'Not specified'];
  const iIdx = imp === 'high' ? 0 : imp === 'medium' ? 1 : imp === 'low' ? 2 : 3;
  const q2: QuizQuestion = {
    prompt: `What is the importance label for "${s.title}"?`,
    options: iOpts,
    answerIndex: iIdx,
    explanation: `The breakdown marked "${s.title}" with importance "${s.importance}".`,
    subtopicTitle: s.title,
  };
  return [q1, q2];
}

function sanitizeQuiz(raw: any, subtopics: BreakdownSubtopic[]): QuizOut {
  let items: QuizQuestion[] = [];
  if (Array.isArray(raw?.questions)) {
    items = raw.questions.filter(isGoodQuestion);
  }
  // Do not auto-fill fallback questions; return empty if none
  return { questions: items };
}

async function selectTopSubtopics(
  subtopics: BreakdownSubtopic[],
  preferredModel: string | undefined,
  maxCount: number,
): Promise<BreakdownSubtopic[]> {
  if (subtopics.length <= maxCount) return subtopics;
  const payload = subtopics.map((s, idx) => ({ index: idx, title: s.title, overview: s.overview || '' }));
  const prompt = `
You are helping design a concise lecture from a larger document.

Below is an ORDERED list of candidate subtopics extracted from the ENTIRE document (from start to end). Choose exactly ${maxCount} indices that:
- Maximize total coverage of the entire document (include early, middle, and late content)
- Favor information-dense and foundational concepts
- Avoid redundancy; aim for diverse topics that together cover the most material

Return ONLY JSON of the form: { "indices": [i0, i1, ...] }
Use 0-based indices, all unique, length exactly ${maxCount}.

CANDIDATES:
${JSON.stringify(payload, null, 2)}
`;
  try {
    const out = await generateJSON(prompt, preferredModel);
    const indices: number[] = Array.isArray(out?.indices) ? out.indices.map((n: any) => Number(n)).filter((n: any) => Number.isInteger(n) && n >= 0 && n < subtopics.length) : [];
    const uniq = Array.from(new Set(indices)).slice(0, maxCount);
    if (uniq.length === 0) throw new Error('no indices');
    // Preserve original document order by sorting selected indices ascending
    uniq.sort((a, b) => a - b);
    return uniq.map(i => subtopics[i]);
  } catch {
    // Fallback: spread picks across the array for coverage
    const step = subtopics.length / maxCount;
    const picks: number[] = [];
    for (let k = 0; k < maxCount; k++) picks.push(Math.floor(k * step));
    const uniq = Array.from(new Set(picks)).slice(0, maxCount);
    return uniq.map(i => subtopics[i]).filter(Boolean);
  }
}

async function generateSectionMarkdowns(
  lectureTitle: string,
  allText: string,
  subtopics: BreakdownSubtopic[],
  preferredModel?: string,
): Promise<Record<string, string>> {
  const clip = (s: string, max = 10000) => {
    const t = (s || '').trim();
    return t.length > max ? t.slice(0, max) : t;
  };
  // Lightweight relevancy selection to shrink context per subtopic
  const STOP = new Set(
    'the,be,to,of,and,a,in,that,have,i,it,for,not,on,with,he,as,you,do,at,by,from,or,an,are,is,was,were,which,one,all,this,can,will,if,about,into,than,then,there,also,other,more,most,each'.split(',')
  );
  const tokenize = (s: string) => (s || '')
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, ' ')
    .split(/\s+/)
    .filter(w => w && w.length >= 3 && !STOP.has(w));
  const paragraphs = (allText || '')
    .split(/\n{2,}/)
    .map(p => p.trim())
    .filter(Boolean);
  const selectRelevantContext = (title: string, overview: string, maxChars = 4000): string => {
    if (!paragraphs.length) return clip(allText, maxChars);
    const queryTerms = new Set([...tokenize(title), ...tokenize(overview)]);
    if (queryTerms.size === 0) return clip(allText, maxChars);
    const scores: Array<{ idx: number; score: number; text: string }> = [];
    for (let i = 0; i < paragraphs.length; i++) {
      const p = paragraphs[i];
      const toks = tokenize(p);
      let sc = 0;
      for (const t of toks) if (queryTerms.has(t)) sc++;
      // small bonus for adjacency to previous relevant paragraph
      if (sc && i > 0) {
        const prevToks = tokenize(paragraphs[i - 1]);
        for (const t of prevToks) if (queryTerms.has(t)) { sc += 0.3; break; }
      }
      if (sc > 0) scores.push({ idx: i, score: sc, text: p });
    }
    if (!scores.length) return clip(allText, maxChars);
    scores.sort((a, b) => b.score - a.score);
    const picked: string[] = [];
    const used = new Set<number>();
    let total = 0;
    for (const s of scores) {
      if (used.has(s.idx)) continue;
      const chunkParts: string[] = [];
      // include prev, current, next for continuity
      for (const j of [s.idx - 1, s.idx, s.idx + 1]) {
        if (j >= 0 && j < paragraphs.length && !used.has(j)) {
          const part = paragraphs[j];
          const addLen = part.length + 2;
          if (total + addLen > maxChars && picked.length) break;
          used.add(j);
          chunkParts.push(part);
          total += addLen;
        }
      }
      if (chunkParts.length) picked.push(chunkParts.join('\n\n'));
      if (total >= maxChars) break;
    }
    return picked.join('\n\n\n');
  };
  // Run all subtopics in parallel (limit equals number of subtopics)
  const limit = Math.max(1, subtopics.length);
  let inFlight = 0;
  const queue: Array<() => Promise<void>> = [];
  const result: Record<string, string> = {};

  const runNext = async (): Promise<void> => {
    if (!queue.length) return;
    if (inFlight >= limit) return;
    const task = queue.shift()!;
    inFlight++;
    try { await task(); } finally { inFlight--; await runNext(); }
  };

  const tasks = subtopics.map((s) => async () => {
    const title = s.title;
    const overview = s.overview || '';
    const prompt = [
      `You are writing ONE section of a lecture. Ground it in the document.`,
      `Lecture: "${lectureTitle}"`,
      `Subtopic: "${title}"`,
      `Overview: ${overview}`,
      `Write 180–320 words of clean Markdown.`,
      `Use short paragraphs and bullet lists where helpful.`,
      `Start directly with content. No preamble. No H1.`,
      `Focus on definitions, theorems, algorithms, and examples that appear in the document; avoid generic use cases unless present.`,
      `---`,
      `DOCUMENT EXCERPTS (relevant slices only):`,
      selectRelevantContext(title, overview, 3000),
    ].join('\n');
    const mdRaw = await generateText(prompt, preferredModel);
    result[title.trim().toLowerCase()] = sanitizeDbText(mdRaw);
  });

  // Enqueue tasks and run with concurrency
  for (const t of tasks) {
    queue.push(t);
    void runNext();
  }
  // Wait for all to finish
  while (queue.length || inFlight) {
    // eslint-disable-next-line no-await-in-loop
    await new Promise((r) => setTimeout(r, 25));
  }
  return result;
}

// --- Route -------------------------------------------------------------------

export async function POST(req: NextRequest) {
  try {
    const session = await requireSession();
    if (!isSessionWithUser(session)) {
      return NextResponse.json({ error: 'Unauthorised' }, { status: 401 });
    }
    const userId = session.user.id;

    const contentType = req.headers.get('content-type') || '';
    let text = '';
    // Keep a copy of the raw PDF bytes when available so we can extract text
    // as a reliable fallback (and to ground chat later).
    let pdfBuffer: Buffer | null = null;
    let approxPages = 0;

    let preferredModel: string | undefined = undefined;
    let wasPlainTextInput = false;
    let visionCandidate: File | null = null;
    if (contentType.includes('multipart/form-data')) {
      const form = await req.formData();
      const file = form.get('file');
      const m = form.get('model');
      if (typeof m === 'string' && m.trim()) preferredModel = m.trim();
      if (!file || !(file instanceof File)) {
        return NextResponse.json({ error: 'No file provided. Please upload a single PDF.' }, { status: 400 });
      }
      if (!file.name.toLowerCase().endsWith('.pdf')) {
        return NextResponse.json({ error: 'Invalid file type. Only PDF files are accepted.' }, { status: 400 });
      }
      // Prefer Vision first for PDFs; keep file for later
      visionCandidate = file as File;
      try {
        const arr = await (file as File).arrayBuffer();
        pdfBuffer = Buffer.from(arr);
      } catch {}
    } else if (contentType.includes('application/json')) {
      const body = await req.json();
      if (typeof body?.model === 'string' && body.model.trim()) preferredModel = body.model.trim();
      const blobUrl = String(body?.blobUrl || '').trim();
      const content = String(body?.content || '').trim();
      if (blobUrl) {
        // Stream PDF from Blob URL, prefer vision
        const resp = await fetch(blobUrl);
        if (!resp.ok) return NextResponse.json({ error: 'Could not fetch blob' }, { status: 400 });
        const arr = Buffer.from(await resp.arrayBuffer());
        pdfBuffer = arr;
        // Route to vision path via temp File shim
        visionCandidate = new File([arr], 'upload.pdf', { type: 'application/pdf' }) as any;
      } else {
        text = sanitizeDbText(content);
        if (!text) return NextResponse.json({ error: 'Content is required.' }, { status: 400 });
        wasPlainTextInput = true;
      }
    } else {
      return NextResponse.json({ error: 'Unsupported content type.' }, { status: 415 });
    }

    // Try to extract text from PDF first (preferred grounding for large PDFs)
    if (!text && pdfBuffer) {
      try {
        const data: any = await pdf(pdfBuffer);
        approxPages = Number(data?.numpages || 0) || 0;
        const extracted = normalizeExtractedText(data.text || '');
        if (extracted) text = extracted;
      } catch {}
    }

    // EARLY RETURN for immediate navigation:
    // If this was plain text input, create a lecture record immediately and return.
    if (wasPlainTextInput) {
      const lecture = await prisma.lecture.create({
        data: { title: DEFAULT_TITLE, originalContent: sanitizeDbText(text), userId },
      });
      try { await bumpDailyStreak(userId); } catch {}
      return NextResponse.json({ lectureId: lecture.id, debug: { model: preferredModel || process.env.GEMINI_MODEL || 'default', immediate: true } }, { status: 201 });
    }

    // Optional: vision path when OCR/text extraction is thin
    if (!text && visionCandidate) {
      try {
        const apiKey = process.env.GOOGLE_API_KEY;
        if (!apiKey) throw new Error('GOOGLE_API_KEY not set');
        const client = new GoogleGenerativeAI(apiKey);
        const files = new GoogleAIFileManager(apiKey);
        const buf = pdfBuffer || Buffer.from(await visionCandidate.arrayBuffer());
        const uploaded = await files.uploadFile(buf, { mimeType: 'application/pdf', displayName: (visionCandidate as any).name || 'upload.pdf' });
        let fileRec: any = uploaded.file;
        const tStart = Date.now();
        while (fileRec.state !== 'ACTIVE') {
          if (Date.now() - tStart > 45000) throw new Error('vision timeout');
          await new Promise((r) => setTimeout(r, 1200));
          fileRec = await files.getFile(fileRec.name);
        }
        const model = client.getGenerativeModel({ model: preferredModel || process.env.GEMINI_MODEL || 'gemini-2.5-flash' });
        const visionPrompt = [
          'Analyze this PDF (text + images).',
          'Return ONLY JSON with exactly this shape (no extra prose):',
          '{ "topic": string, "subtopics": [ { "title": string, "importance": "high"|"medium"|"low", "difficulty": 1|2|3, "overview": string } ] }',
          'Base your response strictly on the PDF content; do not invent unrelated topics.',
        ].join('\n');
        const res = await model.generateContent([
          { fileData: { fileUri: fileRec.uri, mimeType: 'application/pdf' } },
          { text: visionPrompt },
        ]);
        const out = res.response.text?.() || '';
        // Be tolerant of models that wrap JSON in text/code fences
        let parsed: any;
        try {
          parsed = JSON.parse(out);
        } catch {
          const fenced = out.match(/```(?:json)?\s*([\s\S]*?)```/i)?.[1]?.trim();
          if (fenced) {
            try { parsed = JSON.parse(fenced); } catch {}
          }
          if (!parsed) {
            const objMatch = (() => {
              let depth = 0, start = -1, inStr = false, esc = false;
              for (let i = 0; i < out.length; i++) {
                const ch = out[i];
                if (inStr) { if (esc) { esc = false; continue; } if (ch === '\\') { esc = true; continue; } if (ch === '"') { inStr = false; } continue; }
                if (ch === '"') { inStr = true; continue; }
                if (ch === '{') { if (depth === 0) start = i; depth++; continue; }
                if (ch === '}') { if (depth > 0 && --depth === 0 && start >= 0) return out.slice(start, i + 1); }
              }
              return null;
            })();
            if (objMatch) {
              try { parsed = JSON.parse(objMatch); } catch {}
            }
          }
        }
        if (!parsed) throw new Error('Invalid JSON from vision');
        // Use parsed results as breakdown
        const bdFromVision = {
          topic: String(parsed?.topic || 'Untitled'),
          subtopics: Array.isArray(parsed?.subtopics) ? parsed.subtopics.map((s: any) => ({
            title: String(s?.title || ''),
            importance: String(s?.importance || 'medium'),
            difficulty: Number(s?.difficulty || 2),
            overview: String(s?.overview || ''),
          })) : []
        } as Breakdown;
        // Extract raw text (best-effort) for grounding chat/originalContent
        let extracted = '';
        try {
          const data: any = await pdf(pdfBuffer || buf);
          approxPages = Number(data?.numpages || approxPages || 0) || approxPages;
          extracted = normalizeExtractedText(data.text || '');
        } catch {}
        // 3) Persist directly, storing extracted text when available
        const originalContent = extracted || 'PDF (vision) upload';
    const lecture = await prisma.lecture.create({ data: { title: bdFromVision.topic || DEFAULT_TITLE, originalContent: sanitizeDbText(originalContent), userId } });
    // Count lecture generation towards streak
    await bumpDailyStreak(userId);
        if (bdFromVision.subtopics.length) {
          // Cap to avoid long generation
          const subcaps = bdFromVision.subtopics.length > 15
            ? await selectTopSubtopics(bdFromVision.subtopics, preferredModel, 15)
            : bdFromVision.subtopics;
          // Generate explanation for the FIRST subtopic only; others deferred until viewed
          const firstOnly = subcaps.slice(0, 1);
          const sectionMap = await generateSectionMarkdowns(bdFromVision.topic || 'Untitled', extracted, firstOnly, preferredModel);
          await prisma.subtopic.createMany({
            data: subcaps.map((s, idx) => ({
              order: idx,
              title: s.title || `Section ${idx + 1}`,
              importance: s.importance,
              difficulty: s.difficulty,
              overview: s.overview || '',
              explanation: idx === 0 ? (sectionMap[(s.title || '').trim().toLowerCase()] || null) : null,
              lectureId: lecture.id,
            })),
          });
          // After subtopics exist, create initial quiz questions ONLY for the first subtopic
          const created = await prisma.subtopic.findMany({ where: { lectureId: lecture.id }, orderBy: { order: 'asc' }, select: { id: true, title: true, overview: true } });
          const firstSt = created[0];
          if (firstSt) {
            const quizPromptV = `
You are an expert assessment writer. Create exactly TWO multiple-choice questions grounded ONLY in the DOCUMENT CONTENT below for the subtopic shown.

Constraints:
- Use only facts present in the document. Do not invent.
- Include a short DIRECT quote (6–12 words) from the document in the explanation, in "double quotes".
- Exactly four options ["A","B","C","D"]. No prefixes.

Return ONLY ONE JSON object:
{
  "questions": [
    { "prompt": "string", "options": ["A","B","C","D"], "answerIndex": 0, "explanation": "string", "subtopicTitle": "${firstSt.title}" },
    { "prompt": "string", "options": ["A","B","C","D"], "answerIndex": 0, "explanation": "string", "subtopicTitle": "${firstSt.title}" }
  ]
}

DOCUMENT CONTENT (truncated):
${(extracted || '').slice(0, 8000)}

SUBTOPIC:
${JSON.stringify({ title: firstSt.title, overview: firstSt.overview || '' }, null, 2)}
`.trim();
            try {
              const modelForQuiz = preferredModel || 'gemini-2.5-flash';
              const qzRawV = await generateJSON(quizPromptV, modelForQuiz);
              const qList: QuizQuestion[] = Array.isArray(qzRawV?.questions) ? (qzRawV.questions as any[]).filter(isGoodQuestion) : [];
              const quizDataV: Array<{ prompt: string; options: any; answerIndex: number; explanation: string; subtopicId: string; }> = [];
              const q1 = qList[0];
              const q2 = qList[1];
              if (isGoodQuestion(q1) && isGoodQuestion(q2)) {
                quizDataV.push(
                  { prompt: q1.prompt, options: q1.options as any, answerIndex: q1.answerIndex, explanation: q1.explanation, subtopicId: firstSt.id },
                  { prompt: q2.prompt, options: q2.options as any, answerIndex: q2.answerIndex, explanation: q2.explanation, subtopicId: firstSt.id },
                );
              } else {
                // Do not insert fallback questions; leave first subtopic without questions
              }
              if (quizDataV.length) await prisma.quizQuestion.createMany({ data: quizDataV });
            } catch {}
          }
        }
        return NextResponse.json({ lectureId: lecture.id, debug: { model: preferredModel || process.env.GEMINI_MODEL || 'gemini-2.5-flash', usedVision: true } }, { status: 201 });
      } catch (e) {
        // If vision fails, continue to text-only path
      }
    }

    // If we still have no text but we do have the PDF bytes, extract text now.
    if (!text && pdfBuffer) {
      try {
        const data: any = await pdf(pdfBuffer);
        approxPages = Number(data?.numpages || approxPages || 0) || approxPages;
        const extracted = normalizeExtractedText(data.text || '');
        text = extracted;
      } catch {}
    }
    // EARLY RETURN for PDF uploads as well: create minimal lecture and allow client to stream subtopics.
    if (pdfBuffer) {
      const originalContent = sanitizeDbText(text || 'PDF upload');
      const lecture = await prisma.lecture.create({ data: { title: DEFAULT_TITLE, originalContent, userId } });
      try { await bumpDailyStreak(userId); } catch {}
      return NextResponse.json({ lectureId: lecture.id, debug: { model: preferredModel || process.env.GEMINI_MODEL || 'default', immediate: true } }, { status: 201 });
    }
    if (!text) {
      return NextResponse.json({ error: 'Could not extract text from the PDF. The file may only contain images.' }, { status: 422 });
    }

    // 1) Breakdown (robust)
    const charLen = text.length;

    const breakdownPrompt = `
      You are an expert instructional designer. Create an exhaustive, sequential breakdown of the entire document below.

      Goals:
      - Cover ALL major sections and distinct concepts. Do not merge unrelated topics.
      - Preserve the original document order from start to finish.
      - Be concise but complete: each subtopic should map to a coherent portion of the document.
      - Generate between 8 and 15 subtopics in total. Aim for about 12 on average. Never exceed 15.

      Return ONLY a single JSON object with exactly these keys:
      {
        "topic": "string",
        "subtopics": [
          {
            "title": "string",
            "importance": "high" | "medium" | "low",
            "difficulty": 1 | 2 | 3,
            "overview": "string"
          }
        ]
      }

      Document:
      ---
      ${text}
    `;
    const t0 = Date.now();
    const bdRaw = await generateJSON(breakdownPrompt, preferredModel);
    let bd = sanitizeBreakdown(bdRaw, text);
    // Select coverage-maximizing subtopics up to cap
    const MAX_SUBTOPICS = 15;
    if (bd.subtopics.length > MAX_SUBTOPICS) {
      const picked = await selectTopSubtopics(bd.subtopics, preferredModel, MAX_SUBTOPICS);
      bd = { ...bd, subtopics: picked };
    }

    // 2) Quiz (robust) — generate only for FIRST subtopic to speed up
    const firstSub = bd.subtopics[0];
    const quizPromptFirst = `
      You are an expert assessment writer. Create exactly TWO multiple-choice questions grounded ONLY in the DOCUMENT CONTENT below for the subtopic shown.

      Constraints:
      - Use only facts present in the document. Do not invent.
      - Questions must match the scope of the subtopic overview.
      - Include a short DIRECT quote (6–12 words) from the document in the explanation, in "double quotes".
      - Exactly four options ["A","B","C","D"]. No prefixes.
      - Exactly ONE correct option per question; the other three must be clearly incorrect given the DOCUMENT.
      - Avoid ambiguous options and avoid "All/None of the above".

      Return ONLY ONE JSON object:
      {
        "questions": [
          { "prompt": "string", "options": ["A","B","C","D"], "answerIndex": 0, "explanation": "string", "subtopicTitle": "${firstSub?.title || ''}" },
          { "prompt": "string", "options": ["A","B","C","D"], "answerIndex": 0, "explanation": "string", "subtopicTitle": "${firstSub?.title || ''}" }
        ]
      }

      DOCUMENT CONTENT (truncated for safety):
      ${clip(text, 8000)}

      SUBTOPIC:
      ${JSON.stringify({ title: firstSub?.title, overview: firstSub?.overview || '' }, null, 2)}
    `.trim();
    const mid = Date.now();
    const modelForQuiz = preferredModel || 'gemini-2.5-flash';
    const qzRaw = await generateJSON(quizPromptFirst, modelForQuiz);
    const msBreakdown = mid - t0;
    const msQuiz = Date.now() - mid;
    const rawQuestions: QuizQuestion[] = Array.isArray(qzRaw?.questions) ? (qzRaw.questions as any[]).filter(isGoodQuestion) : [];

    // 3) Persist (non-interactive writes to avoid long-lived transaction issues)
    const lecture = await prisma.lecture.create({
      data: { title: bd.topic || DEFAULT_TITLE, originalContent: sanitizeDbText(text), userId },
    });
    // Count lecture generation towards streak
    await bumpDailyStreak(userId);

    // Generate explanation for FIRST subtopic only; others deferred until viewed
    const titleForLecture = bd.topic || DEFAULT_TITLE;
    const firstOnly = bd.subtopics.slice(0, 1);
    const sectionMap = await generateSectionMarkdowns(titleForLecture, text, firstOnly, preferredModel);

    // Insert subtopics with only first explanation persisted
    await prisma.subtopic.createMany({
      data: bd.subtopics.map((s, idx) => ({
        order: idx,
        title: s.title,
        importance: s.importance,
        difficulty: s.difficulty,
        overview: s.overview || '',
        explanation: idx === 0 ? (sectionMap[s.title.trim().toLowerCase()] || null) : null,
        lectureId: lecture.id,
      })),
    });

    // Fetch inserted subtopics (ordered) and align questions by index for stable mapping (2 per subtopic)
    const subtopics = await prisma.subtopic.findMany({
      where: { lectureId: lecture.id },
      orderBy: { order: 'asc' },
      select: { id: true, title: true },
    });
    const quizData: Array<{ prompt: string; options: any; answerIndex: number; explanation: string; subtopicId: string; }> = [];
    if (subtopics.length > 0) {
      const st = subtopics[0];
      const q1 = rawQuestions[0];
      const q2 = rawQuestions[1];
      if (isGoodQuestion(q1) && isGoodQuestion(q2)) {
        quizData.push(
          { prompt: q1.prompt, options: q1.options as any, answerIndex: q1.answerIndex, explanation: q1.explanation, subtopicId: st.id },
          { prompt: q2.prompt, options: q2.options as any, answerIndex: q2.answerIndex, explanation: q2.explanation, subtopicId: st.id },
        );
      } else {
        // Do not insert fallback questions; leave first subtopic without questions
      }
    }
    if (quizData.length) {
      await prisma.quizQuestion.createMany({ data: quizData });
    }

    return NextResponse.json({ lectureId: lecture.id, debug: { model: preferredModel || process.env.GEMINI_MODEL || 'default', msBreakdown, msQuiz } }, { status: 201 });
  } catch (e: any) {
    console.error('LECTURES_API_ERROR:', e?.stack || e?.message || e);
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: e?.status || 500 });
  }
}
</file>

<file path="src/components/LearnView.tsx">
'use client';

import { useRouter } from 'next/navigation';
import { useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import rehypeKatex from 'rehype-katex';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type QuizQuestion,
  type LearnSubtopic,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';
// import useBodyScrollLock from '@/hooks/useBodyScrollLock';

/** Normalize model output so it never renders as one giant code block. */
function sanitizeMarkdown(md: string): string {
  if (!md) return md;
  // Do NOT trim here. Trimming breaks streaming by removing leading spaces
  // that can arrive at chunk boundaries, causing words to concatenate.
  let t = md;

  // 1) Unwrap a single full-document fenced block (```md / ```markdown / ``` / any)
  const exactFence = t.match(/^```(?:markdown|md|text)?\s*\n([\s\S]*?)\n```$/i);
  if (exactFence) {
    t = exactFence[1].trim();
  } else {
    const anyFence = t.match(/^```([A-Za-z0-9+_.-]*)\s*\n([\s\S]*?)\n```$/);
    if (anyFence) {
      const lang = (anyFence[1] || '').toLowerCase();
      const inner = anyFence[2];
      if (
        lang === '' ||
        lang === 'markdown' ||
        lang === 'md' ||
        /^(#{1,6}\s|[-*]\s|\d+\.\s)/m.test(inner) ||
        /\n\n/.test(inner)
      ) {
        t = inner.trim();
      }
    }
  }

  // 2) If every non-empty line starts with >=4 spaces or a tab, de-indent once (was treated as code)
  const lines = t.split('\n');
  const nonEmpty = lines.filter((l) => l.trim() !== '');
  if (nonEmpty.length && nonEmpty.every((l) => /^ {4,}|\t/.test(l))) {
    t = lines.map((l) => l.replace(/^ {4}/, '')).join('\n').trim();
  }

  // 3) If there is a stray unmatched ``` fence, strip it.
  const tickCount = (t.match(/```/g) || []).length;
  if (tickCount === 1) {
    t = t.replace(/```/g, '');
  }

  return t;
}

// Merge streaming chunks without gluing words together across boundaries.
function appendChunkSafely(previous: string, next: string): string {
  if (!next) return previous || '';
  if (!previous) return next;
  const lastChar = previous.slice(-1);
  const firstChar = next[0];
  const isWordChar = (ch: string) => /[A-Za-z0-9]/.test(ch);
  const needsSpace = (
    // word + word (e.g., "feathers" + "While")
    (isWordChar(lastChar) && isWordChar(firstChar)) ||
    // sentence/colon punctuation followed by a word with no whitespace
    (/[\.:;!?]$/.test(previous) && isWordChar(firstChar))
  ) && !/^\s/.test(next);
  return needsSpace ? previous + ' ' + next : previous + next;
}

// Ensure rendered content never starts with a title/heading
function stripLeadingTitle(md: string, title?: string): string {
  let out = String(md ?? '');
  // Drop leading ATX headings (# .. ###### ..)
  out = out.replace(/^\s{0,3}#{1,6}\s+[^\n]+\n+/m, '');
  // Drop leading setext headings (Title\n==== or ----)
  out = out.replace(/^\s*([^\n]+)\n(?:=+|-+)\s*\n+/m, '');
  // If first non-empty line equals provided title, remove it
  if (title) {
    const lines = out.split('\n');
    const firstIdx = lines.findIndex((l) => l.trim() !== '');
    if (firstIdx !== -1) {
      const firstLine = lines[firstIdx].trim();
      if (firstLine.localeCompare(title.trim(), undefined, { sensitivity: 'accent' }) === 0) {
        lines.splice(firstIdx, 1);
        if (lines[firstIdx] !== undefined && lines[firstIdx].trim() === '') {
          lines.splice(firstIdx, 1);
        }
        out = lines.join('\n');
      }
    }
  }
  return out;
}

export default function LearnView({ initial }: { initial: LearnLecture }) {
  // UI-only store per page mount
  const initialUnlocked = deriveUnlockedIndex(initial.subtopics);
  const storeRef = useRef(
    createLearnUIStore({
      currentIndex: initialUnlocked,
      unlockedIndex: initialUnlocked,
    })
  );
  const ui = storeRef.current;

  const currentIndex = ui((s) => s.currentIndex);
  const unlockedIndex = ui((s) => s.unlockedIndex);
  const currentSubtopic = initial.subtopics[currentIndex];

  // Scroll to top of main panel on subtopic change
  const mainRef = useRef<HTMLElement | null>(null);
  const scrollToMainTop = () => {
    if (typeof window === 'undefined') return;
    if (mainRef.current) {
      mainRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' });
    } else {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  };

  // Title (display; updated live from streaming endpoint)
  const [title, setTitle] = useState(initial.title);
  const router = useRouter();
  const [isCompleted, setIsCompleted] = useState(false);
  const [showSparkle, setShowSparkle] = useState(false);
  const [streaming, setStreaming] = useState(false);

  // Maintain a reactive questions map keyed by subtopicId so UI updates immediately
  const [questionsById, setQuestionsById] = useState<Record<string, QuizQuestion[]>>(
    () => Object.fromEntries(initial.subtopics.map((s) => [s.id, s.questions || []]))
  );

  // Prevent duplicate quiz generation across preloader and panel
  const questionsInFlightRef = useRef<Set<string>>(new Set());
  const reserveQuestions = useCallback((id: string): boolean => {
    const s = questionsInFlightRef.current;
    if (s.has(id)) return false;
    s.add(id);
    return true;
  }, []);

  // If subtopics stream in and the second one becomes available AFTER mount while
  // we are still on the first, prefetch is deferred to the subtopic-change effect
  // so it can run in parallel with current quiz generation.

  // Track which subtopics have been prefetched to avoid missing/duplicate work
  const prefetchedNextRef = useRef<Set<string>>(new Set());
  const releaseQuestions = useCallback((id: string): void => {
    questionsInFlightRef.current.delete(id);
  }, []);

  // Force-correct first subtopic explanation once on mount to avoid any
  // potential mismatch showing the second subtopic's content.
  const forceFirstFixRef = useRef<boolean>(false);

  // Explanations cache (sanitized)
  const [explanations, setExplanations] = useState<Record<string, string>>(() =>
    Object.fromEntries(
      initial.subtopics.map((s) => [s.id, s.explanation ? sanitizeMarkdown(s.explanation) : ''])
    )
  );
  // Track when a subtopic's explanation is fully generated
  const [explanationDone, setExplanationDone] = useState<Record<string, boolean>>(() =>
    Object.fromEntries(initial.subtopics.map((s) => [s.id, Boolean(s.explanation && s.explanation.length > 0)]))
  );

  // On first mount, if there are no subtopics yet, stream them in progressively
  useEffect(() => {
    if (!initial.subtopics || initial.subtopics.length === 0) {
      (async () => {
        try {
          setStreaming(true);
          let model: string | undefined;
          try { model = localStorage.getItem('ai:model') || undefined; } catch {}
          const qs = new URLSearchParams({ lectureId: initial.id, ...(model ? { model } : {}) });
          const res = await fetch('/api/lectures/stream?' + qs.toString());
          if (!res.ok || !res.body) return;
          const reader = res.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
            while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            let idx: number;
            while ((idx = buffer.indexOf('\n\n')) !== -1) {
              const event = buffer.slice(0, idx).trim();
              buffer = buffer.slice(idx + 2);
              if (!event.startsWith('data:')) continue;
              const json = event.slice(5).trim();
              let payload: any; try { payload = JSON.parse(json); } catch { continue; }
              if (payload?.type === 'subtopic' && payload.subtopic) {
                const s = payload.subtopic as any;
                // append into our local initial.subtopics clone
                (initial.subtopics as any).push({
                  id: s.id,
                  order: s.order,
                  title: s.title,
                  importance: s.importance,
                  difficulty: s.difficulty,
                  overview: s.overview || '',
                  explanation: s.explanation || '',
                  mastered: false,
                  questions: [],
                });
                // Keep unlocked to currentIndex
                ui.setState((st) => ({ ...st, currentIndex: st.currentIndex, unlockedIndex: Math.max(st.unlockedIndex, st.currentIndex) }));
                setExplanations((e) => ({ ...e, [s.id]: (s.explanation || '') }));
              } else if (payload?.type === 'title' && typeof payload.title === 'string') {
                setTitle(String(payload.title));
              } else if (payload?.type === 'done') {
                // finished initial stream
              } else if (payload?.type === 'error') {
                // swallow
              }
            }
          }
        } finally {
          setStreaming(false);
        }
      })();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Progress state (green progress bar in left sidebar)
  const initialMastered = initial.subtopics.filter((s) => s.mastered).length;
  const totalCount = initial.subtopics.length;
  const [masteredCount, setMasteredCount] = useState<number>(initialMastered);
// NEW: track which subtopics are already counted to avoid double-increment
const countedIdsRef = useRef<Set<string>>(
  new Set(initial.subtopics.filter(s => s.mastered).map(s => s.id))
);

  const progressPct = Math.round((masteredCount / Math.max(1, totalCount)) * 100);
  const progressPctSafe = isCompleted ? 100 : progressPct;

  const canSelect = (i: number) => i <= unlockedIndex;

  // Keep unlockedIndex sane if server state changes
  useEffect(() => {
    const u = deriveUnlockedIndex(initial.subtopics);
    ui.setState((s) => ({
      ...s,
      unlockedIndex: Math.max(u, s.unlockedIndex),
      currentIndex: Math.max(0, Math.min(s.currentIndex, initial.subtopics.length - 1)),
    }));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initial.subtopics.map((s) => (s as any).mastered).join('|')]);

  const fetchExplanationFor = useCallback(
    async (
      target: LearnSubtopic | null | undefined,
      style: 'default' | 'simplified' | 'detailed' | 'example' = 'default',
    ) => {
      if (!target) return;
      const targetId = target.id;
      const targetTitle = target.title;
      // Guard: only stream for the ACTIVE subtopic being viewed.
      try {
        const activeIndex = (ui as any)?.getState?.().currentIndex ?? currentIndex;
        const activeId = initial.subtopics[activeIndex]?.id;
        if (activeId !== targetId) {
          return;
        }
      } catch {}
      setExplanations((e) => ({ ...e, [targetId]: '' }));
      try {
        let model: string | undefined;
        try { model = localStorage.getItem('ai:model') || undefined; } catch {}
        const targetIndex = Math.max(0, initial.subtopics.findIndex((st) => st.id === targetId));
        const covered = targetIndex > 0
          ? initial.subtopics.slice(0, targetIndex).map((st) => ({ title: st.title, overview: st.overview }))
          : [];
        const qs = new URLSearchParams({ stream: '1' });
        const res = await fetch('/api/explain-db?' + qs.toString(), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            lectureTitle: title || initial.title,
            subtopic: targetTitle,
            subtopicId: targetId,
            lectureId: initial.id,
            documentContent: initial.originalContent,
            covered,
            model,
            style,
          }),
        });
        if (!res.ok || !res.body) throw new Error('HTTP ' + res.status);
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          let idx: number;
          while ((idx = buffer.indexOf('\n\n')) !== -1) {
            const event = buffer.slice(0, idx).trim();
            buffer = buffer.slice(idx + 2);
            if (!event.startsWith('data:')) continue;
            const json = event.slice(5).trim();
            let payload: any; try { payload = JSON.parse(json); } catch { continue; }
            if (payload?.type === 'chunk' && typeof payload.delta === 'string') {
              // Guard: ensure target remains the active subtopic while streaming
              let stillActive = true;
              try {
                const activeIndex = (ui as any)?.getState?.().currentIndex ?? currentIndex;
                const activeId = initial.subtopics[activeIndex]?.id;
                stillActive = activeId === targetId;
              } catch {}
              if (stillActive) {
                setExplanations((e) => ({
                  ...e,
                  [targetId]: appendChunkSafely(e[targetId] || '', sanitizeMarkdown(payload.delta)),
                }));
              }
            } else if (payload?.type === 'done') {
              setExplanationDone((m) => ({ ...m, [targetId]: true }));
            } else if (payload?.type === 'error') {
              throw new Error(payload.error || 'stream error');
            }
          }
        }
      } catch (e: any) {
        setExplanations((ex) => ({ ...ex, [targetId]: 'Could not generate explanation. ' + (e?.message || '') }));
      }
    },
    [title, initial.title, initial.id, initial.originalContent, initial.subtopics]
  );

  // Convenience wrapper for buttons: uses current subtopic
  const fetchExplanation = useCallback(
    (style: 'default' | 'simplified' | 'detailed' | 'example' = 'default') =>
      fetchExplanationFor(currentSubtopic, style),
    [currentSubtopic, fetchExplanationFor]
  );

  // On initial mount, proactively regenerate the FIRST subtopic explanation once.
  // This guards against any stale/mismapped persisted content for index 0.
  useEffect(() => {
    if (forceFirstFixRef.current) return;
    if (!initial.subtopics || initial.subtopics.length === 0) return;
    // Only act if we are at the first subtopic
    // deferred: handled when explanation is ready to run in parallel with quiz
    return;
    const first = initial.subtopics[0];
    if (!first) return;
    forceFirstFixRef.current = true;
    // Clear then regenerate to ensure fresh, correct content
    setExplanations((e) => ({ ...e, [first.id]: '' }));
    void fetchExplanationFor(first, 'default');

    // Note: prefetch of second subtopic is handled by other effects to avoid
    // duplicate requests and potential content mixups on mount.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // On subtopic change: fetch explanation once and scroll to top
  useEffect(() => {
    const s = currentSubtopic;
    if (s && !explanations[s.id]) {
      fetchExplanationFor(s, 'default');
    }
    const currentReady = s ? Boolean(explanationDone[s.id]) : false;
    // Preload the NEXT subtopic explanation one step ahead, only after current explanation is done
    const nextIndex = currentIndex + 1;
    if (currentReady && nextIndex < initial.subtopics.length) {
      const next = initial.subtopics[nextIndex];
      if (next && !prefetchedNextRef.current.has(next.id)) {
        // Mark as prefetched to guard against StrictMode double effects
        prefetchedNextRef.current.add(next.id);
        // fire-and-forget preload
        (async () => {
          try {
            let model: string | undefined;
            try { model = localStorage.getItem('ai:model') || undefined; } catch {}
            const covered = initial.subtopics
              .slice(0, Math.max(0, nextIndex))
              .map((st) => ({ title: st.title, overview: st.overview }));
            const res = await fetch('/api/explain-db', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                lectureTitle: title || initial.title,
                subtopic: next.title,
                subtopicId: next.id,
                lectureId: initial.id,
                documentContent: initial.originalContent,
                covered,
                model,
              }),
            });
            if (!res.ok) return;
            const data = (await res.json()) as { markdown?: string };
            const md = sanitizeMarkdown(data.markdown || '');
            setExplanations((e) => ({ ...e, [next.id]: md || 'No content generated.' }));
            setExplanationDone((m) => ({ ...m, [next.id]: true }));

            // Preload quiz questions for the next subtopic as well
            try {
              if (!reserveQuestions(next.id)) return;
              const REQUIRED_QUESTIONS = 2;
              const existingCount = Array.isArray(questionsById[next.id])
                ? questionsById[next.id].length
                : Array.isArray(next.questions)
                  ? next.questions.length
                  : 0;
              let needed = Math.max(0, REQUIRED_QUESTIONS - existingCount);
              const lessonPayload = (md || '').trim();
              if (lessonPayload.length >= 50 && needed > 0) {
                const generated: Array<{ prompt: string; options: string[]; answerIndex: number; explanation: string }> = [];
                while (needed > 0) {
                  const qRes = await fetch('/api/quiz', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ lessonMd: lessonPayload, difficulty: 'hard', subtopicTitle: next.title, lectureId: initial.id, overview: next.overview || '' }),
                  });
                  if (!qRes.ok) break;
                  const qData = (await qRes.json()) as {
                    questions: Array<{ prompt: string; options: string[]; answerIndex: number; explanation: string }>;
                  };
                  const q = qData.questions?.[0];
                  if (!q) break;
                  generated.push({ prompt: q.prompt, options: q.options, answerIndex: q.answerIndex, explanation: q.explanation });
                  needed--;
                }
                if (generated.length) {
                  const save = await fetch('/api/quiz/questions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ subtopicId: next.id, questions: generated }),
                  });
                  if (save.ok) {
                    const payload = (await save.json()) as {
                      questions: Array<{ id: string; prompt: string; options: string[]; answerIndex: number; explanation: string }>;
                    };
                    const saved = (payload.questions || []).slice(0, REQUIRED_QUESTIONS);
                    if (saved.length) {
                      // Update reactive questions map so the quiz is ready instantly when navigating
                      setQuestionsById((prev) => ({ ...prev, [next.id]: saved as unknown as QuizQuestion[] }));
                    }
                  }
                }
              }
            } catch {
              // swallow preloading errors
            } finally {
              releaseQuestions(next.id);
            }
          } catch {
            // If it failed early, allow retry on next navigation
            prefetchedNextRef.current.delete(next.id);
          }
        })();
      }
    }
    if (s) {
      if (typeof requestAnimationFrame !== 'undefined') {
        requestAnimationFrame(() => scrollToMainTop());
      } else {
        scrollToMainTop();
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentSubtopic?.id, explanationDone[currentSubtopic?.id || '']]);

  // rename removed from lesson page

  return (
    <div className="grid grid-cols-1 lg:grid-cols-12 gap-8 lg:gap-10 xl:gap-12 px-2 md:px-4">
      {/* Left: Outline */}
      <aside className="space-y-5 self-start rounded-lg border border-neutral-800 p-6 lg:p-7 xl:p-8 lg:col-span-3">
        <h2 className="text-xl font-semibold">Lecture</h2>

        {/* Progress bar */}
        <div className="mt-2">
          <div className="flex items-center justify-between text-xs text-neutral-400 mb-1">
            <span>Progress</span>
            <span>
              {masteredCount}/{totalCount} ({progressPctSafe}%)
            </span>
          </div>

          {/* Bar + non-clipped glow */}
          <div className="relative">
            <div className="h-2 w-full rounded-full bg-neutral-800 overflow-hidden">
              <div
                className="h-full bg-green-600 rounded-full transition-[width] duration-500"
                style={{ width: `${progressPctSafe}%` }}
              />
            </div>
            <div
              className="pointer-events-none absolute left-0 top-1/2 -translate-y-1/2 z-20"
              style={{ width: `${progressPctSafe}%` }}
            >
              <div className="h-4 w-full rounded-full blur-[10px] bg-green-400/40 mix-blend-screen" />
            </div>
          </div>
        </div>

        {/* Title is managed on the Dashboard now */}

        <div className="mt-4 mb-2">
          <div className="text-sm text-neutral-400 uppercase">Title</div>
          <div className="text-lg font-semibold">{title}</div>
        </div>

        <ul className="space-y-1">
          {initial.subtopics.map((s, i) => (
            <li key={s.id}>
              <button
                onClick={() => canSelect(i) && ui.setState({ currentIndex: i })}
                disabled={!canSelect(i)}
                className={`w-full rounded-md px-4 py-3.5 text-left text-sm leading-snug transition-colors ${
                  i > unlockedIndex
                    ? 'text-neutral-600'
                    : i === currentIndex
                      ? 'bg-neutral-800 font-semibold text-white'
                      : 'text-neutral-300 hover:bg-neutral-900'
                }`}
              >
                {s.title}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      {/* Center: Explanation + Quiz */}
      <main ref={mainRef} className="lg:col-span-6">
        {currentSubtopic ? (
          <div className="space-y-8">
            <div className="card p-6 md:p-8 xl:p-10">
              <h3 className="text-3xl font-bold tracking-tight">{currentSubtopic.title}</h3>
              <div className="mt-2 flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-neutral-400">
                <span>Importance: {currentSubtopic.importance}</span> <span>•</span>{' '}
                <span>Difficulty: {currentSubtopic.difficulty}</span>
              </div>
              <div className="mt-6 flex items-center gap-2 border-t border-neutral-800/50 pt-4">
                <span className="text-sm font-medium text-neutral-400">Style:</span>
                <button
                  onClick={() => fetchExplanation('default')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Default
                </button>
                <button
                  onClick={() => fetchExplanation('simplified')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Simplified
                </button>
                <button
                  onClick={() => fetchExplanation('detailed')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Detailed
                </button>
                <button
                  onClick={() => fetchExplanation('example')}
                  className="rounded-md bg-neutral-800 px-3 py-1 text-sm hover:bg-neutral-700"
                >
                  Example
                </button>
              </div>
              <hr className="my-6 border-neutral-800" />
              <div id="lesson-markdown" data-lesson="markdown" className="markdown">
                <ReactMarkdown remarkPlugins={[remarkGfm, remarkMath]} rehypePlugins={[rehypeKatex]}>
                  {stripLeadingTitle(explanations[currentSubtopic.id] || '', currentSubtopic.title) || 'Crafting learning module...'}
                </ReactMarkdown>
              </div>
            </div>

            {(() => {
              const lessonMd = stripLeadingTitle(explanations[currentSubtopic.id] || '', currentSubtopic.title).trim();
              const hasLesson = lessonMd.length >= 50;
              return (
                <div className="quiz-panel card p-6 md:p-8 xl:p-10">
                  <h3 className="mb-6 text-2xl font-bold tracking-tight">Mastery Check</h3>
                  {!hasLesson && (
                    <p className="mb-4 text-sm text-neutral-400">
                      Waiting for the lesson to finish… quiz will be prepared right after.
                    </p>
                  )}
                   <QuizPanel
                    key={currentSubtopic.id}
                    subtopicId={currentSubtopic.id}
                    subtopicTitle={currentSubtopic.title}
                    overview={currentSubtopic.overview}
                    explanationReady={Boolean(explanationDone[currentSubtopic.id])}
                    lectureId={initial.id}
                    lessonMd={lessonMd}
                     questions={questionsById[currentSubtopic.id] || currentSubtopic.questions}
                    reserveQuestions={reserveQuestions}
                    releaseQuestions={releaseQuestions}
                    onPassed={async () => {
  const id = currentSubtopic.id;
  if (!countedIdsRef.current.has(id)) {
    countedIdsRef.current.add(id);
    setMasteredCount((m) => Math.min(totalCount, m + 1));
  }

                  /* END-OF-LECTURE */
                  const isLast = currentIndex === initial.subtopics.length - 1;
                  // Persist mastery in background (non-blocking)
                  try { void fetch('/api/mastery', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ subtopicId: currentSubtopic.id }),
                  }); } catch {}

                  if (isLast) {
                    // Mark complete so progress bar hits 100%
                    setIsCompleted(true);
                    setShowSparkle(true);
                    // Smoothly scroll to the top so the user can see the full progress bar
                    if (typeof requestAnimationFrame !== 'undefined') {
                      requestAnimationFrame(() => scrollToMainTop());
                    } else {
                      scrollToMainTop();
                    }
                    // Keep sparkle briefly, then hide
                    setTimeout(() => setShowSparkle(false), 1200);
                    // Give time for the bar's 500ms animation and the scroll to finish before redirecting
                    setTimeout(() => {
                      try { router.push(`/learn/${initial.id}/complete`); } catch {}
                    }, 1600);
                    return;
                  }
                  // Optimistic advance
                  const idx = currentIndex;
                  const next = Math.min(idx + 1, initial.subtopics.length - 1);
                  ui.setState({
                    currentIndex: next,
                    unlockedIndex: Math.max(unlockedIndex, next),
                  });
                  scrollToMainTop();
                      // No duplicate await; background call above
                    }}
                    onQuestionsSaved={(saved) => {
                      try {
                        const id = currentSubtopic.id;
                        setQuestionsById((prev) => ({ ...prev, [id]: saved }));
                      } catch {}
                    }}
                  />
                </div>
              );
            })()}
          </div>
        ) : (
          <div className="flex h-full min-h-[60vh] items-center justify-center rounded-lg border-2 border-dashed border-neutral-800 text-neutral-500">
            <p>Select a subtopic to begin</p>
          </div>
        )}
      </main>

      {/* Right: AI Tutor */}
      <aside className="sticky top-24 h-[calc(100vh-8rem)] self-start lg:col-span-3">
        <ChatPanel documentContent={initial.originalContent} />
      </aside>
    </div>
  );
}

/* ------------------------------ QuizPanel --------------------------------- */

function QuizPanel({
  subtopicId,
  subtopicTitle,
  overview,
  explanationReady,
  lectureId,
  lessonMd,
  questions,
  onPassed,
  onQuestionsSaved,
  reserveQuestions,
  releaseQuestions,
}: {
  subtopicId: string;
  subtopicTitle: string;
  overview?: string;
  explanationReady: boolean;
  lectureId: string;
  lessonMd?: string;
  questions: QuizQuestion[];
  onPassed: () => void;
  onQuestionsSaved?: (saved: QuizQuestion[]) => void;
  reserveQuestions?: (id: string) => boolean;
  releaseQuestions?: (id: string) => void;
}) {
  const stripABCD = (str: string) =>
    (str ?? '').replace(/^\s*[A-Da-d]\s*[.)-:]\s*/, '').trim();

  const [items, setItems] = useState<QuizQuestion[]>(() => questions || []);
  const [answers, setAnswers] = useState<number[]>([]);
  const [revealed, setRevealed] = useState(false);
  const [loadingAnother, setLoadingAnother] = useState(false);
  const [hardLoaded, setHardLoaded] = useState(false);
  const REQUIRED_QUESTIONS = 2;
  const hasRequired = items.length >= REQUIRED_QUESTIONS;

  // Reset when subtopic questions change
  useEffect(() => {
    setItems(questions || []);
    setAnswers([]);
    setRevealed(false);
    setHardLoaded(false);
  }, [questions.map((q) => q.id).join('|')]);

  const setAns = (qIndex: number, ansIndex: number) => {
    const next = [...answers];
    next[qIndex] = ansIndex;
    setAnswers(next);
  };

  const allCorrect =
    items && items.length > 0 && items.every((q, i) => answers[i] === q.answerIndex);
  const twoCorrect = hasRequired && answers[0] === items[0]?.answerIndex && answers[1] === items[1]?.answerIndex;

  const check = () => setRevealed(true);
  const tryAgain = () => setRevealed(false);

  // Optionally fetch questions from lesson content until we have REQUIRED_QUESTIONS
  useEffect(() => {
    // Only start once the explanation is fully ready to preserve question quality
    if (!explanationReady) return;
    if (hardLoaded || items.length >= REQUIRED_QUESTIONS) return;
    const lessonPayload = (lessonMd || '').trim();
    if (lessonPayload.length < 50) return;
    // Prevent duplicate generations (e.g., StrictMode double invoke / re-mounts)
    const reserved = reserveQuestions ? reserveQuestions(subtopicId) : true;
    if (!reserved) return;

    (async () => {
      let success = false;
      try {
        let needed = Math.max(0, REQUIRED_QUESTIONS - items.length);
        const generated: Array<{ prompt: string; options: string[]; answerIndex: number; explanation: string }> = [];
        let tries = 0;
        const MAX_TRIES = 4 * Math.max(1, needed);
        while (needed > 0 && tries < MAX_TRIES) {
          tries++;
          const res = await fetch('/api/quiz', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ lessonMd: lessonPayload, difficulty: 'hard', subtopicTitle, lectureId, overview }),
          });
          if (!res.ok) continue;
          const data = (await res.json()) as {
            questions: Array<{ prompt: string; options: string[]; answerIndex: number; explanation: string }>;
            debug?: any;
          };
          try { if (data?.debug) console.debug('[quiz]', { subtopicId, debug: data.debug }); } catch {}
          const q = data.questions?.[0];
          if (!q) continue;
          generated.push({ prompt: q.prompt, options: q.options, answerIndex: q.answerIndex, explanation: q.explanation });
          needed--;
        }
        if (generated.length) {
          // Persist to DB so these questions have stable IDs and survive reloads
          const save = await fetch('/api/quiz/questions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ subtopicId, questions: generated }),
          });
          if (save.ok) {
            const payload = (await save.json()) as {
              questions: Array<{ id: string; prompt: string; options: string[]; answerIndex: number; explanation: string }>;
            };
            const saved = (payload.questions || []).slice(0, REQUIRED_QUESTIONS);
            if (saved.length) {
              setItems(saved);
              setAnswers([]);
              setRevealed(false);
              success = true;
              // Inform parent so future mounts use the saved questions and avoid re-generating
              try { onQuestionsSaved?.(saved as unknown as QuizQuestion[]); } catch {}
            }
          }
        }
      } catch {
        // swallow
      } finally {
        setHardLoaded((prev) => prev || success);
        try { releaseQuestions?.(subtopicId); } catch {}
      }
    })();
  }, [explanationReady, lessonMd, hardLoaded, items.length, subtopicId, subtopicTitle, reserveQuestions, releaseQuestions]);

  const askAnother = async () => {
    setLoadingAnother(true);
    try {
      const payload = (lessonMd || '').trim();
      if (payload.length < 50) throw new Error('lesson too short');
      const res = await fetch('/api/quiz', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ lessonMd: payload, difficulty: 'hard', subtopicTitle, lectureId, overview }),
      });
      if (!res.ok) {
        const e = await res.json().catch(() => ({}));
        throw new Error(e.error || `HTTP ${res.status}`);
      }
      const data = (await res.json()) as {
        questions: Array<{ prompt: string; options: string[]; answerIndex: number; explanation: string }>;
        debug?: any;
      };
      try { if (data?.debug) console.debug('[quiz/another]', { subtopicId, debug: data.debug }); } catch {}
      const q = data.questions?.[0];
      if (!q) throw new Error('No question returned');
      // Persist the one we generated if we still need more
      if (items.length < REQUIRED_QUESTIONS) {
        const save = await fetch('/api/quiz/questions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            subtopicId,
            questions: [{ prompt: q.prompt, options: q.options, answerIndex: q.answerIndex, explanation: q.explanation }],
          }),
        });
        if (save.ok) {
          const payload = (await save.json()) as {
            questions: Array<{ id: string; prompt: string; options: string[]; answerIndex: number; explanation: string }>;
          };
          const saved = (payload.questions || []).slice(0, REQUIRED_QUESTIONS);
          if (saved.length) {
            setItems(saved);
            setAnswers([]);
            setRevealed(false);
            try { onQuestionsSaved?.(saved as unknown as QuizQuestion[]); } catch {}
          }
        }
      }
    } catch (_e) {
      // Fallback: rotate options of the first question
      if (items && items.length > 0) {
        const base = items[0];
        const rotated = [...base.options];
        rotated.push(rotated.shift() as string);
        const newAnswer = (base.answerIndex - 1 + rotated.length) % rotated.length;
        setItems([
          {
            ...base,
            id: `${base.id}-v${Date.now()}`,
            prompt: `${base.prompt} (Variant)`,
            options: rotated,
            answerIndex: newAnswer,
            explanation: base.explanation,
          },
        ]);
        setAnswers([]);
        setRevealed(false);
      }
    } finally {
      setLoadingAnother(false);
    }
  };
  if (items.length < REQUIRED_QUESTIONS && !hardLoaded) {
    return <p className="text-sm text-neutral-400">Preparing questions…</p>;
  }


  if (explanationReady && (!items || items.length === 0) && hardLoaded) {
    return <p className="text-sm text-neutral-400">No quiz questions for this subtopic.</p>;
  }

  return (
    <div className="space-y-4">
      <ul className="space-y-6">
        {items.map((q, i) => {
          const selected = answers[i];
          const isAllCorrect = allCorrect;
          return (
            <li key={q.id} className="space-y-3">
              <div className="font-medium text-neutral-200 chat-md">
                <ReactMarkdown
                  remarkPlugins={[remarkGfm, remarkMath]}
                  rehypePlugins={[rehypeKatex]}
                  components={{
                    em: (props) => <em className="font-semibold not-italic" {...props} />,
                  }}
                >
                  {q.prompt}
                </ReactMarkdown>
              </div>
              <div className="grid gap-2">
                {q.options.map((o, j) => {
                  const isSelected = selected === j;
                  const isCorrect = revealed && j === q.answerIndex;
                  const isIncorrect = revealed && isSelected && j !== q.answerIndex;
                  const buttonClass = `rounded-md border p-3 text-left transition-all text-sm ${
                    isCorrect
                      ? 'border-green-500 bg-green-900/30'
                      : isIncorrect
                        ? 'border-red-500 bg-red-900/30'
                        : isSelected
                          ? 'border-blue-500 bg-blue-900/20'
                          : 'border-neutral-700 hover:bg-neutral-800'
                  }`;
                  return (
                    <button
                      key={j}
                      onClick={async () => {
                        setAns(i, j);
                        try {
                          // Record attempt (fire-and-forget)
                          void fetch('/api/quiz/attempt', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                              questionId: q.id,
                              selectedIndex: j,
                              isCorrect: j === q.answerIndex,
                            }),
                          });
                        } catch {}
                      }}
                      className={buttonClass}
                      disabled={revealed && isAllCorrect}
                    >
                      {stripABCD(o)}
                    </button>
                  );
                })}
              </div>
              {revealed && (
                <div className="mt-4 border-t border-neutral-800 pt-3 text-sm text-neutral-400 chat-md">
                  <ReactMarkdown remarkPlugins={[remarkGfm, remarkMath]} rehypePlugins={[rehypeKatex]}>
                    {q.explanation}
                  </ReactMarkdown>
                </div>
              )}
            </li>
          );
        })}
      </ul>

      <div className="flex flex-wrap items-center gap-4 pt-4">
        {!revealed && (
          <button
            onClick={check}
            disabled={items.length === 0}
            className="rounded-md bg-[rgb(var(--accent))] px-5 py-2 font-semibold text-black disabled:opacity-50"
          >
            Check Answer
          </button>
        )}

        {revealed && twoCorrect && (
          <>
            <button
              onClick={onPassed}
              className="rounded-md bg-green-600 px-4 py-2 text-sm font-semibold text-white hover:bg-green-500"
            >
              Go to next subtopic
            </button>
            <button
              onClick={askAnother}
              disabled={loadingAnother}
              className="rounded-md border border-neutral-600 bg-neutral-800 px-4 py-2 text-sm font-semibold text-white hover:bg-neutral-700 disabled:opacity-50"
            >
              {loadingAnother ? 'Generating...' : 'Try Another Question'}
            </button>
          </>
        )}
      </div>
    </div>
  );
}
</file>

</files>
