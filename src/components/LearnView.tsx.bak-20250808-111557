'use client';

import { useMemo, useState, useEffect, useCallback, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import ChatPanel from '@/components/ChatPanel';
import {
  deriveUnlockedIndex,
  type LearnLecture,
  type LearnSubtopic,
  type QuizQuestion,
} from '@/lib/shared/learn-types';
import { createLearnUIStore } from '@/lib/client/learn-ui-store';
import { renameLecture } from '@/lib/client/rename-lecture';

export default function LearnView({ initial }: { initial: LearnLecture }) {
  // Initialize UI-only store
  const initialUnlocked = deriveUnlockedIndex(initial.subtopics);
  const storeRef = useRef(
    createLearnUIStore({
      currentIndex: initialUnlocked,
      unlockedIndex: initialUnlocked,
    })
  );
  const ui = storeRef.current;

  const currentSubtopic = initial.subtopics[ui.getState().currentIndex];

  // Local title editing state
  const [title, setTitle] = useState(initial.title);
  const [isSavingTitle, setIsSavingTitle] = useState(false);
  const [saveMsg, setSaveMsg] = useState<string | null>(null);

  // "Saved to Dashboard" is inherent once lecture exists in DB; we just expose a button for UX// Explanations cache per subtopic
  const [explanations, setExplanations] = useState<Record<string, string>>(() =>
    Object.fromEntries(
      initial.subtopics.map((s) => [s.id, s.explanation || ''])
    )
  );

  const canSelect = (i: number) => i <= ui.getState().unlockedIndex;

  useEffect(() => {
    const u = deriveUnlockedIndex(initial.subtopics);
    ui.setState((s) => ({
      ...s,
      unlockedIndex: Math.max(u, s.unlockedIndex),
      currentIndex: Math.max(
        0,
        Math.min(s.currentIndex, initial.subtopics.length - 1)
      ),
    }));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initial.subtopics.map((s) => s.mastered).join('|')]);

  const fetchExplanation = useCallback(
    async (
      style: 'default' | 'simplified' | 'detailed' | 'example' = 'default'
    ) => {
      const s = currentSubtopic;
      if (!s) return;
      setExplanations((e) => ({ ...e, [s.id]: 'Loading...' }));
      try {
        const res = await fetch('/api/explain-db', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ subtopicId: s.id, style }),
        });
        if (!res.ok) {
          const e = await res.json().catch(() => ({}));
          throw new Error(e.error || `HTTP ${res.status}`);
        }
        const data = (await res.json()) as { explanation: string };
        setExplanations((e) => ({ ...e, [s.id]: data.explanation }));
      } catch (e: any) {
        setExplanations((ex) => ({
          ...ex,
          [s.id]: 'Could not generate explanation. ' + e.message,
        }));
      }
    },
    [currentSubtopic]
  );

  useEffect(() => {
    const s = currentSubtopic;
    if (s && !explanations[s.id]) {
      fetchExplanation('default');
    }
  }, [currentSubtopic, explanations, fetchExplanation]);

  const handleRename = async () => {
    if (!title.trim() || title.trim().length < 3) {
      setSaveMsg('Title must be at least 3 characters.');
      return;
    }
    try {
      setIsSavingTitle(true);
      setSaveMsg(null);
      const res = await renameLecture(initial.id, title.trim());
      setSaveMsg('Lecture title saved.');
    } catch (e: any) {
      setSaveMsg(e.message || 'Failed to save title.');
    } finally {
      setIsSavingTitle(false);
      setTimeout(() => setSaveMsg(null), 2500);
    }
  };

  const handleSaveToDashboard = async () => {
    // The lecture already exists in DB; we simply give user feedback and a quick link.setTimeout(() => setSavedHint(null), 2500);
  };

  return (
    <div className="grid grid-cols-1 lg:grid-cols-12 gap-8 lg:gap-10 xl:gap-12 px-2 md:px-4">
      {/* Left: Outline */}
      <aside className="space-y-5 self-start rounded-lg border border-neutral-800 p-6 lg:p-7 xl:p-8 lg:col-span-3">
        <h2 className="text-xl font-semibold">Lecture</h2>

        <div className="flex flex-wrap items-center gap-3 sm:flex-nowrap">
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full rounded-md bg-neutral-900 px-3 py-2 ring-1 ring-neutral-700 outline-none"
            aria-label="Lecture title"
          />
          <button onClick={askAnother} disabled={loadingAnother} className="rounded-md border border-neutral-600 px-4 py-2 text-sm hover:bg-neutral-900 disabled:opacity-50">{loadingAnother ? 'Generatingâ€¦' : 'Ask me another question'}</button>
            <button
              onClick={onPassed}
              className="rounded-md bg-green-600 px-4 py-2 text-sm font-semibold text-white hover:bg-green-500"
            >
              Go to next subtopic
            </button>
          </>
        )}

        {revealed && !allCorrect && (
          <button
            onClick={tryAgain}
            className="rounded-md border border-neutral-600 px-4 py-2 text-sm hover:bg-neutral-900"
          >
            Try Again
          </button>
        )}
      </div>
    </div>
  );
}
